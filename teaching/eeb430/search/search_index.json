{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"EEB30 Modelling in Ecology and Evolution Mathematics is central to science because it provides a rigorous way to go from a set of assumptions to their logical consequences. In ecology & evolution this might be how we think a virus will spread and evolve, how climate change will impact a threatened population, or how much genetic diversity we expect to see in a randomly mating population. In this course you'll learn how to build, analyze, and interpret mathematical models of increasing complexity through readings, lectures, tutorials, assignments, computer labs, and a final project. Our focus is on deterministic dynamical models (recursions and differential equations) but we'll also touch on probability theory and stochastic simulations near the end. Please see the University of Toronto Academic Calendar for more details on the course prerequisites and additional information on the distribution/breadth requirements this course satisfies.","title":"Overview"},{"location":"acknowledgements/","text":"Acknowledgements This course is based on a fantastic textbook by Sally Otto and Troy Day , A biologist's guide to mathematical modeling in ecology and evolution . I've been fortunate to have been taught by both of these excellent mentors and I hope I can do them and their book justice. I'm also very grateful to Leithen M'Gonigle who has slickly elaborated on Sally's lecture notes in LaTeX and kindly shared them with me. Thanks also to Ailene McPherson who, along with Sally and Leithen, continues to help me teach this course and inspires me to become a better teacher. Thanks are also due to Puneeth Deraje who has gone above and beyond as a TA. And you wouldn't be reading this without the help of Tom Ouellette who did an amazing job creating this website. Finally, thanks to all the students who have taken the course and given me feedback (explicit or not) -- thanks for your patience!","title":"Acknowledgements"},{"location":"acknowledgements/#acknowledgements","text":"This course is based on a fantastic textbook by Sally Otto and Troy Day , A biologist's guide to mathematical modeling in ecology and evolution . I've been fortunate to have been taught by both of these excellent mentors and I hope I can do them and their book justice. I'm also very grateful to Leithen M'Gonigle who has slickly elaborated on Sally's lecture notes in LaTeX and kindly shared them with me. Thanks also to Ailene McPherson who, along with Sally and Leithen, continues to help me teach this course and inspires me to become a better teacher. Thanks are also due to Puneeth Deraje who has gone above and beyond as a TA. And you wouldn't be reading this without the help of Tom Ouellette who did an amazing job creating this website. Finally, thanks to all the students who have taken the course and given me feedback (explicit or not) -- thanks for your patience!","title":"Acknowledgements"},{"location":"labs/schedule/","text":"Schedule Lab Topic Notebook 1 Introduction to Jupyter, Python, and SymPy 2 Simulating recursion equations 3 Numerical and graphical techniques - 4 Equilibria and stability (univariate) - 5 General solutions (univariate) - 6 Midterm - 7 Linear algebra in SymPy - 8 Multivariate models - 9 Demography - 10 Evolutionary invasion analysis - 11 Stochastic models of evolution - 12 Stochastic population dynamics - To access a lab, click on the image. The easiest option is then to \"Open with Google Colaboratory\", but you can also download the notebook and open it locally (this requires you install Jupyter, Python, and required Python libraries).","title":"Schedule"},{"location":"labs/schedule/#schedule","text":"Lab Topic Notebook 1 Introduction to Jupyter, Python, and SymPy 2 Simulating recursion equations 3 Numerical and graphical techniques - 4 Equilibria and stability (univariate) - 5 General solutions (univariate) - 6 Midterm - 7 Linear algebra in SymPy - 8 Multivariate models - 9 Demography - 10 Evolutionary invasion analysis - 11 Stochastic models of evolution - 12 Stochastic population dynamics - To access a lab, click on the image. The easiest option is then to \"Open with Google Colaboratory\", but you can also download the notebook and open it locally (this requires you install Jupyter, Python, and required Python libraries).","title":"Schedule"},{"location":"lectures/lecture-01/","text":"{ requestKernel: true, mountActivateWidget: true, mountStatusWidget: true, binderOptions: { repo: \"tomouellette/executable-cells\", ref: \"main\", binderUrl: \"https://gke.mybinder.org\", }, } Lecture 1: Introduction Run notes interactively? Lecture overview Why use mathematical models in ecology and evolution? Syllabus 1. Why use mathematical models in ecology and evolution? Mathematics permeates ecology and evolution, from simple back-of-the-envelope calculations to the development of sophisticated mathematical models. This is because mathematics is a unique tool that can take what we already know (or assume to be true) and rigorously lead us to the logical conclusions. To see this (while also introducing you to the kind of models I work with), let's look at a few examples. Example 1: HIV See sections 1.2-1.4 of the text for more info. Human immunodeficiency virus (HIV) is, as the name suggests, a virus that infects humans and causes acquired immunodeficiency syndrome (AIDS). This is a terrible diesase that has caused over 20 million deaths worldwide. It is transmitted via bodily fluids. Once inside the body HIV particles (virions) attach to a protein called CD4 on the cell membrane of helper T cells (part of our immune system) and others. Once attached, the virus inserts its RNA into the host cell, which is reverse transcribed into DNA and becomes part of the host genome. The host cell can remain in the 'latently infected' state for some time. When the viral DNA is eventually transcribed by the host cell, starting an 'active infection', hundreds of new virions are produced, often killing the host cell. These new virions then go on to infect other CD4+ cells. A large decline in the number of helper T cells is what causes AIDS. This is because helper T cells bind to viruses and secrete chemical signals to stimulate the immune system. So without helper T cells the immune system is very comprimised. Based on this, once infected with HIV (and without treatment) we expect the number of virions to rapidly increase and the number of helper T cells to decline. This is generally what is observed. However, the number of virions then tends to steeply decline. Why might this be? Here are two hypotheses: the immune system recognizes HIV and suppresses it the decline in helper T cells prevents HIV from replicating To decide whether the second hypothesis is valid Phillips (1996) built a mathematical model describing the rate of change in the number of CD4+ cells and free virions. See the note below for the details of the model if you are interested (but don't worry if you don't understand all this yet!). Details of the Philips (1996) model See Box 2.4 in the text for more details. Philips built a dynamical model of the infection process using 4 differential equations: \\(\\frac{dR}{dt} = \\Gamma \\tau - \\mu R - \\beta V R\\) \\(\\frac{dL}{dt} = p \\beta V R - \\mu L - \\alpha L\\) \\(\\frac{dE}{dt} = (1 - p) \\beta V R + \\alpha L - \\delta E\\) \\(\\frac{dV}{dt} = \\pi E - \\sigma V\\) These equations describe the rate of change in the number of susceptible CD4+ cells (R), latently infected cells (L), actively infected cells (E), and free virions (V). These are the 4 \"variables\" of the model, as their values change over time. The remainder of the symbols represent \"parameters\", whose values do not change (they are constants). The meaning of the parameters and the values used by Phillips (1996) are shown in the table below. Symbol Description Value (units/day) \\(\\Gamma\\) Rate that CD4+ cells are produced 1.36 \\(\\tau\\) Proportion of CD4+ cells that are susceptible to attack 0.2 \\(\\mu\\) HIV-independent death rate of susceptible CD4+ cells 1.36 x 10^-3 \\(\\beta\\) Rate of CD4+ cell infection per HIV virion 0.00027 \\(p\\) Proportion of newly infected cells becoming latently infected 0.1 \\(\\alpha\\) Activation rate of latently infected cells 3.6 x 10^-2 \\(\\delta\\) Death rate of actively infected cells 0.33 \\(\\pi\\) Rate of production of virions by actively infected cells 100 \\(\\sigma\\) Removal rate of cell-free virus 2 Given these parameter descriptions, can you \"read\" the differential equations above? For example, what does \\(\\Gamma \\tau\\) represent, biologically? Using these equations and parameter values Philips (1996) asked how the number of CD4+ cells (R + L + E) and free virions (V) changed over time following infection. To see how Philips' model behaves, activate the kernel at the top of the page and run the code below import numpy as np import matplotlib.pyplot as plt # Build a function to iterate through the model (see note above for description of equations) def philips_model(R=200, L=0, E=0, V=4e-5, days=120, steps=120): #choose parameter values gamma, mu, tau, beta, p, alpha, sigma, delta, pi = [1.36, 1.36e-3, 0.2, 0.00027, 0.1, 3.6e-2, 2, 0.33, 100] record = [] for t in np.linspace(0, days, steps): dRdt = gamma * tau - mu * R - beta * V * R R += dRdt dLdt = p * beta * V * R - mu * L - alpha * L L += dLdt dEdt = (1-p) * beta * V * R + alpha * L - delta * E E += dEdt dVdt = pi * E - sigma * V V += dVdt record += ([[R + L + E, V]]) return np.array(record) # Interpolate through differentials and record population sizes steps = 120 days = 120 uninfected_lymphocytes, free_virions = philips_model(days=days, steps=steps).T number_of_days = np.linspace(1, days, steps) # Initialize plot fig, left_ax = plt.subplots() right_ax = left_ax.twinx() fig.set_size_inches(8,4) # Plot data on left axis left_ax.plot(number_of_days, uninfected_lymphocytes, color='green', label='R'); left_ax.set_ylabel('CD4+ cells (R + E + L)', fontsize=14) left_ax.legend(frameon=False, bbox_to_anchor=(0.99, 0.99)) left_ax.set_xlabel('Days from infection', fontsize=14) # Plot data on right axis right_ax.plot(number_of_days, free_virions, color='darkred', label='V'); right_ax.set_ylabel('Free virions V', fontsize=14) right_ax.legend(frameon=False, bbox_to_anchor=(0.99, 0.85)) # Format plot and show it plt.yscale('log') fig.tight_layout() plt.show() Compare to Figure 1.3 and Figure 1.4 in the text. We see the initial increase in virions (red) and delcine in CD4+ cells (green), followed by a decline virions (note the log scale on the right axis -- this is a big decline, from over 1000 to about 10). Because this model does not include an immune response against the virions but still exhibits the decline in virions, we conclude that the second hypothesis is valid, that it is theoretically plausible that the decline in virions is due to a lack of CD4+ cells to infect. A few years later this hypothesis was empirically tested and validated -- a nice example of theory guiding science. Feel free to play around with the code above, changing parameter values or even the structure of the model. Do the dynamics change as you expected? Example 2: Extreme Events A second example is a model that I helped Dr. Kelsey Lyberger (then a PhD student at UC Davis with Sebastian Schreiber) with in Lyberger et al 2021 . Kelsey Lyberger, doing Daphnia fieldwork I assume. Kelsey was interested in how populations respond to extreme climatic events, like hurricanes. It has long been clear that such events can impact the size of a population, e.g., by causing extra mortality, and may in fact put populations at risk of extinction. More recently it has become apparent that extreme events can also impose strong natural selection, and that populations can quickly adapt to the new environment. Some examples include: Ice-storms select on sparrow body size Hurricanes select on lizard limbs and toe pads Droughts select on Darwin finch beaks Droughts select on flowering time in Brassica Now, how should such rapid adaptive evolution impact population size? This is the question Kelsey set out to answer with a mathematical model. To do: give details of Kelsey's model Below is a stochastic simulation much like that used by Kelsey. With an activated kernel, run the code below to create a plot very similar to Figure 1 in Lyberger et al. (this may take a minute). import numpy as np import matplotlib.pyplot as plt def lyberger_model(Vg=0.75, Ve=0, event_duration=1, seed=0, other_parameters=[120, 500, 1, 2, 100, 0, 2.5]): # Unpack parameters generations, K, w, lmbda, event_time, initial_theta_t, dtheta_t = other_parameters # Initialize population members = np.random.normal(initial_theta_t, 0, K) # Run simulations np.random.seed(seed) population_size, mean_breeding_value = [], [] for g in range(generations): if g in np.arange(event_time, event_time + event_duration): theta_t = initial_theta_t + dtheta_t else: theta_t = initial_theta_t # Viability selection prob_survival = np.array([np.exp(-(theta_t - z + np.random.normal(0, Ve))**2 / (2*w**2)) for z in members]) survived = np.array([True if p > np.random.uniform(0,1) else False for p in prob_survival]) if len(survived) == 0: break # Survivors members = members[survived] # Random mating offspring = [] for m in np.random.choice(members, len(members)): if len(offspring) > K: offspring = np.random.choice(offspring, K) break else: n_off = np.random.poisson(lmbda) mate = np.random.choice(members) offspring += [(m + mate)/2 for _ in range(n_off)] # Sample new trait values for offspring offspring = np.array(offspring) offspring = np.random.normal(offspring, Vg) # Record statistics population_size.append(len(offspring)) mean_breeding_value.append(np.mean(offspring)) members = offspring return ( np.arange(0, generations-event_time+1), np.array(population_size[event_time-1:]), np.array(mean_breeding_value[event_time-1:]) ) # Initialize plot fig, ax = plt.subplots(2, sharex=True) fig.set_size_inches(8,6) event_duration = 1 # Run 10 simulations per segregation (V0) and environment variance (VE) parameter combination for Vg, Ve, c, lab in [[1, 0, 'black', 'with evolution'], [0, 1, 'red', 'without evolution']]: # Plot simulations simulations = np.array([lyberger_model(Vg=Vg, Ve=Ve, event_duration=event_duration, seed=s) for s in range(10)]) ax[0].plot(simulations[:,0].T, simulations[:,1].T, color=c, alpha=0.3); ax[1].plot(simulations[:,0].T, simulations[:,2].T, color=c, alpha=0.3); # Hack together only one instance of the legend ax[0].plot([np.min(simulations[:,0].T)], [np.min(simulations[:,1].T)], alpha=1, label = lab, color=c) ax[1].plot([np.min(simulations[:,0].T)], [np.min(simulations[:,2].T)], alpha=1, label = lab, color=c) # Add environmental event duration ax[0].fill_between([0,event_duration], y1=500, alpha=0.2) ax[1].fill_between([0,event_duration], y1=-0.2, y2=2, alpha=0.2) # Add labels ax[0].set_ylabel('Population size', fontsize=12) ax[1].set_ylabel('Mean trait value', fontsize=12) ax[1].set_xlabel('Generation', fontsize=14) # Add legend plt.legend(frameon=False) plt.show() The key result, that you can see in the plot above, is that when extreme events are short, adaptive evolution (black lines) can paradoxically reduce population size (relative to the red lines, where there is no evolution). The reason for this is that, while during the extreme event (shaded section) evolution is adaptive, once the extreme event ends the population finds itself maladapted to the original environment. Adaptive evolution can therefore hamper population persistence, and this is an important thing to keep in mind when documenting rapid adaptive evolution in response to extreme events -- it is not necessarily a good thing for the species (or our conservation goals). Example 3: Sex chromosomes A third example is a model that I worked on during my PhD, led by fellow PhD student Dr. Michael Scott, in Scott et al. 2018 . Michael Scott, with snakes and penguins. The inspiration for this model comes from the fact that new sex determination systems are constantly evolving, as can be deduced from this phylogeny. For example, it is clear from this phylogeny that ZW sex determination (where females are ZW and males are ZZ) has evolved multiple times (eg, in both birds/reptiles and lepidoptera). Figure 3 from Bachtrog et al. 2014 Sex vs gender Here we are referring to biological sex (defined by the type of gametes produced by an individual) not gender (defined by behaviour and morphology). For more information see https://gendersexandnature.wordpress.com and https://genderinclusivebiology.squarespace.com/ . Focusing solely on sex chromosomes (as opposed to hermaphroditism or environmental sex determination (ESD)), there are two main hypotheses for changes in sex determination systems: A \"selfish\" Y chromosome gets in more than 50% of male gametes \\(\\rightarrow\\) more than 50% of the population is male (\"sex-ratio bias\") \\(\\rightarrow\\) a W chromosome, which causes all its carriers to be female, invades because individuals of the rarer sex have more offspring (since every offspring has a female and male parent). Selection favours different copies of a gene in the two sexes (\"sexually-antagonistic selection\") \\(\\rightarrow\\) the chromosome carrying this gene becomes a new sex chromosome, allowing the gene copy (\"allele\") favoured in males to be on the Y chromosome (and therefore only in males) and the allele favoured in females to be on the X (which is in females 2/3 of the time). A key element missing from both of these hypotheses (and models supporting them) is selection that occurs during the haploid phase of the life-cycle (eg, competition between pollen grains for fertilization of an ovule). This \"haploid selection\" is important to consider because it can cause both sex-ratio bias (eg, if pollen grains carrying a Y are more successful than those carrying an X) and sexually-antagonistic selection (eg, if selection at the haploid phase differs between gamete types). It can also cause selection to differ at the haploid and diploid stages of the life-cycle (\"ploidally-antagonistic selection\"). So how is haploid selection expected to affect turnover between sex determination systems? Michael and I built a model to ask this question, with the help of Sally Otto (our supervisor), and used many of the techniques covered in this class to analyze it. To do: add model details (Placeholder) Modelling plan discussed on the way home from a conference This was quite a complicated model and analysis, but the general take-home was that haploid selection greatly increases the scope for sex chromosome turnover. For example, in the plot below we see a case where selection favours one allele in male gametes (eg, during pollen competition) and another allele in diploids (ie, this is ploidally-antagonistic selection). Despite the fact that it causes sex-ratio bias (dashed curve), the Y chromosome spreads through the population (black and gray curves), while at the same time a W chromosome invades (blue curve) and equalizes the sex ratio. To do: add code to create this plot Sex chromosome turnover. The conclusion we reached from this mathematical model -- that haploid selection is expected to lead to more turnovers in sex determination systems -- was simultaneously supported by work done in Stephen Wright's lab here in EEB, by (then undergrad and now PhD student) George Sandler in Sandler et al. 2018 . 2. Syllabus OK, now that we've gone over some motivating examples of modeling in ecology and evolution, let's take a look at how we're going to learn to become modelers in this course. Point your browser over to the syllabus and read each of the pages there.","title":"Lecture 1"},{"location":"lectures/lecture-01/#lecture-1-introduction","text":"Run notes interactively?","title":"Lecture 1: Introduction"},{"location":"lectures/lecture-01/#lecture-overview","text":"Why use mathematical models in ecology and evolution? Syllabus","title":"Lecture overview"},{"location":"lectures/lecture-01/#1-why-use-mathematical-models-in-ecology-and-evolution","text":"Mathematics permeates ecology and evolution, from simple back-of-the-envelope calculations to the development of sophisticated mathematical models. This is because mathematics is a unique tool that can take what we already know (or assume to be true) and rigorously lead us to the logical conclusions. To see this (while also introducing you to the kind of models I work with), let's look at a few examples.","title":"1. Why use mathematical models in ecology and evolution?"},{"location":"lectures/lecture-01/#example-1-hiv","text":"See sections 1.2-1.4 of the text for more info. Human immunodeficiency virus (HIV) is, as the name suggests, a virus that infects humans and causes acquired immunodeficiency syndrome (AIDS). This is a terrible diesase that has caused over 20 million deaths worldwide. It is transmitted via bodily fluids. Once inside the body HIV particles (virions) attach to a protein called CD4 on the cell membrane of helper T cells (part of our immune system) and others. Once attached, the virus inserts its RNA into the host cell, which is reverse transcribed into DNA and becomes part of the host genome. The host cell can remain in the 'latently infected' state for some time. When the viral DNA is eventually transcribed by the host cell, starting an 'active infection', hundreds of new virions are produced, often killing the host cell. These new virions then go on to infect other CD4+ cells. A large decline in the number of helper T cells is what causes AIDS. This is because helper T cells bind to viruses and secrete chemical signals to stimulate the immune system. So without helper T cells the immune system is very comprimised. Based on this, once infected with HIV (and without treatment) we expect the number of virions to rapidly increase and the number of helper T cells to decline. This is generally what is observed. However, the number of virions then tends to steeply decline. Why might this be? Here are two hypotheses: the immune system recognizes HIV and suppresses it the decline in helper T cells prevents HIV from replicating To decide whether the second hypothesis is valid Phillips (1996) built a mathematical model describing the rate of change in the number of CD4+ cells and free virions. See the note below for the details of the model if you are interested (but don't worry if you don't understand all this yet!). Details of the Philips (1996) model See Box 2.4 in the text for more details. Philips built a dynamical model of the infection process using 4 differential equations: \\(\\frac{dR}{dt} = \\Gamma \\tau - \\mu R - \\beta V R\\) \\(\\frac{dL}{dt} = p \\beta V R - \\mu L - \\alpha L\\) \\(\\frac{dE}{dt} = (1 - p) \\beta V R + \\alpha L - \\delta E\\) \\(\\frac{dV}{dt} = \\pi E - \\sigma V\\) These equations describe the rate of change in the number of susceptible CD4+ cells (R), latently infected cells (L), actively infected cells (E), and free virions (V). These are the 4 \"variables\" of the model, as their values change over time. The remainder of the symbols represent \"parameters\", whose values do not change (they are constants). The meaning of the parameters and the values used by Phillips (1996) are shown in the table below. Symbol Description Value (units/day) \\(\\Gamma\\) Rate that CD4+ cells are produced 1.36 \\(\\tau\\) Proportion of CD4+ cells that are susceptible to attack 0.2 \\(\\mu\\) HIV-independent death rate of susceptible CD4+ cells 1.36 x 10^-3 \\(\\beta\\) Rate of CD4+ cell infection per HIV virion 0.00027 \\(p\\) Proportion of newly infected cells becoming latently infected 0.1 \\(\\alpha\\) Activation rate of latently infected cells 3.6 x 10^-2 \\(\\delta\\) Death rate of actively infected cells 0.33 \\(\\pi\\) Rate of production of virions by actively infected cells 100 \\(\\sigma\\) Removal rate of cell-free virus 2 Given these parameter descriptions, can you \"read\" the differential equations above? For example, what does \\(\\Gamma \\tau\\) represent, biologically? Using these equations and parameter values Philips (1996) asked how the number of CD4+ cells (R + L + E) and free virions (V) changed over time following infection. To see how Philips' model behaves, activate the kernel at the top of the page and run the code below import numpy as np import matplotlib.pyplot as plt # Build a function to iterate through the model (see note above for description of equations) def philips_model(R=200, L=0, E=0, V=4e-5, days=120, steps=120): #choose parameter values gamma, mu, tau, beta, p, alpha, sigma, delta, pi = [1.36, 1.36e-3, 0.2, 0.00027, 0.1, 3.6e-2, 2, 0.33, 100] record = [] for t in np.linspace(0, days, steps): dRdt = gamma * tau - mu * R - beta * V * R R += dRdt dLdt = p * beta * V * R - mu * L - alpha * L L += dLdt dEdt = (1-p) * beta * V * R + alpha * L - delta * E E += dEdt dVdt = pi * E - sigma * V V += dVdt record += ([[R + L + E, V]]) return np.array(record) # Interpolate through differentials and record population sizes steps = 120 days = 120 uninfected_lymphocytes, free_virions = philips_model(days=days, steps=steps).T number_of_days = np.linspace(1, days, steps) # Initialize plot fig, left_ax = plt.subplots() right_ax = left_ax.twinx() fig.set_size_inches(8,4) # Plot data on left axis left_ax.plot(number_of_days, uninfected_lymphocytes, color='green', label='R'); left_ax.set_ylabel('CD4+ cells (R + E + L)', fontsize=14) left_ax.legend(frameon=False, bbox_to_anchor=(0.99, 0.99)) left_ax.set_xlabel('Days from infection', fontsize=14) # Plot data on right axis right_ax.plot(number_of_days, free_virions, color='darkred', label='V'); right_ax.set_ylabel('Free virions V', fontsize=14) right_ax.legend(frameon=False, bbox_to_anchor=(0.99, 0.85)) # Format plot and show it plt.yscale('log') fig.tight_layout() plt.show() Compare to Figure 1.3 and Figure 1.4 in the text. We see the initial increase in virions (red) and delcine in CD4+ cells (green), followed by a decline virions (note the log scale on the right axis -- this is a big decline, from over 1000 to about 10). Because this model does not include an immune response against the virions but still exhibits the decline in virions, we conclude that the second hypothesis is valid, that it is theoretically plausible that the decline in virions is due to a lack of CD4+ cells to infect. A few years later this hypothesis was empirically tested and validated -- a nice example of theory guiding science. Feel free to play around with the code above, changing parameter values or even the structure of the model. Do the dynamics change as you expected?","title":"Example 1: HIV"},{"location":"lectures/lecture-01/#example-2-extreme-events","text":"A second example is a model that I helped Dr. Kelsey Lyberger (then a PhD student at UC Davis with Sebastian Schreiber) with in Lyberger et al 2021 . Kelsey Lyberger, doing Daphnia fieldwork I assume. Kelsey was interested in how populations respond to extreme climatic events, like hurricanes. It has long been clear that such events can impact the size of a population, e.g., by causing extra mortality, and may in fact put populations at risk of extinction. More recently it has become apparent that extreme events can also impose strong natural selection, and that populations can quickly adapt to the new environment. Some examples include: Ice-storms select on sparrow body size Hurricanes select on lizard limbs and toe pads Droughts select on Darwin finch beaks Droughts select on flowering time in Brassica Now, how should such rapid adaptive evolution impact population size? This is the question Kelsey set out to answer with a mathematical model. To do: give details of Kelsey's model Below is a stochastic simulation much like that used by Kelsey. With an activated kernel, run the code below to create a plot very similar to Figure 1 in Lyberger et al. (this may take a minute). import numpy as np import matplotlib.pyplot as plt def lyberger_model(Vg=0.75, Ve=0, event_duration=1, seed=0, other_parameters=[120, 500, 1, 2, 100, 0, 2.5]): # Unpack parameters generations, K, w, lmbda, event_time, initial_theta_t, dtheta_t = other_parameters # Initialize population members = np.random.normal(initial_theta_t, 0, K) # Run simulations np.random.seed(seed) population_size, mean_breeding_value = [], [] for g in range(generations): if g in np.arange(event_time, event_time + event_duration): theta_t = initial_theta_t + dtheta_t else: theta_t = initial_theta_t # Viability selection prob_survival = np.array([np.exp(-(theta_t - z + np.random.normal(0, Ve))**2 / (2*w**2)) for z in members]) survived = np.array([True if p > np.random.uniform(0,1) else False for p in prob_survival]) if len(survived) == 0: break # Survivors members = members[survived] # Random mating offspring = [] for m in np.random.choice(members, len(members)): if len(offspring) > K: offspring = np.random.choice(offspring, K) break else: n_off = np.random.poisson(lmbda) mate = np.random.choice(members) offspring += [(m + mate)/2 for _ in range(n_off)] # Sample new trait values for offspring offspring = np.array(offspring) offspring = np.random.normal(offspring, Vg) # Record statistics population_size.append(len(offspring)) mean_breeding_value.append(np.mean(offspring)) members = offspring return ( np.arange(0, generations-event_time+1), np.array(population_size[event_time-1:]), np.array(mean_breeding_value[event_time-1:]) ) # Initialize plot fig, ax = plt.subplots(2, sharex=True) fig.set_size_inches(8,6) event_duration = 1 # Run 10 simulations per segregation (V0) and environment variance (VE) parameter combination for Vg, Ve, c, lab in [[1, 0, 'black', 'with evolution'], [0, 1, 'red', 'without evolution']]: # Plot simulations simulations = np.array([lyberger_model(Vg=Vg, Ve=Ve, event_duration=event_duration, seed=s) for s in range(10)]) ax[0].plot(simulations[:,0].T, simulations[:,1].T, color=c, alpha=0.3); ax[1].plot(simulations[:,0].T, simulations[:,2].T, color=c, alpha=0.3); # Hack together only one instance of the legend ax[0].plot([np.min(simulations[:,0].T)], [np.min(simulations[:,1].T)], alpha=1, label = lab, color=c) ax[1].plot([np.min(simulations[:,0].T)], [np.min(simulations[:,2].T)], alpha=1, label = lab, color=c) # Add environmental event duration ax[0].fill_between([0,event_duration], y1=500, alpha=0.2) ax[1].fill_between([0,event_duration], y1=-0.2, y2=2, alpha=0.2) # Add labels ax[0].set_ylabel('Population size', fontsize=12) ax[1].set_ylabel('Mean trait value', fontsize=12) ax[1].set_xlabel('Generation', fontsize=14) # Add legend plt.legend(frameon=False) plt.show() The key result, that you can see in the plot above, is that when extreme events are short, adaptive evolution (black lines) can paradoxically reduce population size (relative to the red lines, where there is no evolution). The reason for this is that, while during the extreme event (shaded section) evolution is adaptive, once the extreme event ends the population finds itself maladapted to the original environment. Adaptive evolution can therefore hamper population persistence, and this is an important thing to keep in mind when documenting rapid adaptive evolution in response to extreme events -- it is not necessarily a good thing for the species (or our conservation goals).","title":"Example 2: Extreme Events"},{"location":"lectures/lecture-01/#example-3-sex-chromosomes","text":"A third example is a model that I worked on during my PhD, led by fellow PhD student Dr. Michael Scott, in Scott et al. 2018 . Michael Scott, with snakes and penguins. The inspiration for this model comes from the fact that new sex determination systems are constantly evolving, as can be deduced from this phylogeny. For example, it is clear from this phylogeny that ZW sex determination (where females are ZW and males are ZZ) has evolved multiple times (eg, in both birds/reptiles and lepidoptera). Figure 3 from Bachtrog et al. 2014 Sex vs gender Here we are referring to biological sex (defined by the type of gametes produced by an individual) not gender (defined by behaviour and morphology). For more information see https://gendersexandnature.wordpress.com and https://genderinclusivebiology.squarespace.com/ . Focusing solely on sex chromosomes (as opposed to hermaphroditism or environmental sex determination (ESD)), there are two main hypotheses for changes in sex determination systems: A \"selfish\" Y chromosome gets in more than 50% of male gametes \\(\\rightarrow\\) more than 50% of the population is male (\"sex-ratio bias\") \\(\\rightarrow\\) a W chromosome, which causes all its carriers to be female, invades because individuals of the rarer sex have more offspring (since every offspring has a female and male parent). Selection favours different copies of a gene in the two sexes (\"sexually-antagonistic selection\") \\(\\rightarrow\\) the chromosome carrying this gene becomes a new sex chromosome, allowing the gene copy (\"allele\") favoured in males to be on the Y chromosome (and therefore only in males) and the allele favoured in females to be on the X (which is in females 2/3 of the time). A key element missing from both of these hypotheses (and models supporting them) is selection that occurs during the haploid phase of the life-cycle (eg, competition between pollen grains for fertilization of an ovule). This \"haploid selection\" is important to consider because it can cause both sex-ratio bias (eg, if pollen grains carrying a Y are more successful than those carrying an X) and sexually-antagonistic selection (eg, if selection at the haploid phase differs between gamete types). It can also cause selection to differ at the haploid and diploid stages of the life-cycle (\"ploidally-antagonistic selection\"). So how is haploid selection expected to affect turnover between sex determination systems? Michael and I built a model to ask this question, with the help of Sally Otto (our supervisor), and used many of the techniques covered in this class to analyze it. To do: add model details (Placeholder) Modelling plan discussed on the way home from a conference This was quite a complicated model and analysis, but the general take-home was that haploid selection greatly increases the scope for sex chromosome turnover. For example, in the plot below we see a case where selection favours one allele in male gametes (eg, during pollen competition) and another allele in diploids (ie, this is ploidally-antagonistic selection). Despite the fact that it causes sex-ratio bias (dashed curve), the Y chromosome spreads through the population (black and gray curves), while at the same time a W chromosome invades (blue curve) and equalizes the sex ratio. To do: add code to create this plot Sex chromosome turnover. The conclusion we reached from this mathematical model -- that haploid selection is expected to lead to more turnovers in sex determination systems -- was simultaneously supported by work done in Stephen Wright's lab here in EEB, by (then undergrad and now PhD student) George Sandler in Sandler et al. 2018 .","title":"Example 3: Sex chromosomes"},{"location":"lectures/lecture-01/#2-syllabus","text":"OK, now that we've gone over some motivating examples of modeling in ecology and evolution, let's take a look at how we're going to learn to become modelers in this course. Point your browser over to the syllabus and read each of the pages there.","title":"2. Syllabus"},{"location":"lectures/lecture-02/","text":"{ requestKernel: true, mountActivateWidget: true, mountStatusWidget: true, binderOptions: { repo: \"tomouellette/executable-cells\", ref: \"main\", binderUrl: \"https://gke.mybinder.org\", }, } Lecture 2: Model construction Run notes interactively? Lecture overview Constructing a model Evolution and the Hardy-Weinberg equilibrium 1. Constructing a model Although many problems require specific formulations and assumptions, there are a few general principles to constructing a model. i. Formulate the question What do you want to know? Describe the model in the form of a question. Simplify, Simplify! Start with the simplest, biologically reasonable description of the problem. ii. Determine the basic ingredients Define the variables in the model. Describe any constraints on the variables. Describe any interactions between variables. Decide whether you will treat time as discrete or continuous. Choose a time scale (i.e., decide what a time step equals in discrete time and specify whether rates will be measured per second, minute, day, year, generation, etc.). Define the parameters in the model. Describe any constraints on the parameters. iii. Qualitatively describe the biological system For continuous-time models, draw a flow diagram to describe changes to the variables over time. For example, if we had a population experiencing migration, death, and birth we could draw the following. graph LR; A((n)) --birth--> A; B[ ] --migration--> A; A --death--> C[ ]; style B height:0px; style C height:0px; Figure. Continuous time flow diagram. For discrete-time models, draw a life-cycle diagram with all the events that occur each time unit. For example, if we were modeling a population that experienced migration, then birth, then death each time step, we could draw the following. graph LR; A((n)) --migration--> B((n')); B --birth--> C((n'')); C --death--> A; Figure. Discrete-time life-cycle diagram. For discrete time models with multiple variables and events, construct a table listing the outcome of every event. We'll see an example of this below. iv. Quantitatively describe the biological system Using the diagrams and tables as a guide, write down the equations. Perform checks. Are the constraints on the variables still met as time passes? Make sure that the units of the right-hand side equal those on the left-hand side. For continuous-time models, add rates for arrows coming in to the flow diagram and subtract rates for arrows coming out of the flow diagram. For example, in the model shown above the rate of change in the number of individuals, \\(\\frac{\\mathrm{d} n(t)}{\\mathrm{d} t}\\) , is \\[ \\frac{\\mathrm{d} n(t)}{\\mathrm{d} t} = m + b n(t) - d n(t) \\] where \\(m\\) , \\(b\\) , and \\(d\\) are the per capita (ie, per individual) rates of migration, birth, and death. In discrete time, you must take into account the order of events when constructing equations. To build an equation for the population size in the next generation, \\(n(t+1)\\) , based on the life-cycle diagram above, first construct an equation for each event \\[n' = n_t + m\\] \\[n'' = n' + bn'\\] \\[n_{t+1} = n'' - dn''\\] Note Note that \\(m\\) and \\(d\\) are now the fraction of individuals that migrate and die, and \\(b\\) is the number of offspring per parent (above these parameters were all rates ). Next, substitute \\(n''\\) and then \\(n'\\) into the equation for \\(n_{t+1}\\) to write \\(n_{t+1}\\) in terms of \\(n_t\\) \\[ \\begin{aligned} n_{t+1} &= n'' \u2212 dn'' \\\\ &= (n' + bn\u2032) \u2212 d(n' + bn\u2032) \\\\ &= n'(1 + b \u2212 d \u2212 db) \\\\ &= (n_t +m)(1+b\u2212d\u2212db) \\\\ \\end{aligned} \\] We now have a recursion equation that correctly takes into account the order of the life cycle (migration, birth, death) and the point at which the census is taken (immediately after death). v. Analyze the equations Start by using the equations to simulate and graph the changes to the system over time. Choose and perform appropriate analyses. Make sure that the analyses can address the problem. vi. Checks and balances Check the results against data or any known special cases. Determine how general the results are. Consider alternatives to the simplest model. Extend or simplify the model, as appropriate, and repeat steps 2-5. vii. Relate the results back to the question Do the results answer the biological question? Are the results counter-intuitive? Why? Interpret the results verbally, and describe conceptually any new insights into the biological process. Describe potential experiments. 2. Evolution and the Hardy-Weinberg equilibrium Natural selection Natural selection requires three conditions be met ( Lewontin 1970 ): Variation in traits: different individuals have different traits Variation in fitness: different traits have different rates of survival and/or reproduction Fitness is heritable: traits are inherited to some degree Although selection is an important idea, it's impossible to know what kind of observations are consistent with selection if we don't have a baseline to compare against. So let's first construct a model of evolution in the absence of selection using the general steps described in section 1, Constructing a model . Evolution in the absence of selection i. Formulate the question What do you want to know How do allele frequencies change over time in the absence of natural selection? Boil the question down In a diploid population with two variant \"alleles\" of a gene (A and a), how will the frequency of the A allele change over time? Simple, biologically reasonable description We assume that each diploid genotype (AA, Aa, and aa) has equal fitness and that individuals reproduce and then die (non-overlapping generations). We also assume that individuals produce haploid gametes that form a gamete pool. Gametes within the gamete pool unite at random to produce the next generation of diploid individuals. ii. Determine the basic ingredients Variables \\(x\\) = frequency of AA individuals \\(y\\) = frequency of Aa individuals \\(z\\) = frequency of aa individuals From this we can extract the allele frequencies the frequency of A is \\(p = x + y/2\\) (ie, all of the alleles in genotype AA ( \\(x\\) ) are A but only 1/2 of the alleles in genotype Aa ( \\(y\\) ) are A) the frequency of a is \\(q = 1 - p = y/2 + z\\) Constraints on these variables \\(x\\) , \\(y\\) , \\(z\\) are \\(\u22650\\) and \\(\u22641\\) \\(x+y+z=1\\) How we'll treat time We will follow the genotype frequencies from one generation to the next, using a discrete-time model Parameters there are no parameters in this model (which is a little bit unusual) iii. Qualitatively describe the biological system Gametes unite at random in the gamete pool to produce diploid offspring. These offspring grow into adults that undergo meiosis, creating gametes, and die. Below we draw the life-cycle diagram. graph LR; A((random<br> union)) --diploid--> B((meiosis)); B --haploid--> A; iv. Quantiatively describe the biological system To calculate the frequency of each genoytpe in the next generation we use a table of events. The \"Union\" column indicates the pair of gametes that are meeting each other, the \"Frequency\" column indicates the proportion of gamete pairs in the population with this particular union, and the remaining columns indicate which diploid genotype is created by the union. Union Frequency AA Aa aa A x A \\(p^2\\) 1 0 0 A x a \\(pq\\) 0 1 0 a x A \\(qp\\) 0 1 0 a x a \\(q^2\\) 0 0 1 \\(p^2\\) \\(2pq\\) \\(q^2\\) The genotype frequencies denoted in red are known as the Hardy-Weinberg frequencies . Note that this table shows that populations not at \"Hardy-Weinberg equilibrium\" reach Hardy-Weinberg equilibrium after only one generation of random mating. We now have the frequency of genotypes in the next generation in terms of the allele frequencies in the previous generation, \\[x' = p^2\\] \\[y' = 2pq\\] \\[z' = q^2\\] To understand how the genotype frequencies at Hardy-Weinberg vary with allele frequency, we can plot them. from sympy import * var('p') x = p**2 #frequency of AA at Hardy-Weinberg as a function of the frequency of allele A y = 2*p*(1-p) #freq of Aa z = (1-p)**2 #freq of aa p = plot(x, y, z, #functions that we are plotting (p,0,1), #plot as a function of allele frequency from 0 to 1 xlabel=\"allele frequency, $p$\", ylabel=\"genotype frequency\", legend=True, show=False ) p[0].label='AA' #give legend genotype labels p[1].label='Aa' p[2].label='aa' p.show() From this plot we see, for example, that the frequency of heterozygotes, Aa, is maximized at intermediate allele frequencies. Subbing in \\(p=x+y/2\\) and \\(q=y/2+z\\) we get the recursion equations describing the frequency of diploid genotypes in the next generation as a function of the diploid genotypes in the current generation, \\[x' = (x + y/2)^2\\] \\[y' = 2(x + y/2)(y/2 + z)\\] \\[z' = (y/2 + z)^2\\] v. Analyze the equations Now back to our question. What is the frequency of allele A in the next generation? \\[p' = x' + y'/2\\] \\[p' = p^2 + 2pq/2\\] \\[p' = p(p + q)\\] \\[p' = p\\] vi. Checks and balances Does \\(x' + y' + z' = 1\\) ? \\[ \\begin{aligned} x' + y' + z' &= p^2 + 2pq + q^2\\\\ &= (p+q)^2\\\\ &= (1)^2\\\\ &= 1 \\end{aligned} \\] vii. Relate the results back to the question How do allele frequencies change over time in the absence of natural selection? They don't Data example: blood types Below is a table describing the frequency of three different blood types (and their associated genotype) in a sample of humans from the USA. Blood type M MN N Genotype MM MN NN Observed frequency in USA 0.292 0.496 0.212 We ask, are these genotypes near Hardy-Weinberg equilibrium? First, write the frequency of each genotype as \\(x\\) , \\(y\\) , and \\(z\\) \\[x = 0.292\\] \\[y = 0.496\\] \\[z = 0.212\\] Next, convert the genotype frequencies into allele frequencies \\[p = x + y/2 = 0.540\\] \\[q = y/2 + z = 0.460\\] Now predict what the genotype frequencies would be at Hardy-Weinberg equilibrium \\[x = p^2 = 0.2916\\] \\[y = 2pq = 0.4985\\] \\[z = q^2 = 0.2116\\] These predicted genotype frequencies are exceptionally close to those actually observed, indicating Hardy-Weinberg equilibrium and suggesting an absence of selection on this phenotype.","title":"Lecture 2"},{"location":"lectures/lecture-02/#lecture-2-model-construction","text":"Run notes interactively?","title":"Lecture 2: Model construction"},{"location":"lectures/lecture-02/#lecture-overview","text":"Constructing a model Evolution and the Hardy-Weinberg equilibrium","title":"Lecture overview"},{"location":"lectures/lecture-02/#1-constructing-a-model","text":"Although many problems require specific formulations and assumptions, there are a few general principles to constructing a model.","title":"1. Constructing a model"},{"location":"lectures/lecture-02/#i-formulate-the-question","text":"What do you want to know? Describe the model in the form of a question. Simplify, Simplify! Start with the simplest, biologically reasonable description of the problem.","title":"i. Formulate the question"},{"location":"lectures/lecture-02/#ii-determine-the-basic-ingredients","text":"Define the variables in the model. Describe any constraints on the variables. Describe any interactions between variables. Decide whether you will treat time as discrete or continuous. Choose a time scale (i.e., decide what a time step equals in discrete time and specify whether rates will be measured per second, minute, day, year, generation, etc.). Define the parameters in the model. Describe any constraints on the parameters.","title":"ii. Determine the basic ingredients"},{"location":"lectures/lecture-02/#iii-qualitatively-describe-the-biological-system","text":"For continuous-time models, draw a flow diagram to describe changes to the variables over time. For example, if we had a population experiencing migration, death, and birth we could draw the following. graph LR; A((n)) --birth--> A; B[ ] --migration--> A; A --death--> C[ ]; style B height:0px; style C height:0px; Figure. Continuous time flow diagram. For discrete-time models, draw a life-cycle diagram with all the events that occur each time unit. For example, if we were modeling a population that experienced migration, then birth, then death each time step, we could draw the following. graph LR; A((n)) --migration--> B((n')); B --birth--> C((n'')); C --death--> A; Figure. Discrete-time life-cycle diagram. For discrete time models with multiple variables and events, construct a table listing the outcome of every event. We'll see an example of this below.","title":"iii. Qualitatively describe the biological system"},{"location":"lectures/lecture-02/#iv-quantitatively-describe-the-biological-system","text":"Using the diagrams and tables as a guide, write down the equations. Perform checks. Are the constraints on the variables still met as time passes? Make sure that the units of the right-hand side equal those on the left-hand side. For continuous-time models, add rates for arrows coming in to the flow diagram and subtract rates for arrows coming out of the flow diagram. For example, in the model shown above the rate of change in the number of individuals, \\(\\frac{\\mathrm{d} n(t)}{\\mathrm{d} t}\\) , is \\[ \\frac{\\mathrm{d} n(t)}{\\mathrm{d} t} = m + b n(t) - d n(t) \\] where \\(m\\) , \\(b\\) , and \\(d\\) are the per capita (ie, per individual) rates of migration, birth, and death. In discrete time, you must take into account the order of events when constructing equations. To build an equation for the population size in the next generation, \\(n(t+1)\\) , based on the life-cycle diagram above, first construct an equation for each event \\[n' = n_t + m\\] \\[n'' = n' + bn'\\] \\[n_{t+1} = n'' - dn''\\] Note Note that \\(m\\) and \\(d\\) are now the fraction of individuals that migrate and die, and \\(b\\) is the number of offspring per parent (above these parameters were all rates ). Next, substitute \\(n''\\) and then \\(n'\\) into the equation for \\(n_{t+1}\\) to write \\(n_{t+1}\\) in terms of \\(n_t\\) \\[ \\begin{aligned} n_{t+1} &= n'' \u2212 dn'' \\\\ &= (n' + bn\u2032) \u2212 d(n' + bn\u2032) \\\\ &= n'(1 + b \u2212 d \u2212 db) \\\\ &= (n_t +m)(1+b\u2212d\u2212db) \\\\ \\end{aligned} \\] We now have a recursion equation that correctly takes into account the order of the life cycle (migration, birth, death) and the point at which the census is taken (immediately after death).","title":"iv. Quantitatively describe the biological system"},{"location":"lectures/lecture-02/#v-analyze-the-equations","text":"Start by using the equations to simulate and graph the changes to the system over time. Choose and perform appropriate analyses. Make sure that the analyses can address the problem.","title":"v. Analyze the equations"},{"location":"lectures/lecture-02/#vi-checks-and-balances","text":"Check the results against data or any known special cases. Determine how general the results are. Consider alternatives to the simplest model. Extend or simplify the model, as appropriate, and repeat steps 2-5.","title":"vi. Checks and balances"},{"location":"lectures/lecture-02/#vii-relate-the-results-back-to-the-question","text":"Do the results answer the biological question? Are the results counter-intuitive? Why? Interpret the results verbally, and describe conceptually any new insights into the biological process. Describe potential experiments.","title":"vii. Relate the results back to the question"},{"location":"lectures/lecture-02/#2-evolution-and-the-hardy-weinberg-equilibrium","text":"","title":"2. Evolution and the Hardy-Weinberg equilibrium"},{"location":"lectures/lecture-02/#natural-selection","text":"Natural selection requires three conditions be met ( Lewontin 1970 ): Variation in traits: different individuals have different traits Variation in fitness: different traits have different rates of survival and/or reproduction Fitness is heritable: traits are inherited to some degree Although selection is an important idea, it's impossible to know what kind of observations are consistent with selection if we don't have a baseline to compare against. So let's first construct a model of evolution in the absence of selection using the general steps described in section 1, Constructing a model .","title":"Natural selection"},{"location":"lectures/lecture-02/#evolution-in-the-absence-of-selection","text":"","title":"Evolution in the absence of selection"},{"location":"lectures/lecture-02/#i-formulate-the-question_1","text":"What do you want to know How do allele frequencies change over time in the absence of natural selection? Boil the question down In a diploid population with two variant \"alleles\" of a gene (A and a), how will the frequency of the A allele change over time? Simple, biologically reasonable description We assume that each diploid genotype (AA, Aa, and aa) has equal fitness and that individuals reproduce and then die (non-overlapping generations). We also assume that individuals produce haploid gametes that form a gamete pool. Gametes within the gamete pool unite at random to produce the next generation of diploid individuals.","title":"i. Formulate the question"},{"location":"lectures/lecture-02/#ii-determine-the-basic-ingredients_1","text":"Variables \\(x\\) = frequency of AA individuals \\(y\\) = frequency of Aa individuals \\(z\\) = frequency of aa individuals From this we can extract the allele frequencies the frequency of A is \\(p = x + y/2\\) (ie, all of the alleles in genotype AA ( \\(x\\) ) are A but only 1/2 of the alleles in genotype Aa ( \\(y\\) ) are A) the frequency of a is \\(q = 1 - p = y/2 + z\\) Constraints on these variables \\(x\\) , \\(y\\) , \\(z\\) are \\(\u22650\\) and \\(\u22641\\) \\(x+y+z=1\\) How we'll treat time We will follow the genotype frequencies from one generation to the next, using a discrete-time model Parameters there are no parameters in this model (which is a little bit unusual)","title":"ii. Determine the basic ingredients"},{"location":"lectures/lecture-02/#iii-qualitatively-describe-the-biological-system_1","text":"Gametes unite at random in the gamete pool to produce diploid offspring. These offspring grow into adults that undergo meiosis, creating gametes, and die. Below we draw the life-cycle diagram. graph LR; A((random<br> union)) --diploid--> B((meiosis)); B --haploid--> A;","title":"iii. Qualitatively describe the biological system"},{"location":"lectures/lecture-02/#iv-quantiatively-describe-the-biological-system","text":"To calculate the frequency of each genoytpe in the next generation we use a table of events. The \"Union\" column indicates the pair of gametes that are meeting each other, the \"Frequency\" column indicates the proportion of gamete pairs in the population with this particular union, and the remaining columns indicate which diploid genotype is created by the union. Union Frequency AA Aa aa A x A \\(p^2\\) 1 0 0 A x a \\(pq\\) 0 1 0 a x A \\(qp\\) 0 1 0 a x a \\(q^2\\) 0 0 1 \\(p^2\\) \\(2pq\\) \\(q^2\\) The genotype frequencies denoted in red are known as the Hardy-Weinberg frequencies . Note that this table shows that populations not at \"Hardy-Weinberg equilibrium\" reach Hardy-Weinberg equilibrium after only one generation of random mating. We now have the frequency of genotypes in the next generation in terms of the allele frequencies in the previous generation, \\[x' = p^2\\] \\[y' = 2pq\\] \\[z' = q^2\\] To understand how the genotype frequencies at Hardy-Weinberg vary with allele frequency, we can plot them. from sympy import * var('p') x = p**2 #frequency of AA at Hardy-Weinberg as a function of the frequency of allele A y = 2*p*(1-p) #freq of Aa z = (1-p)**2 #freq of aa p = plot(x, y, z, #functions that we are plotting (p,0,1), #plot as a function of allele frequency from 0 to 1 xlabel=\"allele frequency, $p$\", ylabel=\"genotype frequency\", legend=True, show=False ) p[0].label='AA' #give legend genotype labels p[1].label='Aa' p[2].label='aa' p.show() From this plot we see, for example, that the frequency of heterozygotes, Aa, is maximized at intermediate allele frequencies. Subbing in \\(p=x+y/2\\) and \\(q=y/2+z\\) we get the recursion equations describing the frequency of diploid genotypes in the next generation as a function of the diploid genotypes in the current generation, \\[x' = (x + y/2)^2\\] \\[y' = 2(x + y/2)(y/2 + z)\\] \\[z' = (y/2 + z)^2\\]","title":"iv. Quantiatively describe the biological system"},{"location":"lectures/lecture-02/#v-analyze-the-equations_1","text":"Now back to our question. What is the frequency of allele A in the next generation? \\[p' = x' + y'/2\\] \\[p' = p^2 + 2pq/2\\] \\[p' = p(p + q)\\] \\[p' = p\\]","title":"v. Analyze the equations"},{"location":"lectures/lecture-02/#vi-checks-and-balances_1","text":"Does \\(x' + y' + z' = 1\\) ? \\[ \\begin{aligned} x' + y' + z' &= p^2 + 2pq + q^2\\\\ &= (p+q)^2\\\\ &= (1)^2\\\\ &= 1 \\end{aligned} \\]","title":"vi. Checks and balances"},{"location":"lectures/lecture-02/#vii-relate-the-results-back-to-the-question_1","text":"How do allele frequencies change over time in the absence of natural selection? They don't Data example: blood types Below is a table describing the frequency of three different blood types (and their associated genotype) in a sample of humans from the USA. Blood type M MN N Genotype MM MN NN Observed frequency in USA 0.292 0.496 0.212 We ask, are these genotypes near Hardy-Weinberg equilibrium? First, write the frequency of each genotype as \\(x\\) , \\(y\\) , and \\(z\\) \\[x = 0.292\\] \\[y = 0.496\\] \\[z = 0.212\\] Next, convert the genotype frequencies into allele frequencies \\[p = x + y/2 = 0.540\\] \\[q = y/2 + z = 0.460\\] Now predict what the genotype frequencies would be at Hardy-Weinberg equilibrium \\[x = p^2 = 0.2916\\] \\[y = 2pq = 0.4985\\] \\[z = q^2 = 0.2116\\] These predicted genotype frequencies are exceptionally close to those actually observed, indicating Hardy-Weinberg equilibrium and suggesting an absence of selection on this phenotype.","title":"vii. Relate the results back to the question"},{"location":"lectures/lecture-03/","text":"{ requestKernel: true, mountActivateWidget: true, mountStatusWidget: true, binderOptions: { repo: \"tomouellette/executable-cells\", ref: \"main\", binderUrl: \"https://gke.mybinder.org\", }, } Lecture 3: Exponential & logistic growth Run notes interactively? Lecture overview Introduction Exponential growth Logistic growth 1. Introduction In nature, population sizes change over time in response to a myriad of factors, such as weather competition, predation, disease, ... resource availability The simplest models describing changes in population size are exponential growth and logistic growth which assume a constant environment no interactions with other species The exponential model also assumes no competition among the members of a species for the available resources ( density-independent growth ), while the logistic model includes competition within a species ( density-dependent growth ). Both of these models can be described in discrete and continuous time. We\u2019ll start with the simpler exponential model. 2. Exponential growth Exponential growth in discrete time Imagine we start with \\(n_t\\) individuals at some time \\(t\\) . If we assume that each of these individuals produces \\(b\\) offspring, the number of individuals after reproduction is \\(n_t + n_t b = n_t(1 + b)\\) . If we then assume a fraction \\(d\\) die, the number of individuals remaining after death is \\(n_t(1+b) - n_t(1+b)d = n_t(1+b)(1-d)\\) . With no further events in the life-cycle, this is the expected number of individuals in the next generation, \\(n_{t+1}\\) , which we can write as \\[ \\begin{aligned} n_{t+1} &= n_t(1+b)(1-d) \\\\ &= n_t R \\\\ \\end{aligned} \\] where \\(R=(1+b)(1-d)\\) is a constant referred to as the reproductive factor . This equation, \\(n_{t+1}=n_t R\\) , is the recursion equation for exponential growth. Exponential vs geometric growth Technically this recursion equation describes \"geometric\" growth, since \\(n_t\\) will grow with \\(t\\) as a geometric series, but here we simply call it \"exponential growth in discrete time\" to make a clear connection with exponential growth in continuous time. We can also describe the change in the number of individuals by subtracting off the current number, \\[ \\begin{aligned} \\Delta n &= n_{t+1} - n_t\\\\ &= n_t(R-1) \\end{aligned} \\] This is the difference equation for exponential growth, with discrete-time growth rate \\(r_d = R-1 = (1+b)(1-d)-1 = b - d - bd\\) . Let's plot the dynamics described by these equations for a particular set of parameter values. import numpy as np import matplotlib.pyplot as plt def exponential_discrete(nt, b, d): '''recursion equation giving population size in next time step as a function of the population size at this time, nt, and the birth and death rates, b and d.''' return nt * (1 + b) * (1 - d) # Grow population nd, nt, b, d = [], 1, 0.2, 0.1 #define empty list nd to store population sizes and choose parameter values for t in np.arange(0,100): #for time from 0 to 99 nt = exponential_discrete(nt, b, d) #get the next population size from the recursion equation nd.append(nt) #and append it to the list # Plot growth fig, ax = plt.subplots() ax.scatter(np.arange(0, 100), nd) #plot population size at each time ax.set_xlabel('Time, $t$') ax.set_ylabel('Population size, $n_t$') plt.show() Exponential growth in continuous time Now assume that each individual continuously gives birth at rate \\(b\\) and dies at rate \\(d\\) . If there are \\(n_t\\) individuals in the population at time \\(t\\) , then the rate of change in the number of individuals is \\[ \\begin{aligned} \\frac{\\mathrm{d} n_t}{\\mathrm{d} t} &= n_t b - n_t d\\\\ &= n_t (b - d)\\\\ &= n_t r_c \\end{aligned} \\] This is the differential equation for exponential growth with continuous-time growth rate \\(r_c = b - d\\) . Note that the growth rate in the discrete-time model was \\(r_d = b - d - b d\\) . The difference between the two growth rates reflects the fact that birth and death cannot happen at the exact same time in the continuous-time model (so there is no \\(b d\\) term), while offspring that are born can die before the next generation in the discrete-time model (causing the \\(b d\\) term). Let's also plot these dynamics. Approximating a differential equation The differential equation describes the change in the population size in an \"infinitesimally\" small amount of time, \\(\\mathrm{d}t\\) . To plot these dynamics we therefore make an approximation, taking \\(\\mathrm{d}t\\) to be small, but not infinitely so. Rearranging the differential equation gives \\(\\mathrm{d}n_t = n_t(b-d)\\mathrm{d}t\\) and the population size after \\(\\mathrm{d}t\\) is therefore \\(n_{t+\\mathrm{d}t} = n_t + \\mathrm{d}n_t\\) . This is a recursion equation that approximates our differential equation. import numpy as np import matplotlib.pyplot as plt def exponential_continuous(nt, b, d, dt): '''approximation of the differential equation giving population size after a small time interval, dt, as a function of the population size at this time, nt, and the birth and death rates, b and d.''' return nt + nt * (b - d) * dt # Grow population nc, nt, dt = [], 1, 0.1 #define empty list nc to store population sizes and choose parameter values (keep b and d as above) for t in np.arange(0,100,dt): #for time from 0 to 99 by increments of dt nt = exponential_continuous(nt, b, d, dt) #get the next population size from the recursion equation nc.append(nt) #and append it to the list # Plot growth fig, ax = plt.subplots() ax.scatter(np.arange(0, 100, dt), nc) #plot population size at each time ax.set_xlabel('Time, $t$') ax.set_ylabel('Population size, $n_t$') plt.show() We can now combine our two plots to compare these two predictions, exponential growth in discrete vs. continuous time. # Plot growth fig, ax = plt.subplots() ax.scatter(np.arange(0, 100), nd, label='discrete time') #plot population size at each time ax.scatter(np.arange(0, 100, dt), nc, label='continuous time') #plot population size at each time ax.set_xlabel('Time, $t$') ax.set_ylabel('Population size, $n_t$') plt.legend() plt.show() Why the difference? The predictions are very similar at first but then noticeably diverge. The time of this divergence depends on the values of parameters \\(b\\) and \\(d\\) . Try increasing or decreasing both \\(b\\) and \\(d\\) and think about why it has that effect. Also think about why the continuous time model predicts a larger population size than the discrete time model. Hint: remember the difference in the growth rates between the two models is \\(bd\\) . The trouble with exponential growth Exponential growth cannot continue indefinitely. Take for example a population of pheasants on an island off the coast of Washington State. Just 8 pheasants were introduced in 1937, but the population then grew exponentially, tripling in size every year ( \\(R=3\\) ) for the first 5 years. Had this population continued to grow exponentially there would have been 7 million of them by the year 1950 and \\(10^{28}\\) by now \u2013 which at 2 kg per pheasant is 3000 times the mass of the earth!! In fact, Lack observed that \u201cthe figures suggest that the increase was slowing down and was about to cease, but at this point the island was occupied by the military and many of the birds shot.\u201d Although populations may initially experience exponential growth, resources eventually become depleted and competition becomes more severe. This suggests that we should change our model assumptions. 3. Logistic growth Exponential growth assumes the growth rate ( \\(r_d\\) , \\(r_c\\) ) is constant. Logistic growth relaxes this assumption, and instead assumes that the growth rate decreases linearly with population size, due to competition for resources within the population. Logistic growth in discrete time In discrete-time, the reproductive factor under logistic growth can be written as \\[R(n_t) = 1 + r\\left(1 - \\frac{n_t}{K}\\right)\\] Notice that each individual is expected to have one offspring ( \\(R=1\\) ) if the intrinsic growth rate (ie, growth rate when rare) is zero, \\(r = 0\\) , or if the population size is at carrying capacity , \\(n_t=K\\) . Try plotting the reproductive factor as a function of \\(n_t\\) for a few different values of \\(r\\) and \\(K\\) . # Reproductive factor for logistic growth def logistic_discrete(nt, r, K): '''reproductive factor in discrete logistic model with growth rate r and carrying capacity k''' return 1 + r * (1 - nt/K) # Compare a few different growth rates and carrying capacities fig, ax = plt.subplots() for r, K in zip([1, 2, 1], [100, 100, 50]): #for each pair of r and K values nt = np.linspace(0, 200) #for a range of population sizes from 0 to 200 R = logistic_discrete(nt, r, K) #calculate the reproductive factor ax.plot(nt, R, label=f\"r = {r}, K = {K}\") #and plot ax.plot(nt, [1 for i in nt], '--', color='gray') #1 line for reference ax.set_xlabel('Population size, $n_t$') ax.set_ylabel('Reproductive factor, $R$') ax.legend(frameon=False) plt.ylim(0,None) plt.show() The population size in the next generation is the expected number of offspring per parent times the the total number of parents \\[n_{t+1} = \\left(1 + r\\left(1-\\frac{n_t}{K}\\right)\\right)n_t\\] This is the recursion equation for logistic growth. This recursion is a non-linear function of \\(n_t\\) ( non-linear means that there is a term in the equation where the term is taken to some power other than 1; here if we expand out the recursion we get a \\(n_t^2\\) term ). This reflects the fact that logistic growth models an interaction between individuals (competition). The change in population size from one generation to the next, \\(\\Delta n\\) , is therefore \\[\\Delta n = n_{t+1} - n_t = r\\left(1 - \\frac{n_t}{K}\\right)n_t\\] Based on this difference equation, when will the population grow in size? Test out your answer by plotting population size over time in the discrete-time logistic model. Try changing the initial population size or carrying capacity so that \\(n_t > K\\) . # Initialize parameters n, nt, r, K = [], 1, 0.1, 100 #list, initial population size, intrinsic growth rate, carrying capacity # Grow population under logistic growth for t in np.arange(0, 100): nt = nt * logistic_discrete(nt, r, K) n.append(nt) # Plot growth fig, ax = plt.subplots() ax.scatter(np.arange(0, 100), n) ax.axhline(100, label=f\"K = {K}\", linestyle='dashed', color='gray') #carrying capacity as dashed line # Add annotations ax.set_xlabel('Time, $t$') ax.set_ylabel('Population size, $n_t$') plt.show() Logistic growth in continuous time The model of logistic growth in continuous time, as with discrete time, follows from the assumption that each individual has a growth rate that decreases as a linear function of the population size \\(r(1 - n_t/K)\\) . If there are \\(n_t\\) individuals in the population at time \\(t\\) , then the rate of change of the population size will be \\[\\frac{\\mathrm{d}n_t}{\\mathrm{d}t} = r\\left(1 - \\frac{n_t}{K}\\right)n_t\\] This is a differential equation of logistic growth. Note that in both discrete and continuous time the logistic growth model reduces to the exponential growth model as \\(n_t/K\\) approaches 0, i.e., when the population size is much smaller than the carrying capacity \\(n_t << K\\) . An example of logistic growth Dr. Sarah Otto cultured haploid (one copy of each chromosome) and diploid (two copies of each chromosome) populations of Saccharomyces cereviseae . She observed the following population sizes for the two types of cells: Figure. The size of haploid and diploid yeast populations in a controlled laboratory experiment. Although the populations grow nearly exponentially at first, growth decreased as population size increased (i.e., density-dependent growth was observed). The carrying capacity ( \\(K\\) ) is clearly larger for the haploid cells, but do haploid and diploid cells have different intrinsic growth rates ( \\(r\\) )? By fitting the logistic growth model described above to the data, Dr. Otto estimated the parameter values to be Haploid: r = 0.55, K = 3.7 x 10^8 Diploid: r = 0.55, K = 2.3 x 10^8 The growth rates therefore do not differ (visibly or statistically). With these parameter estimates, the logistic model nicely fits the data: Figure. Population size of haploid and diploid yeast fit with logistic growth models. Note: This may be a bit misleading, as such excellent model fits are rarely observed, especially outside the lab! To do: make the above plots in Python","title":"Lecture 3"},{"location":"lectures/lecture-03/#lecture-3-exponential-logistic-growth","text":"Run notes interactively?","title":"Lecture 3: Exponential &amp; logistic growth"},{"location":"lectures/lecture-03/#lecture-overview","text":"Introduction Exponential growth Logistic growth","title":"Lecture overview"},{"location":"lectures/lecture-03/#1-introduction","text":"In nature, population sizes change over time in response to a myriad of factors, such as weather competition, predation, disease, ... resource availability The simplest models describing changes in population size are exponential growth and logistic growth which assume a constant environment no interactions with other species The exponential model also assumes no competition among the members of a species for the available resources ( density-independent growth ), while the logistic model includes competition within a species ( density-dependent growth ). Both of these models can be described in discrete and continuous time. We\u2019ll start with the simpler exponential model.","title":"1. Introduction"},{"location":"lectures/lecture-03/#2-exponential-growth","text":"","title":"2. Exponential growth"},{"location":"lectures/lecture-03/#exponential-growth-in-discrete-time","text":"Imagine we start with \\(n_t\\) individuals at some time \\(t\\) . If we assume that each of these individuals produces \\(b\\) offspring, the number of individuals after reproduction is \\(n_t + n_t b = n_t(1 + b)\\) . If we then assume a fraction \\(d\\) die, the number of individuals remaining after death is \\(n_t(1+b) - n_t(1+b)d = n_t(1+b)(1-d)\\) . With no further events in the life-cycle, this is the expected number of individuals in the next generation, \\(n_{t+1}\\) , which we can write as \\[ \\begin{aligned} n_{t+1} &= n_t(1+b)(1-d) \\\\ &= n_t R \\\\ \\end{aligned} \\] where \\(R=(1+b)(1-d)\\) is a constant referred to as the reproductive factor . This equation, \\(n_{t+1}=n_t R\\) , is the recursion equation for exponential growth. Exponential vs geometric growth Technically this recursion equation describes \"geometric\" growth, since \\(n_t\\) will grow with \\(t\\) as a geometric series, but here we simply call it \"exponential growth in discrete time\" to make a clear connection with exponential growth in continuous time. We can also describe the change in the number of individuals by subtracting off the current number, \\[ \\begin{aligned} \\Delta n &= n_{t+1} - n_t\\\\ &= n_t(R-1) \\end{aligned} \\] This is the difference equation for exponential growth, with discrete-time growth rate \\(r_d = R-1 = (1+b)(1-d)-1 = b - d - bd\\) . Let's plot the dynamics described by these equations for a particular set of parameter values. import numpy as np import matplotlib.pyplot as plt def exponential_discrete(nt, b, d): '''recursion equation giving population size in next time step as a function of the population size at this time, nt, and the birth and death rates, b and d.''' return nt * (1 + b) * (1 - d) # Grow population nd, nt, b, d = [], 1, 0.2, 0.1 #define empty list nd to store population sizes and choose parameter values for t in np.arange(0,100): #for time from 0 to 99 nt = exponential_discrete(nt, b, d) #get the next population size from the recursion equation nd.append(nt) #and append it to the list # Plot growth fig, ax = plt.subplots() ax.scatter(np.arange(0, 100), nd) #plot population size at each time ax.set_xlabel('Time, $t$') ax.set_ylabel('Population size, $n_t$') plt.show()","title":"Exponential growth in discrete time"},{"location":"lectures/lecture-03/#exponential-growth-in-continuous-time","text":"Now assume that each individual continuously gives birth at rate \\(b\\) and dies at rate \\(d\\) . If there are \\(n_t\\) individuals in the population at time \\(t\\) , then the rate of change in the number of individuals is \\[ \\begin{aligned} \\frac{\\mathrm{d} n_t}{\\mathrm{d} t} &= n_t b - n_t d\\\\ &= n_t (b - d)\\\\ &= n_t r_c \\end{aligned} \\] This is the differential equation for exponential growth with continuous-time growth rate \\(r_c = b - d\\) . Note that the growth rate in the discrete-time model was \\(r_d = b - d - b d\\) . The difference between the two growth rates reflects the fact that birth and death cannot happen at the exact same time in the continuous-time model (so there is no \\(b d\\) term), while offspring that are born can die before the next generation in the discrete-time model (causing the \\(b d\\) term). Let's also plot these dynamics. Approximating a differential equation The differential equation describes the change in the population size in an \"infinitesimally\" small amount of time, \\(\\mathrm{d}t\\) . To plot these dynamics we therefore make an approximation, taking \\(\\mathrm{d}t\\) to be small, but not infinitely so. Rearranging the differential equation gives \\(\\mathrm{d}n_t = n_t(b-d)\\mathrm{d}t\\) and the population size after \\(\\mathrm{d}t\\) is therefore \\(n_{t+\\mathrm{d}t} = n_t + \\mathrm{d}n_t\\) . This is a recursion equation that approximates our differential equation. import numpy as np import matplotlib.pyplot as plt def exponential_continuous(nt, b, d, dt): '''approximation of the differential equation giving population size after a small time interval, dt, as a function of the population size at this time, nt, and the birth and death rates, b and d.''' return nt + nt * (b - d) * dt # Grow population nc, nt, dt = [], 1, 0.1 #define empty list nc to store population sizes and choose parameter values (keep b and d as above) for t in np.arange(0,100,dt): #for time from 0 to 99 by increments of dt nt = exponential_continuous(nt, b, d, dt) #get the next population size from the recursion equation nc.append(nt) #and append it to the list # Plot growth fig, ax = plt.subplots() ax.scatter(np.arange(0, 100, dt), nc) #plot population size at each time ax.set_xlabel('Time, $t$') ax.set_ylabel('Population size, $n_t$') plt.show() We can now combine our two plots to compare these two predictions, exponential growth in discrete vs. continuous time. # Plot growth fig, ax = plt.subplots() ax.scatter(np.arange(0, 100), nd, label='discrete time') #plot population size at each time ax.scatter(np.arange(0, 100, dt), nc, label='continuous time') #plot population size at each time ax.set_xlabel('Time, $t$') ax.set_ylabel('Population size, $n_t$') plt.legend() plt.show() Why the difference? The predictions are very similar at first but then noticeably diverge. The time of this divergence depends on the values of parameters \\(b\\) and \\(d\\) . Try increasing or decreasing both \\(b\\) and \\(d\\) and think about why it has that effect. Also think about why the continuous time model predicts a larger population size than the discrete time model. Hint: remember the difference in the growth rates between the two models is \\(bd\\) .","title":"Exponential growth in continuous time"},{"location":"lectures/lecture-03/#the-trouble-with-exponential-growth","text":"Exponential growth cannot continue indefinitely. Take for example a population of pheasants on an island off the coast of Washington State. Just 8 pheasants were introduced in 1937, but the population then grew exponentially, tripling in size every year ( \\(R=3\\) ) for the first 5 years. Had this population continued to grow exponentially there would have been 7 million of them by the year 1950 and \\(10^{28}\\) by now \u2013 which at 2 kg per pheasant is 3000 times the mass of the earth!! In fact, Lack observed that \u201cthe figures suggest that the increase was slowing down and was about to cease, but at this point the island was occupied by the military and many of the birds shot.\u201d Although populations may initially experience exponential growth, resources eventually become depleted and competition becomes more severe. This suggests that we should change our model assumptions.","title":"The trouble with exponential growth"},{"location":"lectures/lecture-03/#3-logistic-growth","text":"Exponential growth assumes the growth rate ( \\(r_d\\) , \\(r_c\\) ) is constant. Logistic growth relaxes this assumption, and instead assumes that the growth rate decreases linearly with population size, due to competition for resources within the population.","title":"3. Logistic growth"},{"location":"lectures/lecture-03/#logistic-growth-in-discrete-time","text":"In discrete-time, the reproductive factor under logistic growth can be written as \\[R(n_t) = 1 + r\\left(1 - \\frac{n_t}{K}\\right)\\] Notice that each individual is expected to have one offspring ( \\(R=1\\) ) if the intrinsic growth rate (ie, growth rate when rare) is zero, \\(r = 0\\) , or if the population size is at carrying capacity , \\(n_t=K\\) . Try plotting the reproductive factor as a function of \\(n_t\\) for a few different values of \\(r\\) and \\(K\\) . # Reproductive factor for logistic growth def logistic_discrete(nt, r, K): '''reproductive factor in discrete logistic model with growth rate r and carrying capacity k''' return 1 + r * (1 - nt/K) # Compare a few different growth rates and carrying capacities fig, ax = plt.subplots() for r, K in zip([1, 2, 1], [100, 100, 50]): #for each pair of r and K values nt = np.linspace(0, 200) #for a range of population sizes from 0 to 200 R = logistic_discrete(nt, r, K) #calculate the reproductive factor ax.plot(nt, R, label=f\"r = {r}, K = {K}\") #and plot ax.plot(nt, [1 for i in nt], '--', color='gray') #1 line for reference ax.set_xlabel('Population size, $n_t$') ax.set_ylabel('Reproductive factor, $R$') ax.legend(frameon=False) plt.ylim(0,None) plt.show() The population size in the next generation is the expected number of offspring per parent times the the total number of parents \\[n_{t+1} = \\left(1 + r\\left(1-\\frac{n_t}{K}\\right)\\right)n_t\\] This is the recursion equation for logistic growth. This recursion is a non-linear function of \\(n_t\\) ( non-linear means that there is a term in the equation where the term is taken to some power other than 1; here if we expand out the recursion we get a \\(n_t^2\\) term ). This reflects the fact that logistic growth models an interaction between individuals (competition). The change in population size from one generation to the next, \\(\\Delta n\\) , is therefore \\[\\Delta n = n_{t+1} - n_t = r\\left(1 - \\frac{n_t}{K}\\right)n_t\\] Based on this difference equation, when will the population grow in size? Test out your answer by plotting population size over time in the discrete-time logistic model. Try changing the initial population size or carrying capacity so that \\(n_t > K\\) . # Initialize parameters n, nt, r, K = [], 1, 0.1, 100 #list, initial population size, intrinsic growth rate, carrying capacity # Grow population under logistic growth for t in np.arange(0, 100): nt = nt * logistic_discrete(nt, r, K) n.append(nt) # Plot growth fig, ax = plt.subplots() ax.scatter(np.arange(0, 100), n) ax.axhline(100, label=f\"K = {K}\", linestyle='dashed', color='gray') #carrying capacity as dashed line # Add annotations ax.set_xlabel('Time, $t$') ax.set_ylabel('Population size, $n_t$') plt.show()","title":"Logistic growth in discrete time"},{"location":"lectures/lecture-03/#logistic-growth-in-continuous-time","text":"The model of logistic growth in continuous time, as with discrete time, follows from the assumption that each individual has a growth rate that decreases as a linear function of the population size \\(r(1 - n_t/K)\\) . If there are \\(n_t\\) individuals in the population at time \\(t\\) , then the rate of change of the population size will be \\[\\frac{\\mathrm{d}n_t}{\\mathrm{d}t} = r\\left(1 - \\frac{n_t}{K}\\right)n_t\\] This is a differential equation of logistic growth. Note that in both discrete and continuous time the logistic growth model reduces to the exponential growth model as \\(n_t/K\\) approaches 0, i.e., when the population size is much smaller than the carrying capacity \\(n_t << K\\) . An example of logistic growth Dr. Sarah Otto cultured haploid (one copy of each chromosome) and diploid (two copies of each chromosome) populations of Saccharomyces cereviseae . She observed the following population sizes for the two types of cells: Figure. The size of haploid and diploid yeast populations in a controlled laboratory experiment. Although the populations grow nearly exponentially at first, growth decreased as population size increased (i.e., density-dependent growth was observed). The carrying capacity ( \\(K\\) ) is clearly larger for the haploid cells, but do haploid and diploid cells have different intrinsic growth rates ( \\(r\\) )? By fitting the logistic growth model described above to the data, Dr. Otto estimated the parameter values to be Haploid: r = 0.55, K = 3.7 x 10^8 Diploid: r = 0.55, K = 2.3 x 10^8 The growth rates therefore do not differ (visibly or statistically). With these parameter estimates, the logistic model nicely fits the data: Figure. Population size of haploid and diploid yeast fit with logistic growth models. Note: This may be a bit misleading, as such excellent model fits are rarely observed, especially outside the lab! To do: make the above plots in Python","title":"Logistic growth in continuous time"},{"location":"lectures/lecture-04/","text":"{ requestKernel: true, mountActivateWidget: true, mountStatusWidget: true, binderOptions: { repo: \"tomouellette/executable-cells\", ref: \"main\", binderUrl: \"https://gke.mybinder.org\", }, } Lecture 4: One-locus selection Run notes interactively? Lecture overview Review of Hardy-Weinberg One-locus haploid selection in discrete time One-locus diploid selection in discrete time Comparing haploid and diploid selection One-locus haploid selection in continuous time Comparing haploid selection in discrete and continuous time The models we've covered 1. Review of Hardy-Weinberg In the absence of selection, one round of random mating causes the frequency of diploid genotypes at a locus with two alleles, \\(A\\) and \\(a\\) , to become \\(AA\\) : \\(p^2\\) \\(Aa\\) : \\(2pq\\) \\(aa\\) : \\(q^2\\) where \\(p\\) is the frequency of allele \\(A\\) and \\(q=1-p\\) is the frequency of allele \\(a\\) . A population with these diploid genotype frequencies is said to be in Hardy-Weinberg equilibrium. Furthermore, we showed that under this model the allele frequencies do not change, \\(p' = p\\) . But what if there is selection? 2. One-locus haploid selection in discrete time We begin by examining a model where selection acts during the haploid phase of the life-cycle. This is a little simpler than diploid selection because there are only two haploid genotypes, \\(A\\) and \\(a\\) . It is also a very relevant model for species with long haploid phases (eg, some algae and fungi) or with strong competition during the haploid phase (eg, pollen competiting for ovules). Life-cycle diagram We first illustrate the structure of the model with a life-cycle diagram. graph LR; A((random<br> union)) --diploid--> B((meiosis)); B --haploid--> C((selection)); C --haploid--> A; Figure. Life-cycle diagram of haploid selection We will census the population at the beginning of the haploid phase (immediately after meiosis). Deriving the equations Let \\(n_A(t) =\\) number of \\(A\\) genotypes in generation \\(t\\) \\(n_a(t) =\\) number of \\(a\\) genotypes in generation \\(t\\) The frequency of \\(A\\) is therefore \\(p_t = \\frac{n_a(t)}{n_A(t) + n_a(t)}\\) . Now, let\u2019s assume that not all haploid individuals survive to reproduce, and that the viability of an individual depends on its genotype: \\(v_A =\\) fraction of \\(A\\) genotypes that survive \\(v_a =\\) fraction of \\(a\\) genotypes that survive After these deaths have occurred, there are \\(v_A n_A(t)\\) \\(A\\) genotypes and \\(v_a n_a(t)\\) \\(a\\) genotypes. The frequency of \\(A\\) among these survivors is therefore \\(\\frac{v_A n_A(t)}{v_A n_A(t) + v_a n_a(t)}\\) . These survivors go on to unite at random, go through the diploid phase of the life-cycle without selection, and then undergo meiosis to produce the next generation of haploids. Because none of these processes change allele frequencies (as in our model of Hardy-Weinberg), the frequency of \\(A\\) in the next generation is the frequency after death, \\[ p_{t+1} = \\frac{v_A n_A(t)}{v_A n_A(t) + v_a n_a(t)}. \\] To make this a recursion equation we need to write \\(p_{t+1}\\) in terms of \\(p_t\\) , so that if we knew \\(p\\) at some point in time we can recursively calculate it in all future times. To do this we divide both the numerator and denominator by the total number of individuals, \\(n_A(t) + n_a(t)\\) , and simplify \\[ \\begin{aligned} p_{t+1} &= \\frac{v_A n_A(t)}{v_A n_A(t) + v_a n_a(t)} \\\\ &= \\frac{v_A\\frac{n_A(t)}{n_A(t) + n_a(t)}}{v_A\\frac{n_A(t)}{n_A(t) + n_a(t)} + v_a\\frac{n_a(t)}{n_A(t) + n_a(t)}}\\\\ &= \\frac{v_A p_t}{v_A p_t + v_a q_t}. \\end{aligned} \\] This is now a recursion equation for the allele frequency in our model of haploid selection. Simplifying Our current recursion is a function of two parameters, the absolute viabilities, \\(v_A\\) and \\(v_a\\) . Now notice that if we divide both the numerator and denominator by one of these viabilities, say \\(v_a\\) , then we can reduce the recursion to a function of only one parameter, \\(W_A = v_A/v_a\\) , the viability of \\(A\\) relative to the viablity of \\(a\\) , \\[ \\begin{aligned} p_{t+1} &= \\frac{(v_A/v_a)p_t}{(v_A/v_a)p_t + (v_a/v_a)q_t}\\\\ &= \\frac{W_A p_t}{W_A p_t + q_t}. \\end{aligned} \\] Let's plot the recursion to get a sense of the dynamics import matplotlib.pyplot as plt # calculate allele frequency over time with recursion W_A = 1.1 #relative viability of allele A p_now = 0.01 #initial allele frequency, p_0 ps = [] #list to hold allele frequencies over time ts = range(100) #list of time steps for t in ts: #for each time ps.append(p_now) #add current allele frequency to list p_now = W_A*p_now/(W_A*p_now+(1-p_now)) #update allele frequency with our recursion equation # plot plt.scatter(ts, ps) #plot the (t,p) pairs plt.xlabel(\"generation, $t$\") #label axes plt.ylabel(\"frequency of $A$ allele, $p$\") plt.show() 3. One-locus diploid selection in discrete time Since we are all currently in the diploid phase of our life-cycle, it is natural to ask: Does selection in the diploid phase work the same way? Life-cycle diagram We now have the following life-cycle diagram. graph LR; A((random<br> union)) --diploid--> B((selection)); B --diploid--> C((meiosis)); C --haploid--> A; Figure. Life-cycle diagram of diploid selection We will census at the beginning of the diploid phase (immediately after gamete union). Deriving the equations Let \\(n_{AA}(t) =\\) number of \\(AA\\) genotypes in generation \\(t\\) \\(n_{Aa}(t) =\\) number of \\(Aa\\) genotypes in generation \\(t\\) \\(n_{aa}(t) =\\) number of \\(aa\\) genotypes in generation \\(t\\) The frequency of allele \\(A\\) is then \\[ \\begin{aligned} p_t &= \\frac{2n_{AA}(t) + n_{Aa}(t)}{2n_{AA}(t) + n_{Aa}(t) + n_{aa}(t)} \\\\ &= \\frac{n_{AA}(t) + \\frac{1}{2}n_{Aa}(t)}{n_{AA}(t) + n_{Aa}(t) + n_{aa}(t)} \\end{aligned} \\] Now let's assume that not all individuals survive to reproduce, and that the viability of an individual depends on its genotype: \\(V_{AA} =\\) fraction of \\(AA\\) genotypes that survive \\(V_{Aa} =\\) fraction of \\(Aa\\) genotypes that survive \\(V_{aa} =\\) fraction of \\(aa\\) genotypes that survive After these deaths there will be \\(v_{AA}n_{AA}(t)\\) \\(AA\\) genotypes, \\(v_{Aa}n_{Aa}(t)\\) \\(Aa\\) genotypes, and \\(v_{aa}n_{aa}(t)\\) \\(aa\\) genotypes. The frequency of the \\(A\\) allele among these survivors is therefore \\[ \\frac{v_{AA}n_{AA}(t) + \\frac{1}{2}v_{Aa}n_{Aa}(t)}{v_{AA}n_{AA}(t) + \\frac{1}{2}v_{Aa}n_{Aa}(t) + v_{aa}n_{aa}(t)}. \\] Since meiosis, passage through the haploid phase without selection, and random union will not change this frequency, this is the frequency of the \\(A\\) allele in the next generation, \\[ p_{t+1} = \\frac{v_{AA}n_{AA}(t) + \\frac{1}{2}v_{Aa}n_{Aa}(t)}{v_{AA}n_{AA}(t) + \\frac{1}{2}v_{Aa}n_{Aa}(t) + v_{aa}n_{aa}(t)}. \\] As above, we want a recursion equation, so we want to replace the \\(n_i\\) 's in the right hand side of this equation with \\(p\\) 's. To do this we note that with the random union of gametes the diploid offspring are in Hardy-Weinberg proportions, so that \\(n_{AA}(t) = p_t^2 n(t)\\) \\(n_{Aa}(t) = 2p_t q_t n(t)\\) \\(n_{aa}(t) = q_t^2 n(t)\\) where \\(n(t) = n_{AA}(t) + n_{Aa}(t) + n_{aa}(t)\\) is the total population size. Substituting these Hardy-Weinberg proportions in and simplifying, the total population size cancels out and we can rewrite the above equation in terms of allele frequency alone, \\[ p_{t+1} = \\frac{v_{AA}p_t^2 + v_{Aa}p_t q_t}{v_{AA}p_t^2 + 2v_{Aa}p_t q_t + v_{aa}q_t^2}. \\] This is a recursion equation for allele frequency in our model of diploid selection. Simplifying As in the haploid selection case, we can divide by one of the viabilities, say \\(v_{aa}\\) , to remove one parameter from the model \\[ \\begin{aligned} p_{t+1} &= \\frac{(v_{AA}/v_{aa})p_t^2 + (v_{Aa}/v_{aa})p_t q_t}{(v_{AA}/v_{aa})p_t^2 + 2(v_{Aa}/v_{aa})p_t q_t + (v_{aa}/v_{aa})q_t^2} \\\\ &= \\frac{W_{AA}p_t^2 + W_{Aa}p_t q_t}{W_{AA}p_t^2 + 2W_{Aa}p_t q_t + q_t^2} \\end{aligned} \\] This recursion is a function of only two relative viabilities, \\(W_{AA} = v_{AA}/v_{aa}\\) and \\(W_{Aa} = v_{Aa}/v_{aa}\\) . Let's plot the recursion to get a sense of the dynamics import matplotlib.pyplot as plt # calculate allele frequency over time with recursion W_AA = 1.2 #relative viability of genotype AA W_Aa = 1.1 #relative viability of genotype Aa p_now = 0.01 #initial allele frequency, p_0 ps = [] #list to hold allele frequencies over time ts = range(100) #list of time steps for t in ts: #for each time ps.append(p_now) #add current allele frequency to list p_now = (W_AA*p_now**2 + W_Aa*p_now*(1-p_now))/(W_AA*p_now**2 + 2*W_Aa*p_now*(1-p_now) + (1-p_now)**2) #update allele frequency with our recursion equation # plot plt.scatter(ts, ps) plt.xlabel(\"generation, $t$\") plt.ylabel(\"frequency of $A$ allele, $p$\") plt.show() 4. Comparing haploid and diploid selection So, returning to our original question, let's compare evolution under haploid selection \\[ p_{t+1} = \\frac{v_A p_t}{v_A p_t + v_a q_t} \\] to evolution under diploid selection \\[ p_{t+1} = \\frac{v_{AA}p_t^2 + v_{Aa}p_t q_t}{v_{AA}p_t^2 + 2v_{Aa}p_t q_t + v_{aa}q_t^2}. \\] To facilitate this, let\u2019s assume the viability of a diploid genotype is the product of the haploid viabilities, i.e., \\(v_{AA} = v_Av_A\\) , \\(v_{Aa} = v_Av_a\\) , and \\(v_{aa} = v_av_a\\) . It then happens that our diploid recursion reduces to the haploid recursion, \\[ \\begin{aligned} p_{t+1} &= \\frac{v_A v_A p_t^2 + v_A v_a p_t q_t}{v_A v_A p_t^2 + 2v_A v_a p_t q_t + v_a v_a q_t^2}\\\\ &= \\frac{v_Ap_t(p_t + v_a q_t)}{v_A p_t(v_A p_t + v_a q_t) + v_a q_t(v_A p_t + v_a q_t)}\\\\ &= \\frac{v_A p_t}{v_A p_t + v_a q_t} \\end{aligned} \\] This shows that we need twice as much selection under diploid selection relative to that under haploid selection (e.g., \\(v_{AA} = v_Av_A\\) ) for evolution to proceed as quickly. Why is evolution slower under diploid selection? Let's check this visually (try breaking the assumption to see what happens) import matplotlib.pyplot as plt # calculate allele frequency over time with recursion W_A = 1.1 #relative viability of allele A in the haploid model W_AA = W_A*W_A #relative viability of genotype AA in the diploid model W_Aa = W_A #relative viability of genotype Aa in the diploid model p_now_hap = 0.01 #initial allele frequency, p_0 p_now_dip = p_now_hap ps_hap, ps_dip = [], [] #lists to hold allele frequencies over time ts = range(100) #list of time steps for t in ts: #for each time ps_hap.append(p_now_hap) #add current allele frequency to list p_now_hap = W_A*p_now_hap/(W_A*p_now_hap+(1-p_now_hap)) #update allele frequency with haploid recursion equation ps_dip.append(p_now_dip) #add current allele frequency to list p_now_dip = (W_AA*p_now_dip**2 + W_Aa*p_now_dip*(1-p_now_dip))/(W_AA*p_now_dip**2 + 2*W_Aa*p_now_dip*(1-p_now_dip) + (1-p_now_dip)**2) #update allele frequency with diploid recursion equation # plot plt.scatter(ts, ps_hap, label='haploid') plt.scatter(ts, ps_dip, label='diploid') plt.xlabel(\"generation, $t$\") plt.ylabel(\"frequency of $A$ allele, $p$\") plt.legend() #add legend to know which points belong to which model plt.show() 5. One-locus haploid selection in continuous time To model haploid selection in continuous-time we assume each haploid genotype has growth rate \\(r_A =\\) growth rate of the \\(A\\) genotype \\(r_a =\\) growth rate of the \\(a\\) genotype which takes into account the time spent going through gamete union, diploidy, and meiosis. We therefore have exponential growth of both genotypes according to \\[\\frac{\\mathrm{d} n_A}{dt} = r_A n_A\\] \\[\\frac{\\mathrm{d} n_a}{dt} = r_a n_a.\\] At any particular point in time, \\(t\\) , the frequency of allele \\(A\\) is as above, \\(p_t = n_A(t)/(n_A(t) + n_a(t))\\) . We can therefore derive the rate of change in the frequency of allele \\(A\\) , \\(\\mathrm{d}p/\\mathrm{d}t\\) , using the qoutient rule \\[ \\begin{aligned} \\frac{\\mathrm{d}p}{\\mathrm{d}t} &= \\frac{\\mathrm{d}\\frac{n_A}{n_A + n_a}}{\\mathrm{d}t} \\\\ &= \\frac{\\frac{\\mathrm{d}n_A}{\\mathrm{d}t} (n_A + n_a) - n_A \\frac{\\mathrm{d}(n_A+n_a)}{\\mathrm{d}t}}{(n_A + n_a)^2}\\\\ &= \\frac{r_A n_A (n_A + n_a) - n_A (r_A n_A + r_a n_a)}{(n_A + n_a)^2}\\\\ &= \\frac{r_A n_A n_a - r_a n_A n_a)}{(n_A + n_a)^2}\\\\ &= \\frac{(r_A -r_a)n_A n_a}{(n_A + n_a)^2}\\\\ &= (r_A -r_a)p q, \\end{aligned} \\] where \\(s_c = r_A - r_a\\) is the continuous-time selection coefficient of allele \\(A\\) . A similar equation can be derived for the model of diploid-selection in continuous time, but we will not study it (see the textbook if you are curious). 6. Comparing haploid selection in discrete and continuous time Are the discrete- and continuous-time models of haploid selection as different as they look? \\[ p_{t+1} = \\frac{v_A p_t}{v_A p_t + v_a q_t} \\] \\[ \\frac{\\mathrm{d}p}{\\mathrm{d}t} = s_c p q \\] Not really. Discrete and continuous time models generally behave in a similar fashion when changes occur slowly over time. For this model of haploid selection, this implies that the discrete and continuous models will be similar when the fitnesses of the two genotypes are nearly equal, i.e., when \\(v_A - v_a\\) is small. This is called \"weak selection\". In the discrete model, the change in the allele frequency is \\[ \\begin{aligned} \\Delta p &= p_{t+1} - p_t \\\\ &= \\frac{v_A p_t}{v_A p_t + v_a q_t} - p_t \\\\ &= \\frac{(v_A - v_a)p_t q_t}{v_A p_t + v_a q_t}. \\end{aligned} \\] Now define \\(s_d = (v_A - v_a)/v_a\\) as the discrete time selection coefficient. Subbing this in as \\(V_A = s_d v_a + v_a\\) gives \\[ \\begin{aligned} \\Delta p &= \\frac{(v_A-v_a)p_t q_t}{v_A p_t + v_a q_t}\\\\ &= \\frac{(s_d v_a + v_a - v_a) p_t q_t}{(s_d v_a + v_a) p_t + v_a q_t}\\\\ &= \\frac{s_d v_a p_t q_t}{s_d v_a p_t + v_a (p_t + q_t)}\\\\ &= \\frac{s_d v_a p_t q_t}{s_d v_a p_t + v_a}\\\\ &= \\frac{s_d p_t q_t}{s_d p_t + 1}\\\\ \\end{aligned} \\] Now assume weak selection, ie, that \\(s_d\\) is small. This implies \\(s_d p_t + 1 \\approx 1\\) . Making this approximation we have \\[ \\Delta p \\approx s_d p_t q_t \\] This is equivalent to the continuous-time model when the selection coefficients are equal, \\(s_c = s_d\\) . 7. The models we've covered To summarize the last two lectures, we've derived four of the most classic models in ecology and evolution: Model Discrete time Continous time Exponential growth \\(n_{t+1} = R n_t\\) \\(\\frac{\\mathrm{d}n}{\\mathrm{d}t} = r n\\) Logistic growth \\(n_{t+1} = (1 + r(1 - \\frac{n_t}{K}))n_t\\) \\(\\frac{\\mathrm{d}n}{\\mathrm{d}t} = r(1 - \\frac{n}{K})n\\) Haploid selection \\(p_{t+1} = \\frac{p_t W_A}{p_t W_A + q_t}\\) \\(\\frac{\\mathrm{d}p}{\\mathrm{d}t} = s p(1-p)\\) Diploid selection \\(p_{t+1} = \\frac{p_t^2 W_{AA} + p_t q_t W_{Aa}}{p_t^2 W_{AA} + 2 p_t q_t W_{Aa} + q_t^2}\\) Not derived See textbook sections 3.4 and 3.5 for models of interacting species and epidemiology, respectively, which we won't cover in class.","title":"Lecture 4"},{"location":"lectures/lecture-04/#lecture-4-one-locus-selection","text":"Run notes interactively?","title":"Lecture 4: One-locus selection"},{"location":"lectures/lecture-04/#lecture-overview","text":"Review of Hardy-Weinberg One-locus haploid selection in discrete time One-locus diploid selection in discrete time Comparing haploid and diploid selection One-locus haploid selection in continuous time Comparing haploid selection in discrete and continuous time The models we've covered","title":"Lecture overview"},{"location":"lectures/lecture-04/#1-review-of-hardy-weinberg","text":"In the absence of selection, one round of random mating causes the frequency of diploid genotypes at a locus with two alleles, \\(A\\) and \\(a\\) , to become \\(AA\\) : \\(p^2\\) \\(Aa\\) : \\(2pq\\) \\(aa\\) : \\(q^2\\) where \\(p\\) is the frequency of allele \\(A\\) and \\(q=1-p\\) is the frequency of allele \\(a\\) . A population with these diploid genotype frequencies is said to be in Hardy-Weinberg equilibrium. Furthermore, we showed that under this model the allele frequencies do not change, \\(p' = p\\) . But what if there is selection?","title":"1. Review of Hardy-Weinberg"},{"location":"lectures/lecture-04/#2-one-locus-haploid-selection-in-discrete-time","text":"We begin by examining a model where selection acts during the haploid phase of the life-cycle. This is a little simpler than diploid selection because there are only two haploid genotypes, \\(A\\) and \\(a\\) . It is also a very relevant model for species with long haploid phases (eg, some algae and fungi) or with strong competition during the haploid phase (eg, pollen competiting for ovules).","title":"2. One-locus haploid selection in discrete time"},{"location":"lectures/lecture-04/#life-cycle-diagram","text":"We first illustrate the structure of the model with a life-cycle diagram. graph LR; A((random<br> union)) --diploid--> B((meiosis)); B --haploid--> C((selection)); C --haploid--> A; Figure. Life-cycle diagram of haploid selection We will census the population at the beginning of the haploid phase (immediately after meiosis).","title":"Life-cycle diagram"},{"location":"lectures/lecture-04/#deriving-the-equations","text":"Let \\(n_A(t) =\\) number of \\(A\\) genotypes in generation \\(t\\) \\(n_a(t) =\\) number of \\(a\\) genotypes in generation \\(t\\) The frequency of \\(A\\) is therefore \\(p_t = \\frac{n_a(t)}{n_A(t) + n_a(t)}\\) . Now, let\u2019s assume that not all haploid individuals survive to reproduce, and that the viability of an individual depends on its genotype: \\(v_A =\\) fraction of \\(A\\) genotypes that survive \\(v_a =\\) fraction of \\(a\\) genotypes that survive After these deaths have occurred, there are \\(v_A n_A(t)\\) \\(A\\) genotypes and \\(v_a n_a(t)\\) \\(a\\) genotypes. The frequency of \\(A\\) among these survivors is therefore \\(\\frac{v_A n_A(t)}{v_A n_A(t) + v_a n_a(t)}\\) . These survivors go on to unite at random, go through the diploid phase of the life-cycle without selection, and then undergo meiosis to produce the next generation of haploids. Because none of these processes change allele frequencies (as in our model of Hardy-Weinberg), the frequency of \\(A\\) in the next generation is the frequency after death, \\[ p_{t+1} = \\frac{v_A n_A(t)}{v_A n_A(t) + v_a n_a(t)}. \\] To make this a recursion equation we need to write \\(p_{t+1}\\) in terms of \\(p_t\\) , so that if we knew \\(p\\) at some point in time we can recursively calculate it in all future times. To do this we divide both the numerator and denominator by the total number of individuals, \\(n_A(t) + n_a(t)\\) , and simplify \\[ \\begin{aligned} p_{t+1} &= \\frac{v_A n_A(t)}{v_A n_A(t) + v_a n_a(t)} \\\\ &= \\frac{v_A\\frac{n_A(t)}{n_A(t) + n_a(t)}}{v_A\\frac{n_A(t)}{n_A(t) + n_a(t)} + v_a\\frac{n_a(t)}{n_A(t) + n_a(t)}}\\\\ &= \\frac{v_A p_t}{v_A p_t + v_a q_t}. \\end{aligned} \\] This is now a recursion equation for the allele frequency in our model of haploid selection.","title":"Deriving the equations"},{"location":"lectures/lecture-04/#simplifying","text":"Our current recursion is a function of two parameters, the absolute viabilities, \\(v_A\\) and \\(v_a\\) . Now notice that if we divide both the numerator and denominator by one of these viabilities, say \\(v_a\\) , then we can reduce the recursion to a function of only one parameter, \\(W_A = v_A/v_a\\) , the viability of \\(A\\) relative to the viablity of \\(a\\) , \\[ \\begin{aligned} p_{t+1} &= \\frac{(v_A/v_a)p_t}{(v_A/v_a)p_t + (v_a/v_a)q_t}\\\\ &= \\frac{W_A p_t}{W_A p_t + q_t}. \\end{aligned} \\] Let's plot the recursion to get a sense of the dynamics import matplotlib.pyplot as plt # calculate allele frequency over time with recursion W_A = 1.1 #relative viability of allele A p_now = 0.01 #initial allele frequency, p_0 ps = [] #list to hold allele frequencies over time ts = range(100) #list of time steps for t in ts: #for each time ps.append(p_now) #add current allele frequency to list p_now = W_A*p_now/(W_A*p_now+(1-p_now)) #update allele frequency with our recursion equation # plot plt.scatter(ts, ps) #plot the (t,p) pairs plt.xlabel(\"generation, $t$\") #label axes plt.ylabel(\"frequency of $A$ allele, $p$\") plt.show()","title":"Simplifying"},{"location":"lectures/lecture-04/#3-one-locus-diploid-selection-in-discrete-time","text":"Since we are all currently in the diploid phase of our life-cycle, it is natural to ask: Does selection in the diploid phase work the same way?","title":"3. One-locus diploid selection in discrete time"},{"location":"lectures/lecture-04/#life-cycle-diagram_1","text":"We now have the following life-cycle diagram. graph LR; A((random<br> union)) --diploid--> B((selection)); B --diploid--> C((meiosis)); C --haploid--> A; Figure. Life-cycle diagram of diploid selection We will census at the beginning of the diploid phase (immediately after gamete union).","title":"Life-cycle diagram"},{"location":"lectures/lecture-04/#deriving-the-equations_1","text":"Let \\(n_{AA}(t) =\\) number of \\(AA\\) genotypes in generation \\(t\\) \\(n_{Aa}(t) =\\) number of \\(Aa\\) genotypes in generation \\(t\\) \\(n_{aa}(t) =\\) number of \\(aa\\) genotypes in generation \\(t\\) The frequency of allele \\(A\\) is then \\[ \\begin{aligned} p_t &= \\frac{2n_{AA}(t) + n_{Aa}(t)}{2n_{AA}(t) + n_{Aa}(t) + n_{aa}(t)} \\\\ &= \\frac{n_{AA}(t) + \\frac{1}{2}n_{Aa}(t)}{n_{AA}(t) + n_{Aa}(t) + n_{aa}(t)} \\end{aligned} \\] Now let's assume that not all individuals survive to reproduce, and that the viability of an individual depends on its genotype: \\(V_{AA} =\\) fraction of \\(AA\\) genotypes that survive \\(V_{Aa} =\\) fraction of \\(Aa\\) genotypes that survive \\(V_{aa} =\\) fraction of \\(aa\\) genotypes that survive After these deaths there will be \\(v_{AA}n_{AA}(t)\\) \\(AA\\) genotypes, \\(v_{Aa}n_{Aa}(t)\\) \\(Aa\\) genotypes, and \\(v_{aa}n_{aa}(t)\\) \\(aa\\) genotypes. The frequency of the \\(A\\) allele among these survivors is therefore \\[ \\frac{v_{AA}n_{AA}(t) + \\frac{1}{2}v_{Aa}n_{Aa}(t)}{v_{AA}n_{AA}(t) + \\frac{1}{2}v_{Aa}n_{Aa}(t) + v_{aa}n_{aa}(t)}. \\] Since meiosis, passage through the haploid phase without selection, and random union will not change this frequency, this is the frequency of the \\(A\\) allele in the next generation, \\[ p_{t+1} = \\frac{v_{AA}n_{AA}(t) + \\frac{1}{2}v_{Aa}n_{Aa}(t)}{v_{AA}n_{AA}(t) + \\frac{1}{2}v_{Aa}n_{Aa}(t) + v_{aa}n_{aa}(t)}. \\] As above, we want a recursion equation, so we want to replace the \\(n_i\\) 's in the right hand side of this equation with \\(p\\) 's. To do this we note that with the random union of gametes the diploid offspring are in Hardy-Weinberg proportions, so that \\(n_{AA}(t) = p_t^2 n(t)\\) \\(n_{Aa}(t) = 2p_t q_t n(t)\\) \\(n_{aa}(t) = q_t^2 n(t)\\) where \\(n(t) = n_{AA}(t) + n_{Aa}(t) + n_{aa}(t)\\) is the total population size. Substituting these Hardy-Weinberg proportions in and simplifying, the total population size cancels out and we can rewrite the above equation in terms of allele frequency alone, \\[ p_{t+1} = \\frac{v_{AA}p_t^2 + v_{Aa}p_t q_t}{v_{AA}p_t^2 + 2v_{Aa}p_t q_t + v_{aa}q_t^2}. \\] This is a recursion equation for allele frequency in our model of diploid selection.","title":"Deriving the equations"},{"location":"lectures/lecture-04/#simplifying_1","text":"As in the haploid selection case, we can divide by one of the viabilities, say \\(v_{aa}\\) , to remove one parameter from the model \\[ \\begin{aligned} p_{t+1} &= \\frac{(v_{AA}/v_{aa})p_t^2 + (v_{Aa}/v_{aa})p_t q_t}{(v_{AA}/v_{aa})p_t^2 + 2(v_{Aa}/v_{aa})p_t q_t + (v_{aa}/v_{aa})q_t^2} \\\\ &= \\frac{W_{AA}p_t^2 + W_{Aa}p_t q_t}{W_{AA}p_t^2 + 2W_{Aa}p_t q_t + q_t^2} \\end{aligned} \\] This recursion is a function of only two relative viabilities, \\(W_{AA} = v_{AA}/v_{aa}\\) and \\(W_{Aa} = v_{Aa}/v_{aa}\\) . Let's plot the recursion to get a sense of the dynamics import matplotlib.pyplot as plt # calculate allele frequency over time with recursion W_AA = 1.2 #relative viability of genotype AA W_Aa = 1.1 #relative viability of genotype Aa p_now = 0.01 #initial allele frequency, p_0 ps = [] #list to hold allele frequencies over time ts = range(100) #list of time steps for t in ts: #for each time ps.append(p_now) #add current allele frequency to list p_now = (W_AA*p_now**2 + W_Aa*p_now*(1-p_now))/(W_AA*p_now**2 + 2*W_Aa*p_now*(1-p_now) + (1-p_now)**2) #update allele frequency with our recursion equation # plot plt.scatter(ts, ps) plt.xlabel(\"generation, $t$\") plt.ylabel(\"frequency of $A$ allele, $p$\") plt.show()","title":"Simplifying"},{"location":"lectures/lecture-04/#4-comparing-haploid-and-diploid-selection","text":"So, returning to our original question, let's compare evolution under haploid selection \\[ p_{t+1} = \\frac{v_A p_t}{v_A p_t + v_a q_t} \\] to evolution under diploid selection \\[ p_{t+1} = \\frac{v_{AA}p_t^2 + v_{Aa}p_t q_t}{v_{AA}p_t^2 + 2v_{Aa}p_t q_t + v_{aa}q_t^2}. \\] To facilitate this, let\u2019s assume the viability of a diploid genotype is the product of the haploid viabilities, i.e., \\(v_{AA} = v_Av_A\\) , \\(v_{Aa} = v_Av_a\\) , and \\(v_{aa} = v_av_a\\) . It then happens that our diploid recursion reduces to the haploid recursion, \\[ \\begin{aligned} p_{t+1} &= \\frac{v_A v_A p_t^2 + v_A v_a p_t q_t}{v_A v_A p_t^2 + 2v_A v_a p_t q_t + v_a v_a q_t^2}\\\\ &= \\frac{v_Ap_t(p_t + v_a q_t)}{v_A p_t(v_A p_t + v_a q_t) + v_a q_t(v_A p_t + v_a q_t)}\\\\ &= \\frac{v_A p_t}{v_A p_t + v_a q_t} \\end{aligned} \\] This shows that we need twice as much selection under diploid selection relative to that under haploid selection (e.g., \\(v_{AA} = v_Av_A\\) ) for evolution to proceed as quickly. Why is evolution slower under diploid selection? Let's check this visually (try breaking the assumption to see what happens) import matplotlib.pyplot as plt # calculate allele frequency over time with recursion W_A = 1.1 #relative viability of allele A in the haploid model W_AA = W_A*W_A #relative viability of genotype AA in the diploid model W_Aa = W_A #relative viability of genotype Aa in the diploid model p_now_hap = 0.01 #initial allele frequency, p_0 p_now_dip = p_now_hap ps_hap, ps_dip = [], [] #lists to hold allele frequencies over time ts = range(100) #list of time steps for t in ts: #for each time ps_hap.append(p_now_hap) #add current allele frequency to list p_now_hap = W_A*p_now_hap/(W_A*p_now_hap+(1-p_now_hap)) #update allele frequency with haploid recursion equation ps_dip.append(p_now_dip) #add current allele frequency to list p_now_dip = (W_AA*p_now_dip**2 + W_Aa*p_now_dip*(1-p_now_dip))/(W_AA*p_now_dip**2 + 2*W_Aa*p_now_dip*(1-p_now_dip) + (1-p_now_dip)**2) #update allele frequency with diploid recursion equation # plot plt.scatter(ts, ps_hap, label='haploid') plt.scatter(ts, ps_dip, label='diploid') plt.xlabel(\"generation, $t$\") plt.ylabel(\"frequency of $A$ allele, $p$\") plt.legend() #add legend to know which points belong to which model plt.show()","title":"4. Comparing haploid and diploid selection"},{"location":"lectures/lecture-04/#5-one-locus-haploid-selection-in-continuous-time","text":"To model haploid selection in continuous-time we assume each haploid genotype has growth rate \\(r_A =\\) growth rate of the \\(A\\) genotype \\(r_a =\\) growth rate of the \\(a\\) genotype which takes into account the time spent going through gamete union, diploidy, and meiosis. We therefore have exponential growth of both genotypes according to \\[\\frac{\\mathrm{d} n_A}{dt} = r_A n_A\\] \\[\\frac{\\mathrm{d} n_a}{dt} = r_a n_a.\\] At any particular point in time, \\(t\\) , the frequency of allele \\(A\\) is as above, \\(p_t = n_A(t)/(n_A(t) + n_a(t))\\) . We can therefore derive the rate of change in the frequency of allele \\(A\\) , \\(\\mathrm{d}p/\\mathrm{d}t\\) , using the qoutient rule \\[ \\begin{aligned} \\frac{\\mathrm{d}p}{\\mathrm{d}t} &= \\frac{\\mathrm{d}\\frac{n_A}{n_A + n_a}}{\\mathrm{d}t} \\\\ &= \\frac{\\frac{\\mathrm{d}n_A}{\\mathrm{d}t} (n_A + n_a) - n_A \\frac{\\mathrm{d}(n_A+n_a)}{\\mathrm{d}t}}{(n_A + n_a)^2}\\\\ &= \\frac{r_A n_A (n_A + n_a) - n_A (r_A n_A + r_a n_a)}{(n_A + n_a)^2}\\\\ &= \\frac{r_A n_A n_a - r_a n_A n_a)}{(n_A + n_a)^2}\\\\ &= \\frac{(r_A -r_a)n_A n_a}{(n_A + n_a)^2}\\\\ &= (r_A -r_a)p q, \\end{aligned} \\] where \\(s_c = r_A - r_a\\) is the continuous-time selection coefficient of allele \\(A\\) . A similar equation can be derived for the model of diploid-selection in continuous time, but we will not study it (see the textbook if you are curious).","title":"5. One-locus haploid selection in continuous time"},{"location":"lectures/lecture-04/#6-comparing-haploid-selection-in-discrete-and-continuous-time","text":"Are the discrete- and continuous-time models of haploid selection as different as they look? \\[ p_{t+1} = \\frac{v_A p_t}{v_A p_t + v_a q_t} \\] \\[ \\frac{\\mathrm{d}p}{\\mathrm{d}t} = s_c p q \\] Not really. Discrete and continuous time models generally behave in a similar fashion when changes occur slowly over time. For this model of haploid selection, this implies that the discrete and continuous models will be similar when the fitnesses of the two genotypes are nearly equal, i.e., when \\(v_A - v_a\\) is small. This is called \"weak selection\". In the discrete model, the change in the allele frequency is \\[ \\begin{aligned} \\Delta p &= p_{t+1} - p_t \\\\ &= \\frac{v_A p_t}{v_A p_t + v_a q_t} - p_t \\\\ &= \\frac{(v_A - v_a)p_t q_t}{v_A p_t + v_a q_t}. \\end{aligned} \\] Now define \\(s_d = (v_A - v_a)/v_a\\) as the discrete time selection coefficient. Subbing this in as \\(V_A = s_d v_a + v_a\\) gives \\[ \\begin{aligned} \\Delta p &= \\frac{(v_A-v_a)p_t q_t}{v_A p_t + v_a q_t}\\\\ &= \\frac{(s_d v_a + v_a - v_a) p_t q_t}{(s_d v_a + v_a) p_t + v_a q_t}\\\\ &= \\frac{s_d v_a p_t q_t}{s_d v_a p_t + v_a (p_t + q_t)}\\\\ &= \\frac{s_d v_a p_t q_t}{s_d v_a p_t + v_a}\\\\ &= \\frac{s_d p_t q_t}{s_d p_t + 1}\\\\ \\end{aligned} \\] Now assume weak selection, ie, that \\(s_d\\) is small. This implies \\(s_d p_t + 1 \\approx 1\\) . Making this approximation we have \\[ \\Delta p \\approx s_d p_t q_t \\] This is equivalent to the continuous-time model when the selection coefficients are equal, \\(s_c = s_d\\) .","title":"6. Comparing haploid selection in discrete and continuous time"},{"location":"lectures/lecture-04/#7-the-models-weve-covered","text":"To summarize the last two lectures, we've derived four of the most classic models in ecology and evolution: Model Discrete time Continous time Exponential growth \\(n_{t+1} = R n_t\\) \\(\\frac{\\mathrm{d}n}{\\mathrm{d}t} = r n\\) Logistic growth \\(n_{t+1} = (1 + r(1 - \\frac{n_t}{K}))n_t\\) \\(\\frac{\\mathrm{d}n}{\\mathrm{d}t} = r(1 - \\frac{n}{K})n\\) Haploid selection \\(p_{t+1} = \\frac{p_t W_A}{p_t W_A + q_t}\\) \\(\\frac{\\mathrm{d}p}{\\mathrm{d}t} = s p(1-p)\\) Diploid selection \\(p_{t+1} = \\frac{p_t^2 W_{AA} + p_t q_t W_{Aa}}{p_t^2 W_{AA} + 2 p_t q_t W_{Aa} + q_t^2}\\) Not derived See textbook sections 3.4 and 3.5 for models of interacting species and epidemiology, respectively, which we won't cover in class.","title":"7. The models we've covered"},{"location":"lectures/schedule/","text":"Schedule Lecture Topic Reading 1 Introduction Preface, 1.1, 1.4 (5p.) 2 Model construction Chapter 2 (34p.) 3 Exponential and logistic growth 3.1, 3.2 (8p.) 4 One-locus selection 3.3 (10p.) 5 Numerical and graphical techniques I (univariate) 6 Numerical and graphical techniques II (multivariate) 7 Equilibria (univariate) 8 Stability (univariate) 9 General solutions I (univariate) 10 Midterm review 11 General solutions II (multivariate) 12 Equilibria and stability (linear multivariate) 13 Demography 14 Equilibria and stability (nonlinear multivariate) 15 Evolutionary invasion analysis 16 Evolutionary invasion analysis - structured populations 17 Introduction to probability 18 More probability 19 More probability 20 TBD 21 TBD 22 TBD 23 Grad student presentations 24 Final review","title":"Schedule"},{"location":"lectures/schedule/#schedule","text":"Lecture Topic Reading 1 Introduction Preface, 1.1, 1.4 (5p.) 2 Model construction Chapter 2 (34p.) 3 Exponential and logistic growth 3.1, 3.2 (8p.) 4 One-locus selection 3.3 (10p.) 5 Numerical and graphical techniques I (univariate) 6 Numerical and graphical techniques II (multivariate) 7 Equilibria (univariate) 8 Stability (univariate) 9 General solutions I (univariate) 10 Midterm review 11 General solutions II (multivariate) 12 Equilibria and stability (linear multivariate) 13 Demography 14 Equilibria and stability (nonlinear multivariate) 15 Evolutionary invasion analysis 16 Evolutionary invasion analysis - structured populations 17 Introduction to probability 18 More probability 19 More probability 20 TBD 21 TBD 22 TBD 23 Grad student presentations 24 Final review","title":"Schedule"},{"location":"syllabus/assignments/","text":"Assignments Homeworks A list of homework problems will be released after class on Wednesday, with the solutions due by the start of class on Monday. Homeworks can be submitted online (Quercus) or on paper (in class). Labs Each computer lab contains a series of problems and the solutions are due by the end of the day (ideally by the end of the lab). Solutions can be submitted online (Quercus).","title":"Assignments"},{"location":"syllabus/assignments/#assignments","text":"","title":"Assignments"},{"location":"syllabus/assignments/#homeworks","text":"A list of homework problems will be released after class on Wednesday, with the solutions due by the start of class on Monday. Homeworks can be submitted online (Quercus) or on paper (in class).","title":"Homeworks"},{"location":"syllabus/assignments/#labs","text":"Each computer lab contains a series of problems and the solutions are due by the end of the day (ideally by the end of the lab). Solutions can be submitted online (Quercus).","title":"Labs"},{"location":"syllabus/course_structure/","text":"Course structure Learning objectives Mathematics is central to science because it provides a rigorous way to go from a set of assumptions (what we take to be true) to their logical consequences (what we want to know). In ecology & evolution this might be how we think SARS-CoV-2 may spread and evolve given a set of vaccination rates and travel restrictions, how caribou population sizes are predicted to respond to forecasted rates of climate change, or something much more abstract like the expected amount of genetic diversity in a randomly mating population. In this course we'll learn how to build, analyze, and interpret mathematical models of increasing complexity through readings, lectures, tutorials, assignments, computer labs, and a final project. By the end of the course you will be able to: build a model: go from a verbal description of a biological system to a set of equations analyze a model: manipulate a set of equations into a mathematical expression of interest interpret a model: translate mathematical expressions back into biological meaning Weekly tasks attend two lectures [time = 2h] attend one lab [time = 2h] read text [approx. time = 2h] do homework [approx. time = 2h] Grading scheme 20% - homeworks 20% - labs 20% - midterm 15% - final project 25% - final Late fees: homeworks and labs: to facilitate us giving you rapid feedback and solutions, you will receive 1/2 of your grade if submitted <24 hours late and 0 for anything later final project: you will receive 9/10 of your grade if submitted <24 hours late, else 8/10 if <48 hours late, else ...","title":"Course structure"},{"location":"syllabus/course_structure/#course-structure","text":"","title":"Course structure"},{"location":"syllabus/course_structure/#learning-objectives","text":"Mathematics is central to science because it provides a rigorous way to go from a set of assumptions (what we take to be true) to their logical consequences (what we want to know). In ecology & evolution this might be how we think SARS-CoV-2 may spread and evolve given a set of vaccination rates and travel restrictions, how caribou population sizes are predicted to respond to forecasted rates of climate change, or something much more abstract like the expected amount of genetic diversity in a randomly mating population. In this course we'll learn how to build, analyze, and interpret mathematical models of increasing complexity through readings, lectures, tutorials, assignments, computer labs, and a final project. By the end of the course you will be able to: build a model: go from a verbal description of a biological system to a set of equations analyze a model: manipulate a set of equations into a mathematical expression of interest interpret a model: translate mathematical expressions back into biological meaning","title":"Learning objectives"},{"location":"syllabus/course_structure/#weekly-tasks","text":"attend two lectures [time = 2h] attend one lab [time = 2h] read text [approx. time = 2h] do homework [approx. time = 2h]","title":"Weekly tasks"},{"location":"syllabus/course_structure/#grading-scheme","text":"20% - homeworks 20% - labs 20% - midterm 15% - final project 25% - final Late fees: homeworks and labs: to facilitate us giving you rapid feedback and solutions, you will receive 1/2 of your grade if submitted <24 hours late and 0 for anything later final project: you will receive 9/10 of your grade if submitted <24 hours late, else 8/10 if <48 hours late, else ...","title":"Grading scheme"},{"location":"syllabus/final_project/","text":"Final project Construct your own model. In this project you will use the tools you've learned in class and apply them to a model that you develop. The model can be about any phenomenon in ecology and evolution, as long as you make up the model. Be as creative as you want. You'll do the final project in two parts. Part 1: Describe your biological question and why this interests you. Describe your model in words (ie, the main assumptions) and explain the main structure with a diagram (eg, flow or life cycle diagram). Describe what your analysis might reveal (ie, your hypothesis). Max 2 pages. Due November 16. Part 2: Describe your model assumptions in detail, defining all parameters and variables. Write down the equations for your model. Analyze your model. Explain how the results address your original question. Suggest how the model could be improved or extended. Max 4 pages. Due December 7. And for grad students taking EEB1430, you'll also give a short presentation of your final project on December 7. Tip If you are having trouble coming up with a new model, take one of the models that we've analysed in the course and change one or more of its underlying assumptions to get a new set of equations. Then analyse these equations. Discuss the differences between the assumptions used and also between the results obtained.","title":"Final Project"},{"location":"syllabus/final_project/#final-project","text":"","title":"Final project"},{"location":"syllabus/final_project/#construct-your-own-model","text":"In this project you will use the tools you've learned in class and apply them to a model that you develop. The model can be about any phenomenon in ecology and evolution, as long as you make up the model. Be as creative as you want. You'll do the final project in two parts. Part 1: Describe your biological question and why this interests you. Describe your model in words (ie, the main assumptions) and explain the main structure with a diagram (eg, flow or life cycle diagram). Describe what your analysis might reveal (ie, your hypothesis). Max 2 pages. Due November 16. Part 2: Describe your model assumptions in detail, defining all parameters and variables. Write down the equations for your model. Analyze your model. Explain how the results address your original question. Suggest how the model could be improved or extended. Max 4 pages. Due December 7. And for grad students taking EEB1430, you'll also give a short presentation of your final project on December 7. Tip If you are having trouble coming up with a new model, take one of the models that we've analysed in the course and change one or more of its underlying assumptions to get a new set of equations. Then analyse these equations. Discuss the differences between the assumptions used and also between the results obtained.","title":"Construct your own model."},{"location":"syllabus/general_info/","text":"General info Land acknowledgement I wish to acknowledge this land on which the University of Toronto operates. For thousands of years it has been the traditional land of the Huron-Wendat, the Seneca, and the Mississaugas of the Credit. Today, this meeting place is still the home to many Indigenous people from across Turtle Island and I am grateful to have the opportunity to work on this land. For more information see University of Toronto's land acknowledgement . Group norms The University of Toronto is committed to equity, human rights, and respect for diversity. All members of the learning environment in this course should strive to create an atmosphere of mutual respect where all members of our community can express themselves, engage with each other, and respect one another\u2019s differences. U of T does not condone discrimination or harassment against any persons or communities. Please contact me if you have any concerns. For more information see the Code of Student Conduct . Accessibility The University provides academic accommodations for students with disabilities in accordance with the terms of the Ontario Human Rights Code . This occurs through a collaborative process that acknowledges a collective obligation to develop an accessible learning environment that both meets the needs of students and preserves the essential academic requirements of the University\u2019s courses and programs. Students with diverse learning styles and needs are welcome in this course. If you have a disability that may require accommodations, please feel free to get in touch with me and/or the Accessibility Services office . Religious observances The University provides reasonable accommodation of the needs of students who observe religious holy days other than those already accommodated by ordinary scheduling and statutory holidays. Students have a responsibility to alert members of the teaching staff in a timely fashion to upcoming religious observances and anticipated absences and I will make every reasonable effort to avoid scheduling tests, examinations or other compulsory activities at these times. Please reach out to me as early as possible to communicate any anticipated absences related to religious observances, and to discuss any possible related implications for course work. Family care responsibilities The University of Toronto strives to provide a family-friendly environment. You may wish to inform me if you are a student with family responsibilities. If you are a student parent or have family responsibilities, you also may wish to visit the Family Care Office website .","title":"General info"},{"location":"syllabus/general_info/#general-info","text":"","title":"General info"},{"location":"syllabus/general_info/#land-acknowledgement","text":"I wish to acknowledge this land on which the University of Toronto operates. For thousands of years it has been the traditional land of the Huron-Wendat, the Seneca, and the Mississaugas of the Credit. Today, this meeting place is still the home to many Indigenous people from across Turtle Island and I am grateful to have the opportunity to work on this land. For more information see University of Toronto's land acknowledgement .","title":"Land acknowledgement"},{"location":"syllabus/general_info/#group-norms","text":"The University of Toronto is committed to equity, human rights, and respect for diversity. All members of the learning environment in this course should strive to create an atmosphere of mutual respect where all members of our community can express themselves, engage with each other, and respect one another\u2019s differences. U of T does not condone discrimination or harassment against any persons or communities. Please contact me if you have any concerns. For more information see the Code of Student Conduct .","title":"Group norms"},{"location":"syllabus/general_info/#accessibility","text":"The University provides academic accommodations for students with disabilities in accordance with the terms of the Ontario Human Rights Code . This occurs through a collaborative process that acknowledges a collective obligation to develop an accessible learning environment that both meets the needs of students and preserves the essential academic requirements of the University\u2019s courses and programs. Students with diverse learning styles and needs are welcome in this course. If you have a disability that may require accommodations, please feel free to get in touch with me and/or the Accessibility Services office .","title":"Accessibility"},{"location":"syllabus/general_info/#religious-observances","text":"The University provides reasonable accommodation of the needs of students who observe religious holy days other than those already accommodated by ordinary scheduling and statutory holidays. Students have a responsibility to alert members of the teaching staff in a timely fashion to upcoming religious observances and anticipated absences and I will make every reasonable effort to avoid scheduling tests, examinations or other compulsory activities at these times. Please reach out to me as early as possible to communicate any anticipated absences related to religious observances, and to discuss any possible related implications for course work.","title":"Religious observances"},{"location":"syllabus/general_info/#family-care-responsibilities","text":"The University of Toronto strives to provide a family-friendly environment. You may wish to inform me if you are a student with family responsibilities. If you are a student parent or have family responsibilities, you also may wish to visit the Family Care Office website .","title":"Family care responsibilities"},{"location":"syllabus/instructors/","text":"Instructors Professor Matthew Osmond (he/him) email: mm.osmond@utoronto.ca office hours: Wednesday 11-12, Earth Sciences Centre (ESC) 3041 website: osmond-lab.github.io Teaching assistant Puneeth Deraje (he/him) email: puneeth.deraje@mail.utoronto.ca office hours: Thursday 10-11, ESC 3046","title":"Instructors"},{"location":"syllabus/instructors/#instructors","text":"","title":"Instructors"},{"location":"syllabus/instructors/#professor","text":"Matthew Osmond (he/him) email: mm.osmond@utoronto.ca office hours: Wednesday 11-12, Earth Sciences Centre (ESC) 3041 website: osmond-lab.github.io","title":"Professor"},{"location":"syllabus/instructors/#teaching-assistant","text":"Puneeth Deraje (he/him) email: puneeth.deraje@mail.utoronto.ca office hours: Thursday 10-11, ESC 3046","title":"Teaching assistant"},{"location":"syllabus/other_resources/","text":"Other resources There are many resources available at the University to help you succeed in this course. Below are a few: Writing Center Academic integrity More on academic integrity CTSI list of supports Academic success module Get help with Quercus","title":"Other resources"},{"location":"syllabus/other_resources/#other-resources","text":"There are many resources available at the University to help you succeed in this course. Below are a few: Writing Center Academic integrity More on academic integrity CTSI list of supports Academic success module Get help with Quercus","title":"Other resources"},{"location":"syllabus/textbook/","text":"Textbook Otto & Day 2007. A biologist's guide to mathematical modeling in ecology and evolution . UofT library e-copies UofT library physical-copies buy your own copy","title":"Textbook"},{"location":"syllabus/textbook/#textbook","text":"Otto & Day 2007. A biologist's guide to mathematical modeling in ecology and evolution . UofT library e-copies UofT library physical-copies buy your own copy","title":"Textbook"},{"location":"syllabus/when_and_where/","text":"When and where Lectures Monday & Wednesday, 10:10 - 11:00 AM, Ramsay Wright (RW) 142 Labs Wednesday, 3:10 - 5:00 PM, RW 109/107","title":"When and where"},{"location":"syllabus/when_and_where/#when-and-where","text":"","title":"When and where"},{"location":"syllabus/when_and_where/#lectures","text":"Monday & Wednesday, 10:10 - 11:00 AM, Ramsay Wright (RW) 142","title":"Lectures"},{"location":"syllabus/when_and_where/#labs","text":"Wednesday, 3:10 - 5:00 PM, RW 109/107","title":"Labs"}]}