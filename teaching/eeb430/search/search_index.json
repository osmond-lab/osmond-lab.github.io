{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"EEB430 Modelling in Ecology and Evolution Mathematics is central to science because it provides a rigorous way to go from a set of assumptions to their logical consequences. In ecology & evolution this might be how we think a virus will spread and evolve, how climate change will impact a threatened population, or how much genetic diversity we expect to see in a randomly mating population. In this course you'll learn how to build, analyze, and interpret mathematical models of increasing complexity through readings, lectures, tutorials, assignments, computer labs, and a final project. Our focus is on deterministic dynamical models (recursions and differential equations) but we'll also touch on probability theory and stochastic simulations near the end. Please see the University of Toronto Academic Calendar for more details on the course prerequisites and additional information on the distribution/breadth requirements this course satisfies.","title":"Overview"},{"location":"acknowledgements/","text":"Acknowledgements This course is based on a fantastic textbook by Sally Otto and Troy Day , A biologist's guide to mathematical modeling in ecology and evolution . I've been fortunate to have been taught by both of these excellent mentors and I hope I can do them and their book justice. I'm also very grateful to Leithen M'Gonigle who has slickly elaborated on Sally's lecture notes in LaTeX and kindly shared them with me. Thanks also to Ailene McPherson who, along with Sally and Leithen, continues to help me teach this course and inspires me to become a better teacher. Thanks are also due to Puneeth Deraje who has gone above and beyond as a TA. And you wouldn't be reading this without the help of Tom Ouellette who did an amazing job creating this website. Finally, thanks to all the students who have taken the course and given me feedback (explicit or not) -- thanks for your patience!","title":"Acknowledgements"},{"location":"acknowledgements/#acknowledgements","text":"This course is based on a fantastic textbook by Sally Otto and Troy Day , A biologist's guide to mathematical modeling in ecology and evolution . I've been fortunate to have been taught by both of these excellent mentors and I hope I can do them and their book justice. I'm also very grateful to Leithen M'Gonigle who has slickly elaborated on Sally's lecture notes in LaTeX and kindly shared them with me. Thanks also to Ailene McPherson who, along with Sally and Leithen, continues to help me teach this course and inspires me to become a better teacher. Thanks are also due to Puneeth Deraje who has gone above and beyond as a TA. And you wouldn't be reading this without the help of Tom Ouellette who did an amazing job creating this website. Finally, thanks to all the students who have taken the course and given me feedback (explicit or not) -- thanks for your patience!","title":"Acknowledgements"},{"location":"labs/schedule/","text":"Schedule Lab Topic Notebook 1 Introduction to Jupyter, Python, and SymPy 2 Simulating recursion equations 3 Numerical and graphical techniques 4 Equilibria and stability (univariate) 5 General solutions (univariate) 6 Midterm - 7 Linear algebra in SymPy - 8 Multivariate models - 9 Demography - 10 Evolutionary invasion analysis - 11 Stochastic models of evolution - 12 Stochastic population dynamics - To access a lab, click on the image. The easiest option is then to \"Open with Google Colaboratory\", but you can also download the notebook and open it locally (this requires you install Jupyter, Python, and required Python libraries).","title":"Schedule"},{"location":"labs/schedule/#schedule","text":"Lab Topic Notebook 1 Introduction to Jupyter, Python, and SymPy 2 Simulating recursion equations 3 Numerical and graphical techniques 4 Equilibria and stability (univariate) 5 General solutions (univariate) 6 Midterm - 7 Linear algebra in SymPy - 8 Multivariate models - 9 Demography - 10 Evolutionary invasion analysis - 11 Stochastic models of evolution - 12 Stochastic population dynamics - To access a lab, click on the image. The easiest option is then to \"Open with Google Colaboratory\", but you can also download the notebook and open it locally (this requires you install Jupyter, Python, and required Python libraries).","title":"Schedule"},{"location":"lectures/lecture-01/","text":"{ requestKernel: true, mountActivateWidget: true, mountStatusWidget: true, binderOptions: { repo: \"tomouellette/executable-cells\", ref: \"main\", binderUrl: \"https://gke.mybinder.org\", }, } Lecture 1: Introduction Run notes interactively? Lecture overview Why use mathematical models in ecology and evolution? Syllabus 1. Why use mathematical models in ecology and evolution? Mathematics permeates ecology and evolution, from simple back-of-the-envelope calculations to the development of sophisticated mathematical models. This is because mathematics is a unique tool that can take what we already know (or assume to be true) and rigorously lead us to the logical conclusions. To see this (while also introducing you to the kind of models I work with), let's look at a few examples. Example 1: HIV See sections 1.2-1.4 of the text for more info. Human immunodeficiency virus (HIV) is, as the name suggests, a virus that infects humans and causes acquired immunodeficiency syndrome (AIDS). This is a terrible diesase that has caused over 20 million deaths worldwide. It is transmitted via bodily fluids. Once inside the body HIV particles (virions) attach to a protein called CD4 on the cell membrane of helper T cells (part of our immune system) and others. Once attached, the virus inserts its RNA into the host cell, which is reverse transcribed into DNA and becomes part of the host genome. The host cell can remain in the 'latently infected' state for some time. When the viral DNA is eventually transcribed by the host cell, starting an 'active infection', hundreds of new virions are produced, often killing the host cell. These new virions then go on to infect other CD4+ cells. A large decline in the number of helper T cells is what causes AIDS. This is because helper T cells bind to viruses and secrete chemical signals to stimulate the immune system. So without helper T cells the immune system is very comprimised. Based on this, once infected with HIV (and without treatment) we expect the number of virions to rapidly increase and the number of helper T cells to decline. This is generally what is observed. However, the number of virions then tends to steeply decline. Why might this be? Here are two hypotheses: the immune system recognizes HIV and suppresses it the decline in helper T cells prevents HIV from replicating To decide whether the second hypothesis is valid Phillips (1996) built a mathematical model describing the rate of change in the number of CD4+ cells and free virions. See the note below for the details of the model if you are interested (but don't worry if you don't understand all this yet!). Details of the Philips (1996) model See Box 2.4 in the text for more details. Philips built a dynamical model of the infection process using 4 differential equations: \\(\\frac{dR}{dt} = \\Gamma \\tau - \\mu R - \\beta V R\\) \\(\\frac{dL}{dt} = p \\beta V R - \\mu L - \\alpha L\\) \\(\\frac{dE}{dt} = (1 - p) \\beta V R + \\alpha L - \\delta E\\) \\(\\frac{dV}{dt} = \\pi E - \\sigma V\\) These equations describe the rate of change in the number of susceptible CD4+ cells (R), latently infected cells (L), actively infected cells (E), and free virions (V). These are the 4 \"variables\" of the model, as their values change over time. The remainder of the symbols represent \"parameters\", whose values do not change (they are constants). The meaning of the parameters and the values used by Phillips (1996) are shown in the table below. Symbol Description Value (units/day) \\(\\Gamma\\) Rate that CD4+ cells are produced 1.36 \\(\\tau\\) Proportion of CD4+ cells that are susceptible to attack 0.2 \\(\\mu\\) HIV-independent death rate of susceptible CD4+ cells 1.36 x 10^-3 \\(\\beta\\) Rate of CD4+ cell infection per HIV virion 0.00027 \\(p\\) Proportion of newly infected cells becoming latently infected 0.1 \\(\\alpha\\) Activation rate of latently infected cells 3.6 x 10^-2 \\(\\delta\\) Death rate of actively infected cells 0.33 \\(\\pi\\) Rate of production of virions by actively infected cells 100 \\(\\sigma\\) Removal rate of cell-free virus 2 Given these parameter descriptions, can you \"read\" the differential equations above? For example, what does \\(\\Gamma \\tau\\) represent, biologically? Using these equations and parameter values Philips (1996) asked how the number of CD4+ cells (R + L + E) and free virions (V) changed over time following infection. To see how Philips' model behaves, activate the kernel at the top of the page and run the code below import numpy as np import matplotlib.pyplot as plt # Build a function to iterate through the model (see note above for description of equations) def philips_model(R=200, L=0, E=0, V=4e-5, days=120, steps=120): #choose parameter values gamma, mu, tau, beta, p, alpha, sigma, delta, pi = [1.36, 1.36e-3, 0.2, 0.00027, 0.1, 3.6e-2, 2, 0.33, 100] record = [] for t in np.linspace(0, days, steps): dRdt = gamma * tau - mu * R - beta * V * R R += dRdt dLdt = p * beta * V * R - mu * L - alpha * L L += dLdt dEdt = (1-p) * beta * V * R + alpha * L - delta * E E += dEdt dVdt = pi * E - sigma * V V += dVdt record += ([[R + L + E, V]]) return np.array(record) # Interpolate through differentials and record population sizes steps = 120 days = 120 uninfected_lymphocytes, free_virions = philips_model(days=days, steps=steps).T number_of_days = np.linspace(1, days, steps) # Initialize plot fig, left_ax = plt.subplots() right_ax = left_ax.twinx() fig.set_size_inches(8,4) # Plot data on left axis left_ax.plot(number_of_days, uninfected_lymphocytes, color='green', label='R'); left_ax.set_ylabel('CD4+ cells (R + E + L)', fontsize=14) left_ax.legend(frameon=False, bbox_to_anchor=(0.99, 0.99)) left_ax.set_xlabel('Days from infection', fontsize=14) # Plot data on right axis right_ax.plot(number_of_days, free_virions, color='darkred', label='V'); right_ax.set_ylabel('Free virions V', fontsize=14) right_ax.legend(frameon=False, bbox_to_anchor=(0.99, 0.85)) # Format plot and show it plt.yscale('log') fig.tight_layout() plt.show() Compare to Figure 1.3 and Figure 1.4 in the text. We see the initial increase in virions (red) and delcine in CD4+ cells (green), followed by a decline virions (note the log scale on the right axis -- this is a big decline, from over 1000 to about 10). Because this model does not include an immune response against the virions but still exhibits the decline in virions, we conclude that the second hypothesis is valid, that it is theoretically plausible that the decline in virions is due to a lack of CD4+ cells to infect. A few years later this hypothesis was empirically tested and validated -- a nice example of theory guiding science. Feel free to play around with the code above, changing parameter values or even the structure of the model. Do the dynamics change as you expected? Example 2: Extreme Events A second example is a model that I helped Dr. Kelsey Lyberger (then a PhD student at UC Davis with Sebastian Schreiber) with in Lyberger et al 2021 . Kelsey Lyberger, doing Daphnia fieldwork I assume. Kelsey was interested in how populations respond to extreme climatic events, like hurricanes. It has long been clear that such events can impact the size of a population, e.g., by causing extra mortality, and may in fact put populations at risk of extinction. More recently it has become apparent that extreme events can also impose strong natural selection, and that populations can quickly adapt to the new environment. Some examples include: Ice-storms select on sparrow body size Hurricanes select on lizard limbs and toe pads Droughts select on Darwin finch beaks Droughts select on flowering time in Brassica Now, how should such rapid adaptive evolution impact population size? This is the question Kelsey set out to answer with a mathematical model. To do: give details of Kelsey's model Below is a stochastic simulation much like that used by Kelsey. With an activated kernel, run the code below to create a plot very similar to Figure 1 in Lyberger et al. (this may take a minute). import numpy as np import matplotlib.pyplot as plt def lyberger_model(Vg=0.75, Ve=0, event_duration=1, seed=0, other_parameters=[120, 500, 1, 2, 100, 0, 2.5]): # Unpack parameters generations, K, w, lmbda, event_time, initial_theta_t, dtheta_t = other_parameters # Initialize population members = np.random.normal(initial_theta_t, 0, K) # Run simulations np.random.seed(seed) population_size, mean_breeding_value = [], [] for g in range(generations): if g in np.arange(event_time, event_time + event_duration): theta_t = initial_theta_t + dtheta_t else: theta_t = initial_theta_t # Viability selection prob_survival = np.array([np.exp(-(theta_t - z + np.random.normal(0, Ve))**2 / (2*w**2)) for z in members]) survived = np.array([True if p > np.random.uniform(0,1) else False for p in prob_survival]) if len(survived) == 0: break # Survivors members = members[survived] # Random mating offspring = [] for m in np.random.choice(members, len(members)): if len(offspring) > K: offspring = np.random.choice(offspring, K) break else: n_off = np.random.poisson(lmbda) mate = np.random.choice(members) offspring += [(m + mate)/2 for _ in range(n_off)] # Sample new trait values for offspring offspring = np.array(offspring) offspring = np.random.normal(offspring, Vg) # Record statistics population_size.append(len(offspring)) mean_breeding_value.append(np.mean(offspring)) members = offspring return ( np.arange(0, generations-event_time+1), np.array(population_size[event_time-1:]), np.array(mean_breeding_value[event_time-1:]) ) # Initialize plot fig, ax = plt.subplots(2, sharex=True) fig.set_size_inches(8,6) event_duration = 1 # Run 10 simulations per segregation (V0) and environment variance (VE) parameter combination for Vg, Ve, c, lab in [[1, 0, 'black', 'with evolution'], [0, 1, 'red', 'without evolution']]: # Plot simulations simulations = np.array([lyberger_model(Vg=Vg, Ve=Ve, event_duration=event_duration, seed=s) for s in range(10)]) ax[0].plot(simulations[:,0].T, simulations[:,1].T, color=c, alpha=0.3); ax[1].plot(simulations[:,0].T, simulations[:,2].T, color=c, alpha=0.3); # Hack together only one instance of the legend ax[0].plot([np.min(simulations[:,0].T)], [np.min(simulations[:,1].T)], alpha=1, label = lab, color=c) ax[1].plot([np.min(simulations[:,0].T)], [np.min(simulations[:,2].T)], alpha=1, label = lab, color=c) # Add environmental event duration ax[0].fill_between([0,event_duration], y1=500, alpha=0.2) ax[1].fill_between([0,event_duration], y1=-0.2, y2=2, alpha=0.2) # Add labels ax[0].set_ylabel('Population size', fontsize=12) ax[1].set_ylabel('Mean trait value', fontsize=12) ax[1].set_xlabel('Generation', fontsize=14) # Add legend plt.legend(frameon=False) plt.show() The key result, that you can see in the plot above, is that when extreme events are short, adaptive evolution (black lines) can paradoxically reduce population size (relative to the red lines, where there is no evolution). The reason for this is that, while during the extreme event (shaded section) evolution is adaptive, once the extreme event ends the population finds itself maladapted to the original environment. Adaptive evolution can therefore hamper population persistence, and this is an important thing to keep in mind when documenting rapid adaptive evolution in response to extreme events -- it is not necessarily a good thing for the species (or our conservation goals). Example 3: Sex chromosomes A third example is a model that I worked on during my PhD, led by fellow PhD student Dr. Michael Scott, in Scott et al. 2018 . Michael Scott, with snakes and penguins. The inspiration for this model comes from the fact that new sex determination systems are constantly evolving, as can be deduced from this phylogeny. For example, it is clear from this phylogeny that ZW sex determination (where females are ZW and males are ZZ) has evolved multiple times (eg, in both birds/reptiles and lepidoptera). Figure 3 from Bachtrog et al. 2014 Sex vs gender Here we are referring to biological sex (defined by the type of gametes produced by an individual) not gender (defined by behaviour and morphology). For more information see https://gendersexandnature.wordpress.com and https://genderinclusivebiology.squarespace.com/ . Focusing solely on sex chromosomes (as opposed to hermaphroditism or environmental sex determination (ESD)), there are two main hypotheses for changes in sex determination systems: A \"selfish\" Y chromosome gets in more than 50% of male gametes \\(\\rightarrow\\) more than 50% of the population is male (\"sex-ratio bias\") \\(\\rightarrow\\) a W chromosome, which causes all its carriers to be female, invades because individuals of the rarer sex have more offspring (since every offspring has a female and male parent). Selection favours different copies of a gene in the two sexes (\"sexually-antagonistic selection\") \\(\\rightarrow\\) the chromosome carrying this gene becomes a new sex chromosome, allowing the gene copy (\"allele\") favoured in males to be on the Y chromosome (and therefore only in males) and the allele favoured in females to be on the X (which is in females 2/3 of the time). A key element missing from both of these hypotheses (and models supporting them) is selection that occurs during the haploid phase of the life-cycle (eg, competition between pollen grains for fertilization of an ovule). This \"haploid selection\" is important to consider because it can cause both sex-ratio bias (eg, if pollen grains carrying a Y are more successful than those carrying an X) and sexually-antagonistic selection (eg, if selection at the haploid phase differs between gamete types). It can also cause selection to differ at the haploid and diploid stages of the life-cycle (\"ploidally-antagonistic selection\"). So how is haploid selection expected to affect turnover between sex determination systems? Michael and I built a model to ask this question, with the help of Sally Otto (our supervisor), and used many of the techniques covered in this class to analyze it. To do: add model details (Placeholder) Modelling plan discussed on the way home from a conference This was quite a complicated model and analysis, but the general take-home was that haploid selection greatly increases the scope for sex chromosome turnover. For example, in the plot below we see a case where selection favours one allele in male gametes (eg, during pollen competition) and another allele in diploids (ie, this is ploidally-antagonistic selection). Despite the fact that it causes sex-ratio bias (dashed curve), the Y chromosome spreads through the population (black and gray curves), while at the same time a W chromosome invades (blue curve) and equalizes the sex ratio. To do: add code to create this plot Sex chromosome turnover. The conclusion we reached from this mathematical model -- that haploid selection is expected to lead to more turnovers in sex determination systems -- was simultaneously supported by work done in Stephen Wright's lab here in EEB, by (then undergrad and now PhD student) George Sandler in Sandler et al. 2018 . 2. Syllabus OK, now that we've gone over some motivating examples of modeling in ecology and evolution, let's take a look at how we're going to learn to become modelers in this course. Point your browser over to the syllabus and read each of the pages there.","title":"Lecture 1"},{"location":"lectures/lecture-01/#lecture-1-introduction","text":"Run notes interactively?","title":"Lecture 1: Introduction"},{"location":"lectures/lecture-01/#lecture-overview","text":"Why use mathematical models in ecology and evolution? Syllabus","title":"Lecture overview"},{"location":"lectures/lecture-01/#1-why-use-mathematical-models-in-ecology-and-evolution","text":"Mathematics permeates ecology and evolution, from simple back-of-the-envelope calculations to the development of sophisticated mathematical models. This is because mathematics is a unique tool that can take what we already know (or assume to be true) and rigorously lead us to the logical conclusions. To see this (while also introducing you to the kind of models I work with), let's look at a few examples.","title":"1. Why use mathematical models in ecology and evolution?"},{"location":"lectures/lecture-01/#example-1-hiv","text":"See sections 1.2-1.4 of the text for more info. Human immunodeficiency virus (HIV) is, as the name suggests, a virus that infects humans and causes acquired immunodeficiency syndrome (AIDS). This is a terrible diesase that has caused over 20 million deaths worldwide. It is transmitted via bodily fluids. Once inside the body HIV particles (virions) attach to a protein called CD4 on the cell membrane of helper T cells (part of our immune system) and others. Once attached, the virus inserts its RNA into the host cell, which is reverse transcribed into DNA and becomes part of the host genome. The host cell can remain in the 'latently infected' state for some time. When the viral DNA is eventually transcribed by the host cell, starting an 'active infection', hundreds of new virions are produced, often killing the host cell. These new virions then go on to infect other CD4+ cells. A large decline in the number of helper T cells is what causes AIDS. This is because helper T cells bind to viruses and secrete chemical signals to stimulate the immune system. So without helper T cells the immune system is very comprimised. Based on this, once infected with HIV (and without treatment) we expect the number of virions to rapidly increase and the number of helper T cells to decline. This is generally what is observed. However, the number of virions then tends to steeply decline. Why might this be? Here are two hypotheses: the immune system recognizes HIV and suppresses it the decline in helper T cells prevents HIV from replicating To decide whether the second hypothesis is valid Phillips (1996) built a mathematical model describing the rate of change in the number of CD4+ cells and free virions. See the note below for the details of the model if you are interested (but don't worry if you don't understand all this yet!). Details of the Philips (1996) model See Box 2.4 in the text for more details. Philips built a dynamical model of the infection process using 4 differential equations: \\(\\frac{dR}{dt} = \\Gamma \\tau - \\mu R - \\beta V R\\) \\(\\frac{dL}{dt} = p \\beta V R - \\mu L - \\alpha L\\) \\(\\frac{dE}{dt} = (1 - p) \\beta V R + \\alpha L - \\delta E\\) \\(\\frac{dV}{dt} = \\pi E - \\sigma V\\) These equations describe the rate of change in the number of susceptible CD4+ cells (R), latently infected cells (L), actively infected cells (E), and free virions (V). These are the 4 \"variables\" of the model, as their values change over time. The remainder of the symbols represent \"parameters\", whose values do not change (they are constants). The meaning of the parameters and the values used by Phillips (1996) are shown in the table below. Symbol Description Value (units/day) \\(\\Gamma\\) Rate that CD4+ cells are produced 1.36 \\(\\tau\\) Proportion of CD4+ cells that are susceptible to attack 0.2 \\(\\mu\\) HIV-independent death rate of susceptible CD4+ cells 1.36 x 10^-3 \\(\\beta\\) Rate of CD4+ cell infection per HIV virion 0.00027 \\(p\\) Proportion of newly infected cells becoming latently infected 0.1 \\(\\alpha\\) Activation rate of latently infected cells 3.6 x 10^-2 \\(\\delta\\) Death rate of actively infected cells 0.33 \\(\\pi\\) Rate of production of virions by actively infected cells 100 \\(\\sigma\\) Removal rate of cell-free virus 2 Given these parameter descriptions, can you \"read\" the differential equations above? For example, what does \\(\\Gamma \\tau\\) represent, biologically? Using these equations and parameter values Philips (1996) asked how the number of CD4+ cells (R + L + E) and free virions (V) changed over time following infection. To see how Philips' model behaves, activate the kernel at the top of the page and run the code below import numpy as np import matplotlib.pyplot as plt # Build a function to iterate through the model (see note above for description of equations) def philips_model(R=200, L=0, E=0, V=4e-5, days=120, steps=120): #choose parameter values gamma, mu, tau, beta, p, alpha, sigma, delta, pi = [1.36, 1.36e-3, 0.2, 0.00027, 0.1, 3.6e-2, 2, 0.33, 100] record = [] for t in np.linspace(0, days, steps): dRdt = gamma * tau - mu * R - beta * V * R R += dRdt dLdt = p * beta * V * R - mu * L - alpha * L L += dLdt dEdt = (1-p) * beta * V * R + alpha * L - delta * E E += dEdt dVdt = pi * E - sigma * V V += dVdt record += ([[R + L + E, V]]) return np.array(record) # Interpolate through differentials and record population sizes steps = 120 days = 120 uninfected_lymphocytes, free_virions = philips_model(days=days, steps=steps).T number_of_days = np.linspace(1, days, steps) # Initialize plot fig, left_ax = plt.subplots() right_ax = left_ax.twinx() fig.set_size_inches(8,4) # Plot data on left axis left_ax.plot(number_of_days, uninfected_lymphocytes, color='green', label='R'); left_ax.set_ylabel('CD4+ cells (R + E + L)', fontsize=14) left_ax.legend(frameon=False, bbox_to_anchor=(0.99, 0.99)) left_ax.set_xlabel('Days from infection', fontsize=14) # Plot data on right axis right_ax.plot(number_of_days, free_virions, color='darkred', label='V'); right_ax.set_ylabel('Free virions V', fontsize=14) right_ax.legend(frameon=False, bbox_to_anchor=(0.99, 0.85)) # Format plot and show it plt.yscale('log') fig.tight_layout() plt.show() Compare to Figure 1.3 and Figure 1.4 in the text. We see the initial increase in virions (red) and delcine in CD4+ cells (green), followed by a decline virions (note the log scale on the right axis -- this is a big decline, from over 1000 to about 10). Because this model does not include an immune response against the virions but still exhibits the decline in virions, we conclude that the second hypothesis is valid, that it is theoretically plausible that the decline in virions is due to a lack of CD4+ cells to infect. A few years later this hypothesis was empirically tested and validated -- a nice example of theory guiding science. Feel free to play around with the code above, changing parameter values or even the structure of the model. Do the dynamics change as you expected?","title":"Example 1: HIV"},{"location":"lectures/lecture-01/#example-2-extreme-events","text":"A second example is a model that I helped Dr. Kelsey Lyberger (then a PhD student at UC Davis with Sebastian Schreiber) with in Lyberger et al 2021 . Kelsey Lyberger, doing Daphnia fieldwork I assume. Kelsey was interested in how populations respond to extreme climatic events, like hurricanes. It has long been clear that such events can impact the size of a population, e.g., by causing extra mortality, and may in fact put populations at risk of extinction. More recently it has become apparent that extreme events can also impose strong natural selection, and that populations can quickly adapt to the new environment. Some examples include: Ice-storms select on sparrow body size Hurricanes select on lizard limbs and toe pads Droughts select on Darwin finch beaks Droughts select on flowering time in Brassica Now, how should such rapid adaptive evolution impact population size? This is the question Kelsey set out to answer with a mathematical model. To do: give details of Kelsey's model Below is a stochastic simulation much like that used by Kelsey. With an activated kernel, run the code below to create a plot very similar to Figure 1 in Lyberger et al. (this may take a minute). import numpy as np import matplotlib.pyplot as plt def lyberger_model(Vg=0.75, Ve=0, event_duration=1, seed=0, other_parameters=[120, 500, 1, 2, 100, 0, 2.5]): # Unpack parameters generations, K, w, lmbda, event_time, initial_theta_t, dtheta_t = other_parameters # Initialize population members = np.random.normal(initial_theta_t, 0, K) # Run simulations np.random.seed(seed) population_size, mean_breeding_value = [], [] for g in range(generations): if g in np.arange(event_time, event_time + event_duration): theta_t = initial_theta_t + dtheta_t else: theta_t = initial_theta_t # Viability selection prob_survival = np.array([np.exp(-(theta_t - z + np.random.normal(0, Ve))**2 / (2*w**2)) for z in members]) survived = np.array([True if p > np.random.uniform(0,1) else False for p in prob_survival]) if len(survived) == 0: break # Survivors members = members[survived] # Random mating offspring = [] for m in np.random.choice(members, len(members)): if len(offspring) > K: offspring = np.random.choice(offspring, K) break else: n_off = np.random.poisson(lmbda) mate = np.random.choice(members) offspring += [(m + mate)/2 for _ in range(n_off)] # Sample new trait values for offspring offspring = np.array(offspring) offspring = np.random.normal(offspring, Vg) # Record statistics population_size.append(len(offspring)) mean_breeding_value.append(np.mean(offspring)) members = offspring return ( np.arange(0, generations-event_time+1), np.array(population_size[event_time-1:]), np.array(mean_breeding_value[event_time-1:]) ) # Initialize plot fig, ax = plt.subplots(2, sharex=True) fig.set_size_inches(8,6) event_duration = 1 # Run 10 simulations per segregation (V0) and environment variance (VE) parameter combination for Vg, Ve, c, lab in [[1, 0, 'black', 'with evolution'], [0, 1, 'red', 'without evolution']]: # Plot simulations simulations = np.array([lyberger_model(Vg=Vg, Ve=Ve, event_duration=event_duration, seed=s) for s in range(10)]) ax[0].plot(simulations[:,0].T, simulations[:,1].T, color=c, alpha=0.3); ax[1].plot(simulations[:,0].T, simulations[:,2].T, color=c, alpha=0.3); # Hack together only one instance of the legend ax[0].plot([np.min(simulations[:,0].T)], [np.min(simulations[:,1].T)], alpha=1, label = lab, color=c) ax[1].plot([np.min(simulations[:,0].T)], [np.min(simulations[:,2].T)], alpha=1, label = lab, color=c) # Add environmental event duration ax[0].fill_between([0,event_duration], y1=500, alpha=0.2) ax[1].fill_between([0,event_duration], y1=-0.2, y2=2, alpha=0.2) # Add labels ax[0].set_ylabel('Population size', fontsize=12) ax[1].set_ylabel('Mean trait value', fontsize=12) ax[1].set_xlabel('Generation', fontsize=14) # Add legend plt.legend(frameon=False) plt.show() The key result, that you can see in the plot above, is that when extreme events are short, adaptive evolution (black lines) can paradoxically reduce population size (relative to the red lines, where there is no evolution). The reason for this is that, while during the extreme event (shaded section) evolution is adaptive, once the extreme event ends the population finds itself maladapted to the original environment. Adaptive evolution can therefore hamper population persistence, and this is an important thing to keep in mind when documenting rapid adaptive evolution in response to extreme events -- it is not necessarily a good thing for the species (or our conservation goals).","title":"Example 2: Extreme Events"},{"location":"lectures/lecture-01/#example-3-sex-chromosomes","text":"A third example is a model that I worked on during my PhD, led by fellow PhD student Dr. Michael Scott, in Scott et al. 2018 . Michael Scott, with snakes and penguins. The inspiration for this model comes from the fact that new sex determination systems are constantly evolving, as can be deduced from this phylogeny. For example, it is clear from this phylogeny that ZW sex determination (where females are ZW and males are ZZ) has evolved multiple times (eg, in both birds/reptiles and lepidoptera). Figure 3 from Bachtrog et al. 2014 Sex vs gender Here we are referring to biological sex (defined by the type of gametes produced by an individual) not gender (defined by behaviour and morphology). For more information see https://gendersexandnature.wordpress.com and https://genderinclusivebiology.squarespace.com/ . Focusing solely on sex chromosomes (as opposed to hermaphroditism or environmental sex determination (ESD)), there are two main hypotheses for changes in sex determination systems: A \"selfish\" Y chromosome gets in more than 50% of male gametes \\(\\rightarrow\\) more than 50% of the population is male (\"sex-ratio bias\") \\(\\rightarrow\\) a W chromosome, which causes all its carriers to be female, invades because individuals of the rarer sex have more offspring (since every offspring has a female and male parent). Selection favours different copies of a gene in the two sexes (\"sexually-antagonistic selection\") \\(\\rightarrow\\) the chromosome carrying this gene becomes a new sex chromosome, allowing the gene copy (\"allele\") favoured in males to be on the Y chromosome (and therefore only in males) and the allele favoured in females to be on the X (which is in females 2/3 of the time). A key element missing from both of these hypotheses (and models supporting them) is selection that occurs during the haploid phase of the life-cycle (eg, competition between pollen grains for fertilization of an ovule). This \"haploid selection\" is important to consider because it can cause both sex-ratio bias (eg, if pollen grains carrying a Y are more successful than those carrying an X) and sexually-antagonistic selection (eg, if selection at the haploid phase differs between gamete types). It can also cause selection to differ at the haploid and diploid stages of the life-cycle (\"ploidally-antagonistic selection\"). So how is haploid selection expected to affect turnover between sex determination systems? Michael and I built a model to ask this question, with the help of Sally Otto (our supervisor), and used many of the techniques covered in this class to analyze it. To do: add model details (Placeholder) Modelling plan discussed on the way home from a conference This was quite a complicated model and analysis, but the general take-home was that haploid selection greatly increases the scope for sex chromosome turnover. For example, in the plot below we see a case where selection favours one allele in male gametes (eg, during pollen competition) and another allele in diploids (ie, this is ploidally-antagonistic selection). Despite the fact that it causes sex-ratio bias (dashed curve), the Y chromosome spreads through the population (black and gray curves), while at the same time a W chromosome invades (blue curve) and equalizes the sex ratio. To do: add code to create this plot Sex chromosome turnover. The conclusion we reached from this mathematical model -- that haploid selection is expected to lead to more turnovers in sex determination systems -- was simultaneously supported by work done in Stephen Wright's lab here in EEB, by (then undergrad and now PhD student) George Sandler in Sandler et al. 2018 .","title":"Example 3: Sex chromosomes"},{"location":"lectures/lecture-01/#2-syllabus","text":"OK, now that we've gone over some motivating examples of modeling in ecology and evolution, let's take a look at how we're going to learn to become modelers in this course. Point your browser over to the syllabus and read each of the pages there.","title":"2. Syllabus"},{"location":"lectures/lecture-02/","text":"{ requestKernel: true, mountActivateWidget: true, mountStatusWidget: true, binderOptions: { repo: \"tomouellette/executable-cells\", ref: \"main\", binderUrl: \"https://gke.mybinder.org\", }, } Lecture 2: Model construction Run notes interactively? Lecture overview Constructing a model Evolution and the Hardy-Weinberg equilibrium 1. Constructing a model Although many problems require specific formulations and assumptions, there are a few general principles to constructing a model. i. Formulate the question What do you want to know? Describe the model in the form of a question. Simplify, Simplify! Start with the simplest, biologically reasonable description of the problem. ii. Determine the basic ingredients Define the variables in the model. Describe any constraints on the variables. Describe any interactions between variables. Decide whether you will treat time as discrete or continuous. Choose a time scale (i.e., decide what a time step equals in discrete time and specify whether rates will be measured per second, minute, day, year, generation, etc.). Define the parameters in the model. Describe any constraints on the parameters. iii. Qualitatively describe the biological system For continuous-time models, draw a flow diagram to describe changes to the variables over time. For example, if we had a population experiencing migration, death, and birth we could draw the following. graph LR; A((n)) --birth--> A; B[ ] --migration--> A; A --death--> C[ ]; style B height:0px; style C height:0px; Figure. Continuous time flow diagram. For discrete-time models, draw a life-cycle diagram with all the events that occur each time unit. For example, if we were modeling a population that experienced migration, then birth, then death each time step, we could draw the following. graph LR; A((n)) --migration--> B((n')); B --birth--> C((n'')); C --death--> A; Figure. Discrete-time life-cycle diagram. For discrete time models with multiple variables and events, construct a table listing the outcome of every event. We'll see an example of this below. iv. Quantitatively describe the biological system Using the diagrams and tables as a guide, write down the equations. Perform checks. Are the constraints on the variables still met as time passes? Make sure that the units of the right-hand side equal those on the left-hand side. For continuous-time models, add rates for arrows coming in to the flow diagram and subtract rates for arrows coming out of the flow diagram. For example, in the model shown above the rate of change in the number of individuals, \\(\\frac{\\mathrm{d} n(t)}{\\mathrm{d} t}\\) , is \\[ \\frac{\\mathrm{d} n(t)}{\\mathrm{d} t} = m + b n(t) - d n(t) \\] where \\(m\\) , \\(b\\) , and \\(d\\) are the per capita (ie, per individual) rates of migration, birth, and death. In discrete time, you must take into account the order of events when constructing equations. To build an equation for the population size in the next generation, \\(n(t+1)\\) , based on the life-cycle diagram above, first construct an equation for each event \\[n' = n_t + m\\] \\[n'' = n' + bn'\\] \\[n_{t+1} = n'' - dn''\\] Note Note that \\(m\\) and \\(d\\) are now the fraction of individuals that migrate and die, and \\(b\\) is the number of offspring per parent (above these parameters were all rates ). Next, substitute \\(n''\\) and then \\(n'\\) into the equation for \\(n_{t+1}\\) to write \\(n_{t+1}\\) in terms of \\(n_t\\) \\[ \\begin{aligned} n_{t+1} &= n'' \u2212 dn'' \\\\ &= (n' + bn\u2032) \u2212 d(n' + bn\u2032) \\\\ &= n'(1 + b \u2212 d \u2212 db) \\\\ &= (n_t +m)(1+b\u2212d\u2212db) \\\\ \\end{aligned} \\] We now have a recursion equation that correctly takes into account the order of the life cycle (migration, birth, death) and the point at which the census is taken (immediately after death). v. Analyze the equations Start by using the equations to simulate and graph the changes to the system over time. Choose and perform appropriate analyses. Make sure that the analyses can address the problem. vi. Checks and balances Check the results against data or any known special cases. Determine how general the results are. Consider alternatives to the simplest model. Extend or simplify the model, as appropriate, and repeat steps 2-5. vii. Relate the results back to the question Do the results answer the biological question? Are the results counter-intuitive? Why? Interpret the results verbally, and describe conceptually any new insights into the biological process. Describe potential experiments. 2. Evolution and the Hardy-Weinberg equilibrium Natural selection Natural selection requires three conditions be met ( Lewontin 1970 ): Variation in traits: different individuals have different traits Variation in fitness: different traits have different rates of survival and/or reproduction Fitness is heritable: traits are inherited to some degree Although selection is an important idea, it's impossible to know what kind of observations are consistent with selection if we don't have a baseline to compare against. So let's first construct a model of evolution in the absence of selection using the general steps described in section 1, Constructing a model . Evolution in the absence of selection i. Formulate the question What do you want to know How do allele frequencies change over time in the absence of natural selection? Boil the question down In a diploid population with two variant \"alleles\" of a gene (A and a), how will the frequency of the A allele change over time? Simple, biologically reasonable description We assume that each diploid genotype (AA, Aa, and aa) has equal fitness and that individuals reproduce and then die (non-overlapping generations). We also assume that individuals produce haploid gametes that form a gamete pool. Gametes within the gamete pool unite at random to produce the next generation of diploid individuals. ii. Determine the basic ingredients Variables \\(x\\) = frequency of AA individuals \\(y\\) = frequency of Aa individuals \\(z\\) = frequency of aa individuals From this we can extract the allele frequencies the frequency of A is \\(p = x + y/2\\) (ie, all of the alleles in genotype AA ( \\(x\\) ) are A but only 1/2 of the alleles in genotype Aa ( \\(y\\) ) are A) the frequency of a is \\(q = 1 - p = y/2 + z\\) Constraints on these variables \\(x\\) , \\(y\\) , \\(z\\) are \\(\u22650\\) and \\(\u22641\\) \\(x+y+z=1\\) How we'll treat time We will follow the genotype frequencies from one generation to the next, using a discrete-time model Parameters there are no parameters in this model (which is a little bit unusual) iii. Qualitatively describe the biological system Gametes unite at random in the gamete pool to produce diploid offspring. These offspring grow into adults that undergo meiosis, creating gametes, and die. Below we draw the life-cycle diagram. graph LR; A((random<br> union)) --diploid--> B((meiosis)); B --haploid--> A; iv. Quantiatively describe the biological system To calculate the frequency of each genoytpe in the next generation we use a table of events. The \"Union\" column indicates the pair of gametes that are meeting each other, the \"Frequency\" column indicates the proportion of gamete pairs in the population with this particular union, and the remaining columns indicate which diploid genotype is created by the union. Union Frequency AA Aa aa A x A \\(p^2\\) 1 0 0 A x a \\(pq\\) 0 1 0 a x A \\(qp\\) 0 1 0 a x a \\(q^2\\) 0 0 1 \\(p^2\\) \\(2pq\\) \\(q^2\\) The genotype frequencies denoted in red are known as the Hardy-Weinberg frequencies . Note that this table shows that populations not at \"Hardy-Weinberg equilibrium\" reach Hardy-Weinberg equilibrium after only one generation of random mating. We now have the frequency of genotypes in the next generation in terms of the allele frequencies in the previous generation, \\[x' = p^2\\] \\[y' = 2pq\\] \\[z' = q^2\\] To understand how the genotype frequencies at Hardy-Weinberg vary with allele frequency, we can plot them. from sympy import * var('p') x = p**2 #frequency of AA at Hardy-Weinberg as a function of the frequency of allele A y = 2*p*(1-p) #freq of Aa z = (1-p)**2 #freq of aa p = plot(x, y, z, #functions that we are plotting (p,0,1), #plot as a function of allele frequency from 0 to 1 xlabel=\"allele frequency, $p$\", ylabel=\"genotype frequency\", legend=True, show=False ) p[0].label='AA' #give legend genotype labels p[1].label='Aa' p[2].label='aa' p.show() From this plot we see, for example, that the frequency of heterozygotes, Aa, is maximized at intermediate allele frequencies. Subbing in \\(p=x+y/2\\) and \\(q=y/2+z\\) we get the recursion equations describing the frequency of diploid genotypes in the next generation as a function of the diploid genotypes in the current generation, \\[x' = (x + y/2)^2\\] \\[y' = 2(x + y/2)(y/2 + z)\\] \\[z' = (y/2 + z)^2\\] v. Analyze the equations Now back to our question. What is the frequency of allele A in the next generation? \\[p' = x' + y'/2\\] \\[p' = p^2 + 2pq/2\\] \\[p' = p(p + q)\\] \\[p' = p\\] vi. Checks and balances Does \\(x' + y' + z' = 1\\) ? \\[ \\begin{aligned} x' + y' + z' &= p^2 + 2pq + q^2\\\\ &= (p+q)^2\\\\ &= (1)^2\\\\ &= 1 \\end{aligned} \\] vii. Relate the results back to the question How do allele frequencies change over time in the absence of natural selection? They don't Data example: blood types Below is a table describing the frequency of three different blood types (and their associated genotype) in a sample of humans from the USA. Blood type M MN N Genotype MM MN NN Observed frequency in USA 0.292 0.496 0.212 We ask, are these genotypes near Hardy-Weinberg equilibrium? First, write the frequency of each genotype as \\(x\\) , \\(y\\) , and \\(z\\) \\[x = 0.292\\] \\[y = 0.496\\] \\[z = 0.212\\] Next, convert the genotype frequencies into allele frequencies \\[p = x + y/2 = 0.540\\] \\[q = y/2 + z = 0.460\\] Now predict what the genotype frequencies would be at Hardy-Weinberg equilibrium \\[x = p^2 = 0.2916\\] \\[y = 2pq = 0.4985\\] \\[z = q^2 = 0.2116\\] These predicted genotype frequencies are exceptionally close to those actually observed, indicating Hardy-Weinberg equilibrium and suggesting an absence of selection on this phenotype.","title":"Lecture 2"},{"location":"lectures/lecture-02/#lecture-2-model-construction","text":"Run notes interactively?","title":"Lecture 2: Model construction"},{"location":"lectures/lecture-02/#lecture-overview","text":"Constructing a model Evolution and the Hardy-Weinberg equilibrium","title":"Lecture overview"},{"location":"lectures/lecture-02/#1-constructing-a-model","text":"Although many problems require specific formulations and assumptions, there are a few general principles to constructing a model.","title":"1. Constructing a model"},{"location":"lectures/lecture-02/#i-formulate-the-question","text":"What do you want to know? Describe the model in the form of a question. Simplify, Simplify! Start with the simplest, biologically reasonable description of the problem.","title":"i. Formulate the question"},{"location":"lectures/lecture-02/#ii-determine-the-basic-ingredients","text":"Define the variables in the model. Describe any constraints on the variables. Describe any interactions between variables. Decide whether you will treat time as discrete or continuous. Choose a time scale (i.e., decide what a time step equals in discrete time and specify whether rates will be measured per second, minute, day, year, generation, etc.). Define the parameters in the model. Describe any constraints on the parameters.","title":"ii. Determine the basic ingredients"},{"location":"lectures/lecture-02/#iii-qualitatively-describe-the-biological-system","text":"For continuous-time models, draw a flow diagram to describe changes to the variables over time. For example, if we had a population experiencing migration, death, and birth we could draw the following. graph LR; A((n)) --birth--> A; B[ ] --migration--> A; A --death--> C[ ]; style B height:0px; style C height:0px; Figure. Continuous time flow diagram. For discrete-time models, draw a life-cycle diagram with all the events that occur each time unit. For example, if we were modeling a population that experienced migration, then birth, then death each time step, we could draw the following. graph LR; A((n)) --migration--> B((n')); B --birth--> C((n'')); C --death--> A; Figure. Discrete-time life-cycle diagram. For discrete time models with multiple variables and events, construct a table listing the outcome of every event. We'll see an example of this below.","title":"iii. Qualitatively describe the biological system"},{"location":"lectures/lecture-02/#iv-quantitatively-describe-the-biological-system","text":"Using the diagrams and tables as a guide, write down the equations. Perform checks. Are the constraints on the variables still met as time passes? Make sure that the units of the right-hand side equal those on the left-hand side. For continuous-time models, add rates for arrows coming in to the flow diagram and subtract rates for arrows coming out of the flow diagram. For example, in the model shown above the rate of change in the number of individuals, \\(\\frac{\\mathrm{d} n(t)}{\\mathrm{d} t}\\) , is \\[ \\frac{\\mathrm{d} n(t)}{\\mathrm{d} t} = m + b n(t) - d n(t) \\] where \\(m\\) , \\(b\\) , and \\(d\\) are the per capita (ie, per individual) rates of migration, birth, and death. In discrete time, you must take into account the order of events when constructing equations. To build an equation for the population size in the next generation, \\(n(t+1)\\) , based on the life-cycle diagram above, first construct an equation for each event \\[n' = n_t + m\\] \\[n'' = n' + bn'\\] \\[n_{t+1} = n'' - dn''\\] Note Note that \\(m\\) and \\(d\\) are now the fraction of individuals that migrate and die, and \\(b\\) is the number of offspring per parent (above these parameters were all rates ). Next, substitute \\(n''\\) and then \\(n'\\) into the equation for \\(n_{t+1}\\) to write \\(n_{t+1}\\) in terms of \\(n_t\\) \\[ \\begin{aligned} n_{t+1} &= n'' \u2212 dn'' \\\\ &= (n' + bn\u2032) \u2212 d(n' + bn\u2032) \\\\ &= n'(1 + b \u2212 d \u2212 db) \\\\ &= (n_t +m)(1+b\u2212d\u2212db) \\\\ \\end{aligned} \\] We now have a recursion equation that correctly takes into account the order of the life cycle (migration, birth, death) and the point at which the census is taken (immediately after death).","title":"iv. Quantitatively describe the biological system"},{"location":"lectures/lecture-02/#v-analyze-the-equations","text":"Start by using the equations to simulate and graph the changes to the system over time. Choose and perform appropriate analyses. Make sure that the analyses can address the problem.","title":"v. Analyze the equations"},{"location":"lectures/lecture-02/#vi-checks-and-balances","text":"Check the results against data or any known special cases. Determine how general the results are. Consider alternatives to the simplest model. Extend or simplify the model, as appropriate, and repeat steps 2-5.","title":"vi. Checks and balances"},{"location":"lectures/lecture-02/#vii-relate-the-results-back-to-the-question","text":"Do the results answer the biological question? Are the results counter-intuitive? Why? Interpret the results verbally, and describe conceptually any new insights into the biological process. Describe potential experiments.","title":"vii. Relate the results back to the question"},{"location":"lectures/lecture-02/#2-evolution-and-the-hardy-weinberg-equilibrium","text":"","title":"2. Evolution and the Hardy-Weinberg equilibrium"},{"location":"lectures/lecture-02/#natural-selection","text":"Natural selection requires three conditions be met ( Lewontin 1970 ): Variation in traits: different individuals have different traits Variation in fitness: different traits have different rates of survival and/or reproduction Fitness is heritable: traits are inherited to some degree Although selection is an important idea, it's impossible to know what kind of observations are consistent with selection if we don't have a baseline to compare against. So let's first construct a model of evolution in the absence of selection using the general steps described in section 1, Constructing a model .","title":"Natural selection"},{"location":"lectures/lecture-02/#evolution-in-the-absence-of-selection","text":"","title":"Evolution in the absence of selection"},{"location":"lectures/lecture-02/#i-formulate-the-question_1","text":"What do you want to know How do allele frequencies change over time in the absence of natural selection? Boil the question down In a diploid population with two variant \"alleles\" of a gene (A and a), how will the frequency of the A allele change over time? Simple, biologically reasonable description We assume that each diploid genotype (AA, Aa, and aa) has equal fitness and that individuals reproduce and then die (non-overlapping generations). We also assume that individuals produce haploid gametes that form a gamete pool. Gametes within the gamete pool unite at random to produce the next generation of diploid individuals.","title":"i. Formulate the question"},{"location":"lectures/lecture-02/#ii-determine-the-basic-ingredients_1","text":"Variables \\(x\\) = frequency of AA individuals \\(y\\) = frequency of Aa individuals \\(z\\) = frequency of aa individuals From this we can extract the allele frequencies the frequency of A is \\(p = x + y/2\\) (ie, all of the alleles in genotype AA ( \\(x\\) ) are A but only 1/2 of the alleles in genotype Aa ( \\(y\\) ) are A) the frequency of a is \\(q = 1 - p = y/2 + z\\) Constraints on these variables \\(x\\) , \\(y\\) , \\(z\\) are \\(\u22650\\) and \\(\u22641\\) \\(x+y+z=1\\) How we'll treat time We will follow the genotype frequencies from one generation to the next, using a discrete-time model Parameters there are no parameters in this model (which is a little bit unusual)","title":"ii. Determine the basic ingredients"},{"location":"lectures/lecture-02/#iii-qualitatively-describe-the-biological-system_1","text":"Gametes unite at random in the gamete pool to produce diploid offspring. These offspring grow into adults that undergo meiosis, creating gametes, and die. Below we draw the life-cycle diagram. graph LR; A((random<br> union)) --diploid--> B((meiosis)); B --haploid--> A;","title":"iii. Qualitatively describe the biological system"},{"location":"lectures/lecture-02/#iv-quantiatively-describe-the-biological-system","text":"To calculate the frequency of each genoytpe in the next generation we use a table of events. The \"Union\" column indicates the pair of gametes that are meeting each other, the \"Frequency\" column indicates the proportion of gamete pairs in the population with this particular union, and the remaining columns indicate which diploid genotype is created by the union. Union Frequency AA Aa aa A x A \\(p^2\\) 1 0 0 A x a \\(pq\\) 0 1 0 a x A \\(qp\\) 0 1 0 a x a \\(q^2\\) 0 0 1 \\(p^2\\) \\(2pq\\) \\(q^2\\) The genotype frequencies denoted in red are known as the Hardy-Weinberg frequencies . Note that this table shows that populations not at \"Hardy-Weinberg equilibrium\" reach Hardy-Weinberg equilibrium after only one generation of random mating. We now have the frequency of genotypes in the next generation in terms of the allele frequencies in the previous generation, \\[x' = p^2\\] \\[y' = 2pq\\] \\[z' = q^2\\] To understand how the genotype frequencies at Hardy-Weinberg vary with allele frequency, we can plot them. from sympy import * var('p') x = p**2 #frequency of AA at Hardy-Weinberg as a function of the frequency of allele A y = 2*p*(1-p) #freq of Aa z = (1-p)**2 #freq of aa p = plot(x, y, z, #functions that we are plotting (p,0,1), #plot as a function of allele frequency from 0 to 1 xlabel=\"allele frequency, $p$\", ylabel=\"genotype frequency\", legend=True, show=False ) p[0].label='AA' #give legend genotype labels p[1].label='Aa' p[2].label='aa' p.show() From this plot we see, for example, that the frequency of heterozygotes, Aa, is maximized at intermediate allele frequencies. Subbing in \\(p=x+y/2\\) and \\(q=y/2+z\\) we get the recursion equations describing the frequency of diploid genotypes in the next generation as a function of the diploid genotypes in the current generation, \\[x' = (x + y/2)^2\\] \\[y' = 2(x + y/2)(y/2 + z)\\] \\[z' = (y/2 + z)^2\\]","title":"iv. Quantiatively describe the biological system"},{"location":"lectures/lecture-02/#v-analyze-the-equations_1","text":"Now back to our question. What is the frequency of allele A in the next generation? \\[p' = x' + y'/2\\] \\[p' = p^2 + 2pq/2\\] \\[p' = p(p + q)\\] \\[p' = p\\]","title":"v. Analyze the equations"},{"location":"lectures/lecture-02/#vi-checks-and-balances_1","text":"Does \\(x' + y' + z' = 1\\) ? \\[ \\begin{aligned} x' + y' + z' &= p^2 + 2pq + q^2\\\\ &= (p+q)^2\\\\ &= (1)^2\\\\ &= 1 \\end{aligned} \\]","title":"vi. Checks and balances"},{"location":"lectures/lecture-02/#vii-relate-the-results-back-to-the-question_1","text":"How do allele frequencies change over time in the absence of natural selection? They don't Data example: blood types Below is a table describing the frequency of three different blood types (and their associated genotype) in a sample of humans from the USA. Blood type M MN N Genotype MM MN NN Observed frequency in USA 0.292 0.496 0.212 We ask, are these genotypes near Hardy-Weinberg equilibrium? First, write the frequency of each genotype as \\(x\\) , \\(y\\) , and \\(z\\) \\[x = 0.292\\] \\[y = 0.496\\] \\[z = 0.212\\] Next, convert the genotype frequencies into allele frequencies \\[p = x + y/2 = 0.540\\] \\[q = y/2 + z = 0.460\\] Now predict what the genotype frequencies would be at Hardy-Weinberg equilibrium \\[x = p^2 = 0.2916\\] \\[y = 2pq = 0.4985\\] \\[z = q^2 = 0.2116\\] These predicted genotype frequencies are exceptionally close to those actually observed, indicating Hardy-Weinberg equilibrium and suggesting an absence of selection on this phenotype.","title":"vii. Relate the results back to the question"},{"location":"lectures/lecture-03/","text":"{ requestKernel: true, mountActivateWidget: true, mountStatusWidget: true, binderOptions: { repo: \"tomouellette/executable-cells\", ref: \"main\", binderUrl: \"https://gke.mybinder.org\", }, } Lecture 3: Exponential & logistic growth Run notes interactively? Lecture overview Introduction Exponential growth Logistic growth 1. Introduction In nature, population sizes change over time in response to a myriad of factors, such as weather competition, predation, disease, ... resource availability The simplest models describing changes in population size are exponential growth and logistic growth which assume a constant environment no interactions with other species The exponential model also assumes no competition among the members of a species for the available resources ( density-independent growth ), while the logistic model includes competition within a species ( density-dependent growth ). Both of these models can be described in discrete and continuous time. We\u2019ll start with the simpler exponential model. 2. Exponential growth Exponential growth in discrete time Imagine we start with \\(n_t\\) individuals at some time \\(t\\) . If we assume that each of these individuals produces \\(b\\) offspring, the number of individuals after reproduction is \\(n_t + n_t b = n_t(1 + b)\\) . If we then assume a fraction \\(d\\) die, the number of individuals remaining after death is \\(n_t(1+b) - n_t(1+b)d = n_t(1+b)(1-d)\\) . With no further events in the life-cycle, this is the expected number of individuals in the next generation, \\(n_{t+1}\\) , which we can write as \\[ \\begin{aligned} n_{t+1} &= n_t(1+b)(1-d) \\\\ &= n_t R \\\\ \\end{aligned} \\] where \\(R=(1+b)(1-d)\\) is a constant referred to as the reproductive factor . This equation, \\(n_{t+1}=n_t R\\) , is the recursion equation for exponential growth. Exponential vs geometric growth Technically this recursion equation describes \"geometric\" growth, since \\(n_t\\) will grow with \\(t\\) as a geometric series, but here we simply call it \"exponential growth in discrete time\" to make a clear connection with exponential growth in continuous time. We can also describe the change in the number of individuals by subtracting off the current number, \\[ \\begin{aligned} \\Delta n &= n_{t+1} - n_t\\\\ &= n_t(R-1) \\end{aligned} \\] This is the difference equation for exponential growth, with discrete-time growth rate \\(r_d = R-1 = (1+b)(1-d)-1 = b - d - bd\\) . Let's plot the dynamics described by these equations for a particular set of parameter values. import numpy as np import matplotlib.pyplot as plt def exponential_discrete(nt, b, d): '''recursion equation giving population size in next time step as a function of the population size at this time, nt, and the birth and death rates, b and d.''' return nt * (1 + b) * (1 - d) # Grow population nd, nt, b, d = [], 1, 0.2, 0.1 #define empty list nd to store population sizes and choose parameter values for t in np.arange(0,100): #for time from 0 to 99 nt = exponential_discrete(nt, b, d) #get the next population size from the recursion equation nd.append(nt) #and append it to the list # Plot growth fig, ax = plt.subplots() ax.scatter(np.arange(0, 100), nd) #plot population size at each time ax.set_xlabel('Time, $t$') ax.set_ylabel('Population size, $n_t$') plt.show() Exponential growth in continuous time Now assume that each individual continuously gives birth at rate \\(b\\) and dies at rate \\(d\\) . If there are \\(n_t\\) individuals in the population at time \\(t\\) , then the rate of change in the number of individuals is \\[ \\begin{aligned} \\frac{\\mathrm{d} n_t}{\\mathrm{d} t} &= n_t b - n_t d\\\\ &= n_t (b - d)\\\\ &= n_t r_c \\end{aligned} \\] This is the differential equation for exponential growth with continuous-time growth rate \\(r_c = b - d\\) . Note that the growth rate in the discrete-time model was \\(r_d = b - d - b d\\) . The difference between the two growth rates reflects the fact that birth and death cannot happen at the exact same time in the continuous-time model (so there is no \\(b d\\) term), while offspring that are born can die before the next generation in the discrete-time model (causing the \\(b d\\) term). Let's also plot these dynamics. Approximating a differential equation The differential equation describes the change in the population size in an \"infinitesimally\" small amount of time, \\(\\mathrm{d}t\\) . To plot these dynamics we therefore make an approximation, taking \\(\\mathrm{d}t\\) to be small, but not infinitely so. Rearranging the differential equation gives \\(\\mathrm{d}n_t = n_t(b-d)\\mathrm{d}t\\) and the population size after \\(\\mathrm{d}t\\) is therefore \\(n_{t+\\mathrm{d}t} = n_t + \\mathrm{d}n_t\\) . This is a recursion equation that approximates our differential equation. import numpy as np import matplotlib.pyplot as plt def exponential_continuous(nt, b, d, dt): '''approximation of the differential equation giving population size after a small time interval, dt, as a function of the population size at this time, nt, and the birth and death rates, b and d.''' return nt + nt * (b - d) * dt # Grow population nc, nt, dt = [], 1, 0.1 #define empty list nc to store population sizes and choose parameter values (keep b and d as above) for t in np.arange(0,100,dt): #for time from 0 to 99 by increments of dt nt = exponential_continuous(nt, b, d, dt) #get the next population size from the recursion equation nc.append(nt) #and append it to the list # Plot growth fig, ax = plt.subplots() ax.scatter(np.arange(0, 100, dt), nc) #plot population size at each time ax.set_xlabel('Time, $t$') ax.set_ylabel('Population size, $n_t$') plt.show() We can now combine our two plots to compare these two predictions, exponential growth in discrete vs. continuous time. # Plot growth fig, ax = plt.subplots() ax.scatter(np.arange(0, 100), nd, label='discrete time') #plot population size at each time ax.scatter(np.arange(0, 100, dt), nc, label='continuous time') #plot population size at each time ax.set_xlabel('Time, $t$') ax.set_ylabel('Population size, $n_t$') plt.legend() plt.show() Why the difference? The predictions are very similar at first but then noticeably diverge. The time of this divergence depends on the values of parameters \\(b\\) and \\(d\\) . Try increasing or decreasing both \\(b\\) and \\(d\\) and think about why it has that effect. Also think about why the continuous time model predicts a larger population size than the discrete time model. Hint: remember the difference in the growth rates between the two models is \\(bd\\) . The trouble with exponential growth Exponential growth cannot continue indefinitely. Take for example a population of pheasants on an island off the coast of Washington State. Just 8 pheasants were introduced in 1937, but the population then grew exponentially, tripling in size every year ( \\(R=3\\) ) for the first 5 years. Had this population continued to grow exponentially there would have been 7 million of them by the year 1950 and \\(10^{28}\\) by now \u2013 which at 2 kg per pheasant is 3000 times the mass of the earth!! In fact, Lack observed that \u201cthe figures suggest that the increase was slowing down and was about to cease, but at this point the island was occupied by the military and many of the birds shot.\u201d Although populations may initially experience exponential growth, resources eventually become depleted and competition becomes more severe. This suggests that we should change our model assumptions. 3. Logistic growth Exponential growth assumes the growth rate ( \\(r_d\\) , \\(r_c\\) ) is constant. Logistic growth relaxes this assumption, and instead assumes that the growth rate decreases linearly with population size, due to competition for resources within the population. Logistic growth in discrete time In discrete-time, the reproductive factor under logistic growth can be written as \\[R(n_t) = 1 + r\\left(1 - \\frac{n_t}{K}\\right)\\] Notice that each individual is expected to have one offspring ( \\(R=1\\) ) if the intrinsic growth rate (ie, growth rate when rare) is zero, \\(r = 0\\) , or if the population size is at carrying capacity , \\(n_t=K\\) . Try plotting the reproductive factor as a function of \\(n_t\\) for a few different values of \\(r\\) and \\(K\\) . # Reproductive factor for logistic growth def logistic_discrete(nt, r, K): '''reproductive factor in discrete logistic model with growth rate r and carrying capacity k''' return 1 + r * (1 - nt/K) # Compare a few different growth rates and carrying capacities fig, ax = plt.subplots() for r, K in zip([1, 2, 1], [100, 100, 50]): #for each pair of r and K values nt = np.linspace(0, 200) #for a range of population sizes from 0 to 200 R = logistic_discrete(nt, r, K) #calculate the reproductive factor ax.plot(nt, R, label=f\"r = {r}, K = {K}\") #and plot ax.plot(nt, [1 for i in nt], '--', color='gray') #1 line for reference ax.set_xlabel('Population size, $n_t$') ax.set_ylabel('Reproductive factor, $R$') ax.legend(frameon=False) plt.ylim(0,None) plt.show() The population size in the next generation is the expected number of offspring per parent times the the total number of parents \\[n_{t+1} = \\left(1 + r\\left(1-\\frac{n_t}{K}\\right)\\right)n_t\\] This is the recursion equation for logistic growth. This recursion is a non-linear function of \\(n_t\\) ( non-linear means that there is a term in the equation where the term is taken to some power other than 1; here if we expand out the recursion we get a \\(n_t^2\\) term ). This reflects the fact that logistic growth models an interaction between individuals (competition). The change in population size from one generation to the next, \\(\\Delta n\\) , is therefore \\[\\Delta n = n_{t+1} - n_t = r\\left(1 - \\frac{n_t}{K}\\right)n_t\\] Based on this difference equation, when will the population grow in size? Test out your answer by plotting population size over time in the discrete-time logistic model. Try changing the initial population size or carrying capacity so that \\(n_t > K\\) . # Initialize parameters n, nt, r, K = [], 1, 0.1, 100 #list, initial population size, intrinsic growth rate, carrying capacity # Grow population under logistic growth for t in np.arange(0, 100): nt = nt * logistic_discrete(nt, r, K) n.append(nt) # Plot growth fig, ax = plt.subplots() ax.scatter(np.arange(0, 100), n) ax.axhline(100, label=f\"K = {K}\", linestyle='dashed', color='gray') #carrying capacity as dashed line # Add annotations ax.set_xlabel('Time, $t$') ax.set_ylabel('Population size, $n_t$') plt.show() Logistic growth in continuous time The model of logistic growth in continuous time, as with discrete time, follows from the assumption that each individual has a growth rate that decreases as a linear function of the population size \\(r(1 - n_t/K)\\) . If there are \\(n_t\\) individuals in the population at time \\(t\\) , then the rate of change of the population size will be \\[\\frac{\\mathrm{d}n_t}{\\mathrm{d}t} = r\\left(1 - \\frac{n_t}{K}\\right)n_t\\] This is a differential equation of logistic growth. Note that in both discrete and continuous time the logistic growth model reduces to the exponential growth model as \\(n_t/K\\) approaches 0, i.e., when the population size is much smaller than the carrying capacity \\(n_t << K\\) . An example of logistic growth Dr. Sarah Otto cultured haploid (one copy of each chromosome) and diploid (two copies of each chromosome) populations of Saccharomyces cereviseae . She observed the following population sizes for the two types of cells: Figure. The size of haploid and diploid yeast populations in a controlled laboratory experiment. Although the populations grow nearly exponentially at first, growth decreased as population size increased (i.e., density-dependent growth was observed). The carrying capacity ( \\(K\\) ) is clearly larger for the haploid cells, but do haploid and diploid cells have different intrinsic growth rates ( \\(r\\) )? By fitting the logistic growth model described above to the data, Dr. Otto estimated the parameter values to be Haploid: r = 0.55, K = 3.7 x 10^8 Diploid: r = 0.55, K = 2.3 x 10^8 The growth rates therefore do not differ (visibly or statistically). With these parameter estimates, the logistic model nicely fits the data: Figure. Population size of haploid and diploid yeast fit with logistic growth models. Note: This may be a bit misleading, as such excellent model fits are rarely observed, especially outside the lab! To do: make the above plots in Python","title":"Lecture 3"},{"location":"lectures/lecture-03/#lecture-3-exponential-logistic-growth","text":"Run notes interactively?","title":"Lecture 3: Exponential &amp; logistic growth"},{"location":"lectures/lecture-03/#lecture-overview","text":"Introduction Exponential growth Logistic growth","title":"Lecture overview"},{"location":"lectures/lecture-03/#1-introduction","text":"In nature, population sizes change over time in response to a myriad of factors, such as weather competition, predation, disease, ... resource availability The simplest models describing changes in population size are exponential growth and logistic growth which assume a constant environment no interactions with other species The exponential model also assumes no competition among the members of a species for the available resources ( density-independent growth ), while the logistic model includes competition within a species ( density-dependent growth ). Both of these models can be described in discrete and continuous time. We\u2019ll start with the simpler exponential model.","title":"1. Introduction"},{"location":"lectures/lecture-03/#2-exponential-growth","text":"","title":"2. Exponential growth"},{"location":"lectures/lecture-03/#exponential-growth-in-discrete-time","text":"Imagine we start with \\(n_t\\) individuals at some time \\(t\\) . If we assume that each of these individuals produces \\(b\\) offspring, the number of individuals after reproduction is \\(n_t + n_t b = n_t(1 + b)\\) . If we then assume a fraction \\(d\\) die, the number of individuals remaining after death is \\(n_t(1+b) - n_t(1+b)d = n_t(1+b)(1-d)\\) . With no further events in the life-cycle, this is the expected number of individuals in the next generation, \\(n_{t+1}\\) , which we can write as \\[ \\begin{aligned} n_{t+1} &= n_t(1+b)(1-d) \\\\ &= n_t R \\\\ \\end{aligned} \\] where \\(R=(1+b)(1-d)\\) is a constant referred to as the reproductive factor . This equation, \\(n_{t+1}=n_t R\\) , is the recursion equation for exponential growth. Exponential vs geometric growth Technically this recursion equation describes \"geometric\" growth, since \\(n_t\\) will grow with \\(t\\) as a geometric series, but here we simply call it \"exponential growth in discrete time\" to make a clear connection with exponential growth in continuous time. We can also describe the change in the number of individuals by subtracting off the current number, \\[ \\begin{aligned} \\Delta n &= n_{t+1} - n_t\\\\ &= n_t(R-1) \\end{aligned} \\] This is the difference equation for exponential growth, with discrete-time growth rate \\(r_d = R-1 = (1+b)(1-d)-1 = b - d - bd\\) . Let's plot the dynamics described by these equations for a particular set of parameter values. import numpy as np import matplotlib.pyplot as plt def exponential_discrete(nt, b, d): '''recursion equation giving population size in next time step as a function of the population size at this time, nt, and the birth and death rates, b and d.''' return nt * (1 + b) * (1 - d) # Grow population nd, nt, b, d = [], 1, 0.2, 0.1 #define empty list nd to store population sizes and choose parameter values for t in np.arange(0,100): #for time from 0 to 99 nt = exponential_discrete(nt, b, d) #get the next population size from the recursion equation nd.append(nt) #and append it to the list # Plot growth fig, ax = plt.subplots() ax.scatter(np.arange(0, 100), nd) #plot population size at each time ax.set_xlabel('Time, $t$') ax.set_ylabel('Population size, $n_t$') plt.show()","title":"Exponential growth in discrete time"},{"location":"lectures/lecture-03/#exponential-growth-in-continuous-time","text":"Now assume that each individual continuously gives birth at rate \\(b\\) and dies at rate \\(d\\) . If there are \\(n_t\\) individuals in the population at time \\(t\\) , then the rate of change in the number of individuals is \\[ \\begin{aligned} \\frac{\\mathrm{d} n_t}{\\mathrm{d} t} &= n_t b - n_t d\\\\ &= n_t (b - d)\\\\ &= n_t r_c \\end{aligned} \\] This is the differential equation for exponential growth with continuous-time growth rate \\(r_c = b - d\\) . Note that the growth rate in the discrete-time model was \\(r_d = b - d - b d\\) . The difference between the two growth rates reflects the fact that birth and death cannot happen at the exact same time in the continuous-time model (so there is no \\(b d\\) term), while offspring that are born can die before the next generation in the discrete-time model (causing the \\(b d\\) term). Let's also plot these dynamics. Approximating a differential equation The differential equation describes the change in the population size in an \"infinitesimally\" small amount of time, \\(\\mathrm{d}t\\) . To plot these dynamics we therefore make an approximation, taking \\(\\mathrm{d}t\\) to be small, but not infinitely so. Rearranging the differential equation gives \\(\\mathrm{d}n_t = n_t(b-d)\\mathrm{d}t\\) and the population size after \\(\\mathrm{d}t\\) is therefore \\(n_{t+\\mathrm{d}t} = n_t + \\mathrm{d}n_t\\) . This is a recursion equation that approximates our differential equation. import numpy as np import matplotlib.pyplot as plt def exponential_continuous(nt, b, d, dt): '''approximation of the differential equation giving population size after a small time interval, dt, as a function of the population size at this time, nt, and the birth and death rates, b and d.''' return nt + nt * (b - d) * dt # Grow population nc, nt, dt = [], 1, 0.1 #define empty list nc to store population sizes and choose parameter values (keep b and d as above) for t in np.arange(0,100,dt): #for time from 0 to 99 by increments of dt nt = exponential_continuous(nt, b, d, dt) #get the next population size from the recursion equation nc.append(nt) #and append it to the list # Plot growth fig, ax = plt.subplots() ax.scatter(np.arange(0, 100, dt), nc) #plot population size at each time ax.set_xlabel('Time, $t$') ax.set_ylabel('Population size, $n_t$') plt.show() We can now combine our two plots to compare these two predictions, exponential growth in discrete vs. continuous time. # Plot growth fig, ax = plt.subplots() ax.scatter(np.arange(0, 100), nd, label='discrete time') #plot population size at each time ax.scatter(np.arange(0, 100, dt), nc, label='continuous time') #plot population size at each time ax.set_xlabel('Time, $t$') ax.set_ylabel('Population size, $n_t$') plt.legend() plt.show() Why the difference? The predictions are very similar at first but then noticeably diverge. The time of this divergence depends on the values of parameters \\(b\\) and \\(d\\) . Try increasing or decreasing both \\(b\\) and \\(d\\) and think about why it has that effect. Also think about why the continuous time model predicts a larger population size than the discrete time model. Hint: remember the difference in the growth rates between the two models is \\(bd\\) .","title":"Exponential growth in continuous time"},{"location":"lectures/lecture-03/#the-trouble-with-exponential-growth","text":"Exponential growth cannot continue indefinitely. Take for example a population of pheasants on an island off the coast of Washington State. Just 8 pheasants were introduced in 1937, but the population then grew exponentially, tripling in size every year ( \\(R=3\\) ) for the first 5 years. Had this population continued to grow exponentially there would have been 7 million of them by the year 1950 and \\(10^{28}\\) by now \u2013 which at 2 kg per pheasant is 3000 times the mass of the earth!! In fact, Lack observed that \u201cthe figures suggest that the increase was slowing down and was about to cease, but at this point the island was occupied by the military and many of the birds shot.\u201d Although populations may initially experience exponential growth, resources eventually become depleted and competition becomes more severe. This suggests that we should change our model assumptions.","title":"The trouble with exponential growth"},{"location":"lectures/lecture-03/#3-logistic-growth","text":"Exponential growth assumes the growth rate ( \\(r_d\\) , \\(r_c\\) ) is constant. Logistic growth relaxes this assumption, and instead assumes that the growth rate decreases linearly with population size, due to competition for resources within the population.","title":"3. Logistic growth"},{"location":"lectures/lecture-03/#logistic-growth-in-discrete-time","text":"In discrete-time, the reproductive factor under logistic growth can be written as \\[R(n_t) = 1 + r\\left(1 - \\frac{n_t}{K}\\right)\\] Notice that each individual is expected to have one offspring ( \\(R=1\\) ) if the intrinsic growth rate (ie, growth rate when rare) is zero, \\(r = 0\\) , or if the population size is at carrying capacity , \\(n_t=K\\) . Try plotting the reproductive factor as a function of \\(n_t\\) for a few different values of \\(r\\) and \\(K\\) . # Reproductive factor for logistic growth def logistic_discrete(nt, r, K): '''reproductive factor in discrete logistic model with growth rate r and carrying capacity k''' return 1 + r * (1 - nt/K) # Compare a few different growth rates and carrying capacities fig, ax = plt.subplots() for r, K in zip([1, 2, 1], [100, 100, 50]): #for each pair of r and K values nt = np.linspace(0, 200) #for a range of population sizes from 0 to 200 R = logistic_discrete(nt, r, K) #calculate the reproductive factor ax.plot(nt, R, label=f\"r = {r}, K = {K}\") #and plot ax.plot(nt, [1 for i in nt], '--', color='gray') #1 line for reference ax.set_xlabel('Population size, $n_t$') ax.set_ylabel('Reproductive factor, $R$') ax.legend(frameon=False) plt.ylim(0,None) plt.show() The population size in the next generation is the expected number of offspring per parent times the the total number of parents \\[n_{t+1} = \\left(1 + r\\left(1-\\frac{n_t}{K}\\right)\\right)n_t\\] This is the recursion equation for logistic growth. This recursion is a non-linear function of \\(n_t\\) ( non-linear means that there is a term in the equation where the term is taken to some power other than 1; here if we expand out the recursion we get a \\(n_t^2\\) term ). This reflects the fact that logistic growth models an interaction between individuals (competition). The change in population size from one generation to the next, \\(\\Delta n\\) , is therefore \\[\\Delta n = n_{t+1} - n_t = r\\left(1 - \\frac{n_t}{K}\\right)n_t\\] Based on this difference equation, when will the population grow in size? Test out your answer by plotting population size over time in the discrete-time logistic model. Try changing the initial population size or carrying capacity so that \\(n_t > K\\) . # Initialize parameters n, nt, r, K = [], 1, 0.1, 100 #list, initial population size, intrinsic growth rate, carrying capacity # Grow population under logistic growth for t in np.arange(0, 100): nt = nt * logistic_discrete(nt, r, K) n.append(nt) # Plot growth fig, ax = plt.subplots() ax.scatter(np.arange(0, 100), n) ax.axhline(100, label=f\"K = {K}\", linestyle='dashed', color='gray') #carrying capacity as dashed line # Add annotations ax.set_xlabel('Time, $t$') ax.set_ylabel('Population size, $n_t$') plt.show()","title":"Logistic growth in discrete time"},{"location":"lectures/lecture-03/#logistic-growth-in-continuous-time","text":"The model of logistic growth in continuous time, as with discrete time, follows from the assumption that each individual has a growth rate that decreases as a linear function of the population size \\(r(1 - n_t/K)\\) . If there are \\(n_t\\) individuals in the population at time \\(t\\) , then the rate of change of the population size will be \\[\\frac{\\mathrm{d}n_t}{\\mathrm{d}t} = r\\left(1 - \\frac{n_t}{K}\\right)n_t\\] This is a differential equation of logistic growth. Note that in both discrete and continuous time the logistic growth model reduces to the exponential growth model as \\(n_t/K\\) approaches 0, i.e., when the population size is much smaller than the carrying capacity \\(n_t << K\\) . An example of logistic growth Dr. Sarah Otto cultured haploid (one copy of each chromosome) and diploid (two copies of each chromosome) populations of Saccharomyces cereviseae . She observed the following population sizes for the two types of cells: Figure. The size of haploid and diploid yeast populations in a controlled laboratory experiment. Although the populations grow nearly exponentially at first, growth decreased as population size increased (i.e., density-dependent growth was observed). The carrying capacity ( \\(K\\) ) is clearly larger for the haploid cells, but do haploid and diploid cells have different intrinsic growth rates ( \\(r\\) )? By fitting the logistic growth model described above to the data, Dr. Otto estimated the parameter values to be Haploid: r = 0.55, K = 3.7 x 10^8 Diploid: r = 0.55, K = 2.3 x 10^8 The growth rates therefore do not differ (visibly or statistically). With these parameter estimates, the logistic model nicely fits the data: Figure. Population size of haploid and diploid yeast fit with logistic growth models. Note: This may be a bit misleading, as such excellent model fits are rarely observed, especially outside the lab! To do: make the above plots in Python","title":"Logistic growth in continuous time"},{"location":"lectures/lecture-04/","text":"{ requestKernel: true, mountActivateWidget: true, mountStatusWidget: true, binderOptions: { repo: \"tomouellette/executable-cells\", ref: \"main\", binderUrl: \"https://gke.mybinder.org\", }, } Lecture 4: One-locus selection Run notes interactively? Lecture overview Review of Hardy-Weinberg One-locus haploid selection in discrete time One-locus diploid selection in discrete time Comparing haploid and diploid selection One-locus haploid selection in continuous time Comparing haploid selection in discrete and continuous time The models we've covered 1. Review of Hardy-Weinberg In Lecture 2 we saw that in the absence of selection, one round of random union among gametes (equivalently, random mating among diploids) causes the frequency of diploid genotypes at a locus with two alleles, \\(A\\) and \\(a\\) , to become \\(AA\\) : \\(p^2\\) \\(Aa\\) : \\(2pq\\) \\(aa\\) : \\(q^2\\) where \\(p\\) is the frequency of allele \\(A\\) and \\(q=1-p\\) is the frequency of allele \\(a\\) . A population with these diploid genotype frequencies is said to be in Hardy-Weinberg equilibrium. Furthermore, we showed that under this model the allele frequencies do not change, \\(p' = p\\) . But what if there is selection? 2. One-locus haploid selection in discrete time We begin by examining a model where selection acts during the haploid phase of the life-cycle. This is a little simpler than diploid selection because there are only two haploid genotypes, \\(A\\) and \\(a\\) . It is also a very relevant model for species with long haploid phases (eg, some algae and fungi) or with strong competition during the haploid phase (eg, pollen competiting for ovules). Life-cycle diagram We first illustrate the structure of the model with a life-cycle diagram. graph LR; A((random<br> union)) --diploid--> B((meiosis)); B --haploid--> C((selection)); C --haploid--> A; Figure. Life-cycle diagram of haploid selection We will census the population at the beginning of the haploid phase (immediately after meiosis). Deriving the equations Let the number of haploid individuals with each allele be \\(n_A(t) =\\) number of individuals with the \\(A\\) allele in generation \\(t\\) \\(n_a(t) =\\) number of individuals with the \\(a\\) allele in generation \\(t\\) The frequency of \\(A\\) is therefore \\(p_t = \\frac{n_a(t)}{n_A(t) + n_a(t)}\\) . Now, let\u2019s assume that during selection each haploid individual has reproductive factor \\(W_A =\\) reproductive factor of individuals with the \\(A\\) allele \\(W_a =\\) reproductive factor of individuals with the \\(a\\) allele These reproductive factors are referred to as the absolute fitnesses as they determine the (absolute) numbers of individuals after selection, \\(n_i' = W_i n_i(t)\\) for \\(i=A\\) and \\(i=a\\) . To relate back to the models of population growth in Lecture 3, this is exponential growth of each allele. After selection these alleles randomly pair, go through the dipliod phase of the life cycle, and then segregate back into haploids after meiosis. We assume this does not change the numbers of each allele (or at least the relative numbers, eg, all diploid individuals could produce X gametes). The frequency of \\(A\\) in the next generation is therefore \\[ \\begin{aligned} p_{t+1} &= \\frac{n_A(t+1)}{n_A(t+1) + v_a n_a(t)} \\\\ &= \\frac{W_A n_A(t)}{W_A n_A(t) + W_a n_a(t)}. \\end{aligned} \\] To make this a recursion equation we need to write \\(p_{t+1}\\) in terms of \\(p_t\\) , so that if we knew \\(p\\) at some point in time we can recursively calculate it in all future times. To do this we divide both the numerator and denominator by the total number of individuals, \\(n_A(t) + n_a(t)\\) , and simplify \\[ \\begin{aligned} p_{t+1} &= \\frac{W_A n_A(t)}{W_A n_A(t) + W_a n_a(t)} \\\\ &= \\frac{W_A\\frac{n_A(t)}{n_A(t) + n_a(t)}}{W_A\\frac{n_A(t)}{n_A(t) + n_a(t)} + W_a\\frac{n_a(t)}{n_A(t) + n_a(t)}}\\\\ &= \\frac{W_A p_t}{W_A p_t + W_a q_t}. \\end{aligned} \\] This is now a recursion equation for the allele frequency in our model of haploid selection. Simplifying Our current recursion is a function of two parameters, the absolute fitnesses \\(W_A\\) and \\(W_a\\) . Now notice that if we divide both the numerator and denominator by one of these fitnesses, say \\(W_a\\) , then we can reduce the recursion to a function of only one parameter, \\(w_A = W_A/W_a\\) , the fitness of \\(A\\) relative to the fitness of \\(a\\) , \\[ \\begin{aligned} p_{t+1} &= \\frac{(W_A/W_a)p_t}{(W_A/W_a)p_t + (W_a/W_a)q_t}\\\\ &= \\frac{w_A p_t}{w_A p_t + q_t}. \\end{aligned} \\] Note that the allele frequency dynamics depend only on the relative fitnesses , and not on the absolute fitnesses, meaning that evolution does not depend on how the size of the population changes. It is therefore possible to study evolution while ignoring population dynamics under this simple model. Let's plot the recursion to get a sense of the dynamics. import matplotlib.pyplot as plt # calculate allele frequency over time with recursion w_A = 1.1 #relative fitness of allele A p_now = 0.01 #initial allele frequency, p_0 ps = [] #list to hold allele frequencies over time ts = range(100) #list of time steps for t in ts: #for each time ps.append(p_now) #add current allele frequency to list p_now = w_A*p_now/(w_A*p_now+(1-p_now)) #update allele frequency with our recursion equation # plot plt.scatter(ts, ps) #plot the (t,p) pairs plt.xlabel(\"generation, $t$\") #label axes plt.ylabel(\"frequency of $A$ allele, $p_t$\") plt.show() 3. One-locus diploid selection in discrete time Since we are all currently in the diploid phase of our life-cycle, it is natural to ask: Does selection in the diploid phase work the same way? Life-cycle diagram We now have the following life-cycle diagram. graph LR; A((random<br> union)) --diploid--> B((selection)); B --diploid--> C((meiosis)); C --haploid--> A; Figure. Life-cycle diagram of diploid selection We will census at the beginning of the diploid phase (immediately after gamete union). Deriving the equations Let the number of diploid individuals with each genotype be \\(n_{AA}(t) =\\) number of individuals with the \\(AA\\) genotype in generation \\(t\\) \\(n_{Aa}(t) =\\) number of individuals with the \\(Aa\\) genotype in generation \\(t\\) \\(n_{aa}(t) =\\) number of individuals wite the \\(aa\\) genotype in generation \\(t\\) The frequency of allele \\(A\\) is then \\[ \\begin{aligned} p_t &= \\frac{2n_{AA}(t) + n_{Aa}(t)}{2n_{AA}(t) + n_{Aa}(t) + n_{aa}(t)} \\\\ &= \\frac{n_{AA}(t) + \\frac{1}{2}n_{Aa}(t)}{n_{AA}(t) + n_{Aa}(t) + n_{aa}(t)} \\end{aligned} \\] Now, let\u2019s assume that during selection each diploid individual has reproductive factor \\(W_{AA} =\\) reproductive factor of individuals with the \\(AA\\) genotype \\(W_{Aa} =\\) reproductive factor of individuals with the \\(Aa\\) genotype \\(W_{aa} =\\) reproductive factor of individuals with the \\(aa\\) genotype These reproductive factors are again referred to as the absolute fitnesses as they determine the (absolute) numbers of individuals after selection, \\(n_i' = W_i n_i(t)\\) for \\(i=AA\\) , \\(i=Aa\\) , and \\(i=aa\\) . After selection these genotypes segregate into haploids via meiosis, go through the haploid phase of the life cycle, and then random join to create diploids again. We assume this does not change the numbers of each genotype (or at least the relative numbers, eg, all diploid individuals could produce X gametes). The frequency of \\(A\\) in the next generation is therefore \\[ \\begin{aligned} p_{t+1} &= \\frac{n_{AA}(t+1) + \\frac{1}{2}n_{Aa}(t+1)}{n_{AA}(t+1) + n_{Aa}(t+1) + n_{aa}(t+1)}\\\\ &= \\frac{W_{AA}n_{AA}(t) + \\frac{1}{2}W_{Aa}n_{Aa}(t)}{W_{AA}n_{AA}(t) + \\frac{1}{2}W_{Aa}n_{Aa}(t) + W_{aa}n_{aa}(t)}. \\end{aligned} \\] As above, we want a recursion equation in terms of allele frequency, so we want to replace the \\(n_i\\) 's in the right hand side of this equation with \\(p\\) 's. To do this we note that with the random union of gametes the diploid offspring are in Hardy-Weinberg proportions, so that \\[ \\begin{aligned} n_{AA}(t) &= p_t^2 n(t) \\\\ n_{Aa}(t) &= 2p_t q_t n(t) \\\\ n_{aa}(t) &= q_t^2 n(t) \\end{aligned} \\] where \\(n(t) = n_{AA}(t) + n_{Aa}(t) + n_{aa}(t)\\) is the total population size. Substituting these Hardy-Weinberg proportions in and simplifying, the total population size cancels out and we can rewrite the above equation in terms of allele frequency alone, \\[ \\begin{aligned} p_{t+1} &= \\frac{W_{AA}p_t^2 n(t) + W_{Aa}p_t q_t n(t)}{W_{AA}p_t^2 n(t) + 2W_{Aa}p_t q_t n(t) + W_{aa}q_t^2 n(t)}\\\\ &= \\frac{W_{AA}p_t^2 + W_{Aa}p_t q_t}{W_{AA}p_t^2 + 2W_{Aa}p_t q_t + W_{aa}q_t^2}. \\end{aligned} \\] This is a recursion equation for allele frequency in our model of diploid selection. Simplifying As in the haploid selection case, we can divide by one of the absolute fitnesses, say \\(W_{aa}\\) , to remove one parameter from the model \\[ \\begin{aligned} p_{t+1} &= \\frac{(W_{AA}/W_{aa})p_t^2 + (W_{Aa}/W_{aa})p_t q_t}{(W_{AA}/W_{aa})p_t^2 + 2(W_{Aa}/W_{aa})p_t q_t + (W_{aa}/W_{aa})q_t^2} \\\\ &= \\frac{w_{AA}p_t^2 + w_{Aa}p_t q_t}{w_{AA}p_t^2 + 2w_{Aa}p_t q_t + q_t^2} \\end{aligned} \\] This recursion is a function of only two relative fitnesses, \\(w_{AA} = W_{AA}/W_{aa}\\) and \\(w_{Aa} = W_{Aa}/W_{aa}\\) . Let's plot the recursion to get a sense of the dynamics. import matplotlib.pyplot as plt # calculate allele frequency over time with recursion w_AA = 1.2 #relative fitness of genotype AA w_Aa = 1.1 #relative fitness of genotype Aa p_now = 0.01 #initial allele frequency, p_0 ps = [] #list to hold allele frequencies over time ts = range(100) #list of time steps for t in ts: #for each time ps.append(p_now) #add current allele frequency to list p_now = (w_AA*p_now**2 + w_Aa*p_now*(1-p_now))/(w_AA*p_now**2 + 2*w_Aa*p_now*(1-p_now) + (1-p_now)**2) #update allele frequency with our recursion equation # plot plt.scatter(ts, ps) plt.xlabel(\"generation, $t$\") plt.ylabel(\"frequency of $A$ allele, $p_t$\") plt.show() 4. Comparing haploid and diploid selection So, returning to our original question, let's compare evolution under haploid selection \\[ p_{t+1} = \\frac{W_A p_t}{W_A p_t + W_a q_t} \\] to evolution under diploid selection \\[ p_{t+1} = \\frac{W_{AA}p_t^2 + W_{Aa}p_t q_t}{W_{AA}p_t^2 + 2W_{Aa}p_t q_t + W_{aa}q_t^2}. \\] To facilitate this, let\u2019s assume the fitness of a diploid genotype is the product of the haploid fitnesses, i.e., \\(W_{AA} = W_A W_A\\) , \\(W_{Aa} = W_A W_a\\) , and \\(W_{aa} = W_a W_a\\) . It then happens that our diploid recursion reduces to the haploid recursion, \\[ \\begin{aligned} p_{t+1} &= \\frac{W_A W_A p_t^2 + W_A W_a p_t q_t}{W_A W_A p_t^2 + 2W_A W_a p_t q_t + W_a W_a q_t^2}\\\\ &= \\frac{W_A p_t(p_t + W_a q_t)}{W_A p_t(W_A p_t + W_a q_t) + W_a q_t(W_A p_t + W_a q_t)}\\\\ &= \\frac{W_A p_t}{W_A p_t + W_a q_t} \\end{aligned} \\] This shows that we need twice as much selection under diploid selection relative to that under haploid selection (e.g., \\(W_{AA} = W_A W_A\\) ) for evolution to proceed as quickly. Why is evolution slower under diploid selection? Let's check this visually (try breaking the assumption above, \\(W_{ij}=W_i W_j\\) , to see what happens). import matplotlib.pyplot as plt # calculate allele frequency over time with recursion w_A = 1.1 #relative fitness of allele A in the haploid model w_AA = w_A*w_A #relative fitness of genotype AA in the diploid model w_Aa = w_A #relative fitness of genotype Aa in the diploid model p_now_hap = 0.01 #initial allele frequency, p_0 p_now_dip = p_now_hap ps_hap, ps_dip = [], [] #lists to hold allele frequencies over time ts = range(100) #list of time steps for t in ts: #for each time ps_hap.append(p_now_hap) #add current allele frequency to list p_now_hap = w_A*p_now_hap/(w_A*p_now_hap+(1-p_now_hap)) #update allele frequency with haploid recursion equation ps_dip.append(p_now_dip) #add current allele frequency to list p_now_dip = (w_AA*p_now_dip**2 + w_Aa*p_now_dip*(1-p_now_dip))/(w_AA*p_now_dip**2 + 2*w_Aa*p_now_dip*(1-p_now_dip) + (1-p_now_dip)**2) #update allele frequency with diploid recursion equation # plot plt.scatter(ts, ps_hap, label='haploid') plt.scatter(ts, ps_dip, label='diploid') plt.xlabel(\"generation, $t$\") plt.ylabel(\"frequency of $A$ allele, $p_t$\") plt.legend() #add legend to know which points belong to which model plt.show() 5. One-locus haploid selection in continuous time To model haploid selection in continuous-time we assume that during the selective phase each haploid individual has growth rate \\(r_A =\\) growth rate of individuals with the \\(A\\) allele \\(r_a =\\) growth rate of individuals with the \\(a\\) allele and the relative numbers of each type don't change otherwise (ie, during union, diploidy, or meiosis). We therefore have exponential growth of both genotypes, \\(\\frac{\\mathrm{d} n_i}{dt} = r_i n_i\\) . At any particular point in time, \\(t\\) , the frequency of allele \\(A\\) is, \\(p_t = n_A(t)/(n_A(t) + n_a(t))\\) . We can therefore derive the rate of change in the frequency of allele \\(A\\) , \\(\\mathrm{d}p/\\mathrm{d}t\\) , using the qoutient rule (see Appendix 2 in the text for help with this and other math tricks) \\[ \\begin{aligned} \\frac{\\mathrm{d}p}{\\mathrm{d}t} &= \\frac{\\mathrm{d}\\frac{n_A}{n_A + n_a}}{\\mathrm{d}t} \\\\ &= \\frac{\\frac{\\mathrm{d}n_A}{\\mathrm{d}t} (n_A + n_a) - n_A \\frac{\\mathrm{d}(n_A+n_a)}{\\mathrm{d}t}}{(n_A + n_a)^2}\\\\ &= \\frac{r_A n_A (n_A + n_a) - n_A (r_A n_A + r_a n_a)}{(n_A + n_a)^2}\\\\ &= \\frac{r_A n_A n_a - r_a n_A n_a)}{(n_A + n_a)^2}\\\\ &= \\frac{(r_A -r_a)n_A n_a}{(n_A + n_a)^2}\\\\ &= (r_A -r_a)p q, \\end{aligned} \\] where \\(s_c = r_A - r_a\\) is the continuous-time selection coefficient of allele \\(A\\) . A similar equation can be derived for the model of diploid-selection in continuous time, but we will not study it (see Problem 3.16 in the text if you are curious). 6. Comparing haploid selection in discrete and continuous time Are the discrete- and continuous-time models of haploid selection as different as they look? \\[ p_{t+1} = \\frac{W_A p_t}{W_A p_t + W_a q_t} \\] \\[ \\frac{\\mathrm{d}p}{\\mathrm{d}t} = s_c p q \\] Not really. Discrete and continuous time models generally behave in a similar fashion when changes occur slowly over time. For this model of haploid selection, this implies that the discrete and continuous models will be similar when the fitnesses of the two alleles are nearly equal, i.e., when \\(W_A - W_a\\) is small. This is called \"weak selection\". In the discrete model, the change in the allele frequency is \\[ \\begin{aligned} \\Delta p &= p_{t+1} - p_t \\\\ &= \\frac{W_A p_t}{W_A p_t + W_a q_t} - p_t \\\\ &= \\frac{(W_A - W_a)p_t q_t}{W_A p_t + W_a q_t}. \\end{aligned} \\] Now define \\(s_d = (W_A - W_a)/W_a\\) as the discrete time selection coefficient. Subbing this in as \\(W_A = s_d W_a + W_a\\) gives \\[ \\begin{aligned} \\Delta p &= \\frac{(W_A-W_a)p_t q_t}{W_A p_t + W_a q_t}\\\\ &= \\frac{(s_d W_a + W_a - W_a) p_t q_t}{(s_d W_a + W_a) p_t + W_a q_t}\\\\ &= \\frac{s_d W_a p_t q_t}{s_d W_a p_t + W_a (p_t + q_t)}\\\\ &= \\frac{s_d W_a p_t q_t}{s_d W_a p_t + W_a}\\\\ &= \\frac{s_d p_t q_t}{s_d p_t + 1}\\\\ \\end{aligned} \\] Now assume weak selection, i.e., that \\(s_d\\) is small. This implies \\(s_d p_t + 1 \\approx 1\\) . Making this approximation we have \\[ \\Delta p \\approx s_d p_t q_t \\] This is equivalent to the continuous-time model when the selection coefficients are equal, \\(s_c = s_d\\) . 7. The models we've covered To summarize the last two lectures, we've derived four of the most classic models in ecology and evolution: Model Discrete time Continous time Exponential growth \\(n_{t+1} = R n_t\\) \\(\\frac{\\mathrm{d}n}{\\mathrm{d}t} = r n\\) Logistic growth \\(n_{t+1} = (1 + r(1 - \\frac{n_t}{K}))n_t\\) \\(\\frac{\\mathrm{d}n}{\\mathrm{d}t} = r(1 - \\frac{n}{K})n\\) Haploid selection \\(p_{t+1} = \\frac{W_A p_t}{W_A p_t + W_a q_t}\\) \\(\\frac{\\mathrm{d}p}{\\mathrm{d}t} = s p(1-p)\\) Diploid selection \\(p_{t+1} = \\frac{W_{AA}p_t^2 + W_{Aa}p_t q_t}{W_{AA}p_t^2 + 2 W_{Aa} p_t q_t + W_{aa} q_t^2}\\) Not derived See textbook Sections 3.4 and 3.5 for models of interacting species and epidemiology, respectively, which we won't cover in class.","title":"Lecture 4"},{"location":"lectures/lecture-04/#lecture-4-one-locus-selection","text":"Run notes interactively?","title":"Lecture 4: One-locus selection"},{"location":"lectures/lecture-04/#lecture-overview","text":"Review of Hardy-Weinberg One-locus haploid selection in discrete time One-locus diploid selection in discrete time Comparing haploid and diploid selection One-locus haploid selection in continuous time Comparing haploid selection in discrete and continuous time The models we've covered","title":"Lecture overview"},{"location":"lectures/lecture-04/#1-review-of-hardy-weinberg","text":"In Lecture 2 we saw that in the absence of selection, one round of random union among gametes (equivalently, random mating among diploids) causes the frequency of diploid genotypes at a locus with two alleles, \\(A\\) and \\(a\\) , to become \\(AA\\) : \\(p^2\\) \\(Aa\\) : \\(2pq\\) \\(aa\\) : \\(q^2\\) where \\(p\\) is the frequency of allele \\(A\\) and \\(q=1-p\\) is the frequency of allele \\(a\\) . A population with these diploid genotype frequencies is said to be in Hardy-Weinberg equilibrium. Furthermore, we showed that under this model the allele frequencies do not change, \\(p' = p\\) . But what if there is selection?","title":"1. Review of Hardy-Weinberg"},{"location":"lectures/lecture-04/#2-one-locus-haploid-selection-in-discrete-time","text":"We begin by examining a model where selection acts during the haploid phase of the life-cycle. This is a little simpler than diploid selection because there are only two haploid genotypes, \\(A\\) and \\(a\\) . It is also a very relevant model for species with long haploid phases (eg, some algae and fungi) or with strong competition during the haploid phase (eg, pollen competiting for ovules).","title":"2. One-locus haploid selection in discrete time"},{"location":"lectures/lecture-04/#life-cycle-diagram","text":"We first illustrate the structure of the model with a life-cycle diagram. graph LR; A((random<br> union)) --diploid--> B((meiosis)); B --haploid--> C((selection)); C --haploid--> A; Figure. Life-cycle diagram of haploid selection We will census the population at the beginning of the haploid phase (immediately after meiosis).","title":"Life-cycle diagram"},{"location":"lectures/lecture-04/#deriving-the-equations","text":"Let the number of haploid individuals with each allele be \\(n_A(t) =\\) number of individuals with the \\(A\\) allele in generation \\(t\\) \\(n_a(t) =\\) number of individuals with the \\(a\\) allele in generation \\(t\\) The frequency of \\(A\\) is therefore \\(p_t = \\frac{n_a(t)}{n_A(t) + n_a(t)}\\) . Now, let\u2019s assume that during selection each haploid individual has reproductive factor \\(W_A =\\) reproductive factor of individuals with the \\(A\\) allele \\(W_a =\\) reproductive factor of individuals with the \\(a\\) allele These reproductive factors are referred to as the absolute fitnesses as they determine the (absolute) numbers of individuals after selection, \\(n_i' = W_i n_i(t)\\) for \\(i=A\\) and \\(i=a\\) . To relate back to the models of population growth in Lecture 3, this is exponential growth of each allele. After selection these alleles randomly pair, go through the dipliod phase of the life cycle, and then segregate back into haploids after meiosis. We assume this does not change the numbers of each allele (or at least the relative numbers, eg, all diploid individuals could produce X gametes). The frequency of \\(A\\) in the next generation is therefore \\[ \\begin{aligned} p_{t+1} &= \\frac{n_A(t+1)}{n_A(t+1) + v_a n_a(t)} \\\\ &= \\frac{W_A n_A(t)}{W_A n_A(t) + W_a n_a(t)}. \\end{aligned} \\] To make this a recursion equation we need to write \\(p_{t+1}\\) in terms of \\(p_t\\) , so that if we knew \\(p\\) at some point in time we can recursively calculate it in all future times. To do this we divide both the numerator and denominator by the total number of individuals, \\(n_A(t) + n_a(t)\\) , and simplify \\[ \\begin{aligned} p_{t+1} &= \\frac{W_A n_A(t)}{W_A n_A(t) + W_a n_a(t)} \\\\ &= \\frac{W_A\\frac{n_A(t)}{n_A(t) + n_a(t)}}{W_A\\frac{n_A(t)}{n_A(t) + n_a(t)} + W_a\\frac{n_a(t)}{n_A(t) + n_a(t)}}\\\\ &= \\frac{W_A p_t}{W_A p_t + W_a q_t}. \\end{aligned} \\] This is now a recursion equation for the allele frequency in our model of haploid selection.","title":"Deriving the equations"},{"location":"lectures/lecture-04/#simplifying","text":"Our current recursion is a function of two parameters, the absolute fitnesses \\(W_A\\) and \\(W_a\\) . Now notice that if we divide both the numerator and denominator by one of these fitnesses, say \\(W_a\\) , then we can reduce the recursion to a function of only one parameter, \\(w_A = W_A/W_a\\) , the fitness of \\(A\\) relative to the fitness of \\(a\\) , \\[ \\begin{aligned} p_{t+1} &= \\frac{(W_A/W_a)p_t}{(W_A/W_a)p_t + (W_a/W_a)q_t}\\\\ &= \\frac{w_A p_t}{w_A p_t + q_t}. \\end{aligned} \\] Note that the allele frequency dynamics depend only on the relative fitnesses , and not on the absolute fitnesses, meaning that evolution does not depend on how the size of the population changes. It is therefore possible to study evolution while ignoring population dynamics under this simple model. Let's plot the recursion to get a sense of the dynamics. import matplotlib.pyplot as plt # calculate allele frequency over time with recursion w_A = 1.1 #relative fitness of allele A p_now = 0.01 #initial allele frequency, p_0 ps = [] #list to hold allele frequencies over time ts = range(100) #list of time steps for t in ts: #for each time ps.append(p_now) #add current allele frequency to list p_now = w_A*p_now/(w_A*p_now+(1-p_now)) #update allele frequency with our recursion equation # plot plt.scatter(ts, ps) #plot the (t,p) pairs plt.xlabel(\"generation, $t$\") #label axes plt.ylabel(\"frequency of $A$ allele, $p_t$\") plt.show()","title":"Simplifying"},{"location":"lectures/lecture-04/#3-one-locus-diploid-selection-in-discrete-time","text":"Since we are all currently in the diploid phase of our life-cycle, it is natural to ask: Does selection in the diploid phase work the same way?","title":"3. One-locus diploid selection in discrete time"},{"location":"lectures/lecture-04/#life-cycle-diagram_1","text":"We now have the following life-cycle diagram. graph LR; A((random<br> union)) --diploid--> B((selection)); B --diploid--> C((meiosis)); C --haploid--> A; Figure. Life-cycle diagram of diploid selection We will census at the beginning of the diploid phase (immediately after gamete union).","title":"Life-cycle diagram"},{"location":"lectures/lecture-04/#deriving-the-equations_1","text":"Let the number of diploid individuals with each genotype be \\(n_{AA}(t) =\\) number of individuals with the \\(AA\\) genotype in generation \\(t\\) \\(n_{Aa}(t) =\\) number of individuals with the \\(Aa\\) genotype in generation \\(t\\) \\(n_{aa}(t) =\\) number of individuals wite the \\(aa\\) genotype in generation \\(t\\) The frequency of allele \\(A\\) is then \\[ \\begin{aligned} p_t &= \\frac{2n_{AA}(t) + n_{Aa}(t)}{2n_{AA}(t) + n_{Aa}(t) + n_{aa}(t)} \\\\ &= \\frac{n_{AA}(t) + \\frac{1}{2}n_{Aa}(t)}{n_{AA}(t) + n_{Aa}(t) + n_{aa}(t)} \\end{aligned} \\] Now, let\u2019s assume that during selection each diploid individual has reproductive factor \\(W_{AA} =\\) reproductive factor of individuals with the \\(AA\\) genotype \\(W_{Aa} =\\) reproductive factor of individuals with the \\(Aa\\) genotype \\(W_{aa} =\\) reproductive factor of individuals with the \\(aa\\) genotype These reproductive factors are again referred to as the absolute fitnesses as they determine the (absolute) numbers of individuals after selection, \\(n_i' = W_i n_i(t)\\) for \\(i=AA\\) , \\(i=Aa\\) , and \\(i=aa\\) . After selection these genotypes segregate into haploids via meiosis, go through the haploid phase of the life cycle, and then random join to create diploids again. We assume this does not change the numbers of each genotype (or at least the relative numbers, eg, all diploid individuals could produce X gametes). The frequency of \\(A\\) in the next generation is therefore \\[ \\begin{aligned} p_{t+1} &= \\frac{n_{AA}(t+1) + \\frac{1}{2}n_{Aa}(t+1)}{n_{AA}(t+1) + n_{Aa}(t+1) + n_{aa}(t+1)}\\\\ &= \\frac{W_{AA}n_{AA}(t) + \\frac{1}{2}W_{Aa}n_{Aa}(t)}{W_{AA}n_{AA}(t) + \\frac{1}{2}W_{Aa}n_{Aa}(t) + W_{aa}n_{aa}(t)}. \\end{aligned} \\] As above, we want a recursion equation in terms of allele frequency, so we want to replace the \\(n_i\\) 's in the right hand side of this equation with \\(p\\) 's. To do this we note that with the random union of gametes the diploid offspring are in Hardy-Weinberg proportions, so that \\[ \\begin{aligned} n_{AA}(t) &= p_t^2 n(t) \\\\ n_{Aa}(t) &= 2p_t q_t n(t) \\\\ n_{aa}(t) &= q_t^2 n(t) \\end{aligned} \\] where \\(n(t) = n_{AA}(t) + n_{Aa}(t) + n_{aa}(t)\\) is the total population size. Substituting these Hardy-Weinberg proportions in and simplifying, the total population size cancels out and we can rewrite the above equation in terms of allele frequency alone, \\[ \\begin{aligned} p_{t+1} &= \\frac{W_{AA}p_t^2 n(t) + W_{Aa}p_t q_t n(t)}{W_{AA}p_t^2 n(t) + 2W_{Aa}p_t q_t n(t) + W_{aa}q_t^2 n(t)}\\\\ &= \\frac{W_{AA}p_t^2 + W_{Aa}p_t q_t}{W_{AA}p_t^2 + 2W_{Aa}p_t q_t + W_{aa}q_t^2}. \\end{aligned} \\] This is a recursion equation for allele frequency in our model of diploid selection.","title":"Deriving the equations"},{"location":"lectures/lecture-04/#simplifying_1","text":"As in the haploid selection case, we can divide by one of the absolute fitnesses, say \\(W_{aa}\\) , to remove one parameter from the model \\[ \\begin{aligned} p_{t+1} &= \\frac{(W_{AA}/W_{aa})p_t^2 + (W_{Aa}/W_{aa})p_t q_t}{(W_{AA}/W_{aa})p_t^2 + 2(W_{Aa}/W_{aa})p_t q_t + (W_{aa}/W_{aa})q_t^2} \\\\ &= \\frac{w_{AA}p_t^2 + w_{Aa}p_t q_t}{w_{AA}p_t^2 + 2w_{Aa}p_t q_t + q_t^2} \\end{aligned} \\] This recursion is a function of only two relative fitnesses, \\(w_{AA} = W_{AA}/W_{aa}\\) and \\(w_{Aa} = W_{Aa}/W_{aa}\\) . Let's plot the recursion to get a sense of the dynamics. import matplotlib.pyplot as plt # calculate allele frequency over time with recursion w_AA = 1.2 #relative fitness of genotype AA w_Aa = 1.1 #relative fitness of genotype Aa p_now = 0.01 #initial allele frequency, p_0 ps = [] #list to hold allele frequencies over time ts = range(100) #list of time steps for t in ts: #for each time ps.append(p_now) #add current allele frequency to list p_now = (w_AA*p_now**2 + w_Aa*p_now*(1-p_now))/(w_AA*p_now**2 + 2*w_Aa*p_now*(1-p_now) + (1-p_now)**2) #update allele frequency with our recursion equation # plot plt.scatter(ts, ps) plt.xlabel(\"generation, $t$\") plt.ylabel(\"frequency of $A$ allele, $p_t$\") plt.show()","title":"Simplifying"},{"location":"lectures/lecture-04/#4-comparing-haploid-and-diploid-selection","text":"So, returning to our original question, let's compare evolution under haploid selection \\[ p_{t+1} = \\frac{W_A p_t}{W_A p_t + W_a q_t} \\] to evolution under diploid selection \\[ p_{t+1} = \\frac{W_{AA}p_t^2 + W_{Aa}p_t q_t}{W_{AA}p_t^2 + 2W_{Aa}p_t q_t + W_{aa}q_t^2}. \\] To facilitate this, let\u2019s assume the fitness of a diploid genotype is the product of the haploid fitnesses, i.e., \\(W_{AA} = W_A W_A\\) , \\(W_{Aa} = W_A W_a\\) , and \\(W_{aa} = W_a W_a\\) . It then happens that our diploid recursion reduces to the haploid recursion, \\[ \\begin{aligned} p_{t+1} &= \\frac{W_A W_A p_t^2 + W_A W_a p_t q_t}{W_A W_A p_t^2 + 2W_A W_a p_t q_t + W_a W_a q_t^2}\\\\ &= \\frac{W_A p_t(p_t + W_a q_t)}{W_A p_t(W_A p_t + W_a q_t) + W_a q_t(W_A p_t + W_a q_t)}\\\\ &= \\frac{W_A p_t}{W_A p_t + W_a q_t} \\end{aligned} \\] This shows that we need twice as much selection under diploid selection relative to that under haploid selection (e.g., \\(W_{AA} = W_A W_A\\) ) for evolution to proceed as quickly. Why is evolution slower under diploid selection? Let's check this visually (try breaking the assumption above, \\(W_{ij}=W_i W_j\\) , to see what happens). import matplotlib.pyplot as plt # calculate allele frequency over time with recursion w_A = 1.1 #relative fitness of allele A in the haploid model w_AA = w_A*w_A #relative fitness of genotype AA in the diploid model w_Aa = w_A #relative fitness of genotype Aa in the diploid model p_now_hap = 0.01 #initial allele frequency, p_0 p_now_dip = p_now_hap ps_hap, ps_dip = [], [] #lists to hold allele frequencies over time ts = range(100) #list of time steps for t in ts: #for each time ps_hap.append(p_now_hap) #add current allele frequency to list p_now_hap = w_A*p_now_hap/(w_A*p_now_hap+(1-p_now_hap)) #update allele frequency with haploid recursion equation ps_dip.append(p_now_dip) #add current allele frequency to list p_now_dip = (w_AA*p_now_dip**2 + w_Aa*p_now_dip*(1-p_now_dip))/(w_AA*p_now_dip**2 + 2*w_Aa*p_now_dip*(1-p_now_dip) + (1-p_now_dip)**2) #update allele frequency with diploid recursion equation # plot plt.scatter(ts, ps_hap, label='haploid') plt.scatter(ts, ps_dip, label='diploid') plt.xlabel(\"generation, $t$\") plt.ylabel(\"frequency of $A$ allele, $p_t$\") plt.legend() #add legend to know which points belong to which model plt.show()","title":"4. Comparing haploid and diploid selection"},{"location":"lectures/lecture-04/#5-one-locus-haploid-selection-in-continuous-time","text":"To model haploid selection in continuous-time we assume that during the selective phase each haploid individual has growth rate \\(r_A =\\) growth rate of individuals with the \\(A\\) allele \\(r_a =\\) growth rate of individuals with the \\(a\\) allele and the relative numbers of each type don't change otherwise (ie, during union, diploidy, or meiosis). We therefore have exponential growth of both genotypes, \\(\\frac{\\mathrm{d} n_i}{dt} = r_i n_i\\) . At any particular point in time, \\(t\\) , the frequency of allele \\(A\\) is, \\(p_t = n_A(t)/(n_A(t) + n_a(t))\\) . We can therefore derive the rate of change in the frequency of allele \\(A\\) , \\(\\mathrm{d}p/\\mathrm{d}t\\) , using the qoutient rule (see Appendix 2 in the text for help with this and other math tricks) \\[ \\begin{aligned} \\frac{\\mathrm{d}p}{\\mathrm{d}t} &= \\frac{\\mathrm{d}\\frac{n_A}{n_A + n_a}}{\\mathrm{d}t} \\\\ &= \\frac{\\frac{\\mathrm{d}n_A}{\\mathrm{d}t} (n_A + n_a) - n_A \\frac{\\mathrm{d}(n_A+n_a)}{\\mathrm{d}t}}{(n_A + n_a)^2}\\\\ &= \\frac{r_A n_A (n_A + n_a) - n_A (r_A n_A + r_a n_a)}{(n_A + n_a)^2}\\\\ &= \\frac{r_A n_A n_a - r_a n_A n_a)}{(n_A + n_a)^2}\\\\ &= \\frac{(r_A -r_a)n_A n_a}{(n_A + n_a)^2}\\\\ &= (r_A -r_a)p q, \\end{aligned} \\] where \\(s_c = r_A - r_a\\) is the continuous-time selection coefficient of allele \\(A\\) . A similar equation can be derived for the model of diploid-selection in continuous time, but we will not study it (see Problem 3.16 in the text if you are curious).","title":"5. One-locus haploid selection in continuous time"},{"location":"lectures/lecture-04/#6-comparing-haploid-selection-in-discrete-and-continuous-time","text":"Are the discrete- and continuous-time models of haploid selection as different as they look? \\[ p_{t+1} = \\frac{W_A p_t}{W_A p_t + W_a q_t} \\] \\[ \\frac{\\mathrm{d}p}{\\mathrm{d}t} = s_c p q \\] Not really. Discrete and continuous time models generally behave in a similar fashion when changes occur slowly over time. For this model of haploid selection, this implies that the discrete and continuous models will be similar when the fitnesses of the two alleles are nearly equal, i.e., when \\(W_A - W_a\\) is small. This is called \"weak selection\". In the discrete model, the change in the allele frequency is \\[ \\begin{aligned} \\Delta p &= p_{t+1} - p_t \\\\ &= \\frac{W_A p_t}{W_A p_t + W_a q_t} - p_t \\\\ &= \\frac{(W_A - W_a)p_t q_t}{W_A p_t + W_a q_t}. \\end{aligned} \\] Now define \\(s_d = (W_A - W_a)/W_a\\) as the discrete time selection coefficient. Subbing this in as \\(W_A = s_d W_a + W_a\\) gives \\[ \\begin{aligned} \\Delta p &= \\frac{(W_A-W_a)p_t q_t}{W_A p_t + W_a q_t}\\\\ &= \\frac{(s_d W_a + W_a - W_a) p_t q_t}{(s_d W_a + W_a) p_t + W_a q_t}\\\\ &= \\frac{s_d W_a p_t q_t}{s_d W_a p_t + W_a (p_t + q_t)}\\\\ &= \\frac{s_d W_a p_t q_t}{s_d W_a p_t + W_a}\\\\ &= \\frac{s_d p_t q_t}{s_d p_t + 1}\\\\ \\end{aligned} \\] Now assume weak selection, i.e., that \\(s_d\\) is small. This implies \\(s_d p_t + 1 \\approx 1\\) . Making this approximation we have \\[ \\Delta p \\approx s_d p_t q_t \\] This is equivalent to the continuous-time model when the selection coefficients are equal, \\(s_c = s_d\\) .","title":"6. Comparing haploid selection in discrete and continuous time"},{"location":"lectures/lecture-04/#7-the-models-weve-covered","text":"To summarize the last two lectures, we've derived four of the most classic models in ecology and evolution: Model Discrete time Continous time Exponential growth \\(n_{t+1} = R n_t\\) \\(\\frac{\\mathrm{d}n}{\\mathrm{d}t} = r n\\) Logistic growth \\(n_{t+1} = (1 + r(1 - \\frac{n_t}{K}))n_t\\) \\(\\frac{\\mathrm{d}n}{\\mathrm{d}t} = r(1 - \\frac{n}{K})n\\) Haploid selection \\(p_{t+1} = \\frac{W_A p_t}{W_A p_t + W_a q_t}\\) \\(\\frac{\\mathrm{d}p}{\\mathrm{d}t} = s p(1-p)\\) Diploid selection \\(p_{t+1} = \\frac{W_{AA}p_t^2 + W_{Aa}p_t q_t}{W_{AA}p_t^2 + 2 W_{Aa} p_t q_t + W_{aa} q_t^2}\\) Not derived See textbook Sections 3.4 and 3.5 for models of interacting species and epidemiology, respectively, which we won't cover in class.","title":"7. The models we've covered"},{"location":"lectures/lecture-05/","text":"{ requestKernel: true, mountActivateWidget: true, mountStatusWidget: true, binderOptions: { repo: \"tomouellette/executable-cells\", ref: \"main\", binderUrl: \"https://gke.mybinder.org\", }, } Lecture 5: Numerical and graphical techniques I (univariate) Run notes interactively? Lecture overview Numerical and graphical techniques Plots of variables over time Plots of variables as a function of the variables themselves Summary 1. Numerical and graphical techniques Before we jump into more rigorous mathematical analyses, we\u2019re first going to learn how to get a feel for the dynamics of our models. To do so we\u2019re going to choose some particular numerical values for our parameters and then use our models to predict what happens over time. The downside of this approach is that we often won\u2019t know the parameter values to choose and, regardless, choosing particular values doesn\u2019t tell us about the dynamics of our model more generally. The upside is that this approach can highlight errors or reveal unexpected patterns that guide future mathematical analyses. 2. Plots of variables over time Exponential growth model In the discrete exponential growth model, there is one parameter, \\(R\\) , the number of offspring per parent (\"reproductive factor\"). In last week\u2019s lab we wrote a recursive function (actually, a generator) to generate values of \\(n_t\\) , the population size, at sequential time points. import numpy as np def n(t0, n0, R, max=np.inf): # Set the initial value of t and n_t t, nt = t0, n0 # Yield new values of n_t if t hasn't gone past the max value while t < max: yield nt # Then update t (this is equivalent to t = t + 1) and n_t t, nt = t + 1, nt * R We then chose some parameter values (reproductive factor, \\(R = 2\\) ) and initial conditions (initial population size, \\(n_0 = 1\\) ) to get the values of \\(n_t\\) from the initial ( \\(t = 0\\) ) to final ( \\(t = 10\\) ) time. nt = n(t0=0, n0=1, R=2, max=10) #choose some parameter values nts = [n for n in nt] #get all the t, n_t values nts [1, 2, 4, 8, 16, 32, 64, 128, 256, 512] And we then plotted \\(n_t\\) as a function of \\(t\\) import matplotlib.pyplot as plt fig, ax = plt.subplots() ax.plot(range(10), nts, marker = '.', markersize = 10) ax.set_xlabel('generation, $t$') ax.set_ylabel('population size, $n_t$') plt.show() This allowed us to compare what happens for different values of the reproductive factor, \\(R\\) . colors = ['black','blue','red'] fig, ax = plt.subplots() for i, R in enumerate([1.1,1,0.9]): nt = n(t0=0, n0=100, R=R, max=10) nts = [n for n in nt] ax.plot(range(10), nts, color=colors[i], label=f\"R = {R}\", marker = '.', markersize = 10) ax.set_xlabel('generation, $t$') ax.set_ylabel('population size, $n_t$') ax.legend() plt.show() We see that when \\(R>1\\) we get population growth and when \\(R<1\\) we get population decline. When \\(R=1\\) the population size remains constant. Logistic growth model In the discrete logistic growth model, there are two parameters, the intrinsic growth rate, \\(r\\) , and the carrying capacity, \\(K\\) . The behaviour doesn\u2019t change much with different values of \\(K\\) but it is extremely sensitive to the value of \\(r\\) , as you may remember from last week\u2019s lab. def n(n0, r, k, max=np.inf): t, nt = 0, n0 while t < max: yield nt t, nt = t + 1, nt + r * nt * (1 - nt / k) # Initialize plots fig, ax = plt.subplots(1, 2, sharex=True, sharey=True) fig.set_size_inches(12,4) # Logistic growth with smaller r values for r in [0.40, 0.70, 1.80, 2.10]: ax[0].plot( #plot lines connecting values for visual clarity range(25), [nt for nt in n(1, r, 1000, max=25)], label = f\"r = {r}\", marker = '.', markersize = 10 ) # Logistic growth with larger r values for r in [2.70, 3.0995]: ax[1].plot( range(25), [nt for nt in n(1, r, 1000, max=25)], label = f\"r = {r}\", marker = '.', markersize = 10 ) # Add titles and annotations ax[0].set_title('smaller $r$') ax[1].set_title('larger $r$') for i in range(2): ax[i].set_xlabel('generation, $t$') ax[i].set_ylabel('population size, $n_t$') ax[i].legend() fig.tight_layout() plt.show() Bifurcation diagrams and chaos We can examine how this model behaves as we change \\(r\\) by making a bifurcation diagram , which plots the values the system takes on after a long time for a given parameter value. Check out the very complex and potentially strange dynamics in the plot below. What does it mean? # Sample the periodicity of the oscillations # by taking unique values after reaching carrying capacity (here we use t between 30 and 75) def log_map(r, n0=900, k=1000): return np.unique([nt for t, nt in enumerate(n(n0, r, k, max=75)) if t > 30]) # Compute the logistic map for different growth rates in discrete time r, Nr = np.array([]), np.array([]) #list of r and n_t values we will plot for i in np.linspace(1.5, 3, 1000): #these are the r values we will simulate nl = log_map(i) #get the unique values after carrying capacity r = np.hstack((r, [i for _ in range(len(nl))])) #add the r value to plotting list (repeat the value of r for each unique n_t value (for plotting)) Nr = np.hstack((Nr, nl)) #add the n_t values to plotting list # Plot the logistic map on a black background (why not?) fig, ax = plt.subplots() ax.patch.set_facecolor('black') ax.scatter(r, Nr, s=0.075, color='white') plt.xlabel('intrinsic growth rate, $r$') plt.ylabel('population size, $n_t$') plt.show() 3. Plots of variables as a function of the variables themselves OK, so now we\u2019ll move on to a plot that is easier to generate and is very useful for models with just one variable (which is what we\u2019ve been working with so far). Instead of plotting the variable as a function of time, we\u2019ll plot the variable as a function of the variable in the previous time, e.g., plotting \\(n_{t+1}\\) as a function of \\(n_t\\) . Haploid selection Let's start with our model of haploid selection \\[ p_{t+1} = \\frac{W_A p_t}{W_A p_t + W_a (1-p_t)} \\] and plot for two different sets of parameter values, where \\(A\\) has a higher or lower fitness than \\(a\\) . import sympy # Build cobweb plotting function def cobweb_haploid(p0, WA, Wa, max=np.inf): t, pnow, pnext = 0, p0, 0 #initial conditions while t < = max: yield pnow, pnext #current value of p_t and p_(t+1) pnext = (WA * pnow) / (WA * pnow + Wa * (1 - pnow)) #update p_(t+1) yield pnow, pnext #current value of p_t and p_(t+1) pnow = pnext #update p_t t += 1 #update t # Build function for generating figure def plot_haploid_selection(WA, Wa, p0=0.5, ax=None): pt = sympy.symbols('pt') #define our variable p_t # Write out sympy equation f = (WA * pt) / (WA * pt + Wa * (1 - pt)) #the recursion equation # Compute function over a set of points in [0,1] by 'lambdifying' sympy equation (turn it into a function) t = np.linspace(0,1,100) fy = sympy.lambdify(pt, f)(t) # Build plot if ax == None: fig, ax = plt.subplots() ax.plot(t, fy, color='black', label=f\"$W_A$ = {WA}, $W_a$ = {Wa}\") #plot p_(t+1) as function of p_t ax.plot(t, t, color='black', linestyle='--') #draw 1:1 line for reference # Add cobweb cobweb = np.array([p for p in cobweb_haploid(p0, WA, Wa, max=100)]) ax.plot(cobweb[:,0], cobweb[:,1]) # Annotate and label plot ax.set_xlim(0,1) ax.set_ylim(0,1) ax.set_xlabel(\"allele frequency at $t$, $p_t$\") ax.set_ylabel(\"allele frequency at $t+1$, $p_{t+1}$\") ax.legend(frameon=False) return ax # Plot figure fig, ax = plt.subplots(1,2) fig.set_size_inches(12,4) # First cobweb with WA > Wa plot_haploid_selection(WA = 1, Wa = 0.5, ax=ax[0]) # Second cobweb with WA < Wa plot_haploid_selection(WA = 0.5, Wa = 1, ax=ax[1]) plt.show() Note that the cobweb plots (staircase looking lines in blue) track the movement of the allele frequencies from \\(t \\rightarrow t + 1\\) . By following the cobweb, you can determine if and where the system will converge to an equilibrium . (Next week we'll do this mathematically.) What are the stable equilibria above? Diploid selection Now let\u2019s move on to the slightly more complex model of diploid selection \\[ p_{t+1} = \\frac{W_{AA} p_t^2 + W_{Aa}p_t q_t}{W_{AA}p_t^2 + W_{Aa}2p_tq_t + W_{aa}q_t^2} \\] To show some different behaviour than above, this time let's set \\(W_{AA} < W_{Aa} > W_{aa}\\) and plot for two different starting frequencies, \\(p_0\\) . def cobweb_diploid(p0, WAA, WAa, Waa, max=np.inf): t, pnow, pnext = 0, p0, 0 #initial conditions while t < = max: yield pnow, pnext #current value of p(t) and p(t+1) pnext = (WAA * pnow**2 + WAa * pnow * (1 - pnow)) / (WAA * pnow**2 + WAa * 2 * pnow * (1 - pnow) + Waa * (1 - pnow)**2) #update p(t+1) yield pnow, pnext #current value of p(t) and p(t+1) pnow = pnext #update p(t) t += 1 #update t # Build function for generating figure def plot_diploid_selection(WAA, WAa, Waa, ax=None, p0=0.5): pt = sympy.symbols('pt') #define our variable p(t) # Write out sympy equation f = (WAA * pt**2 + WAa * pt * (1- pt) ) / (WAA * pt**2 + WAa * 2 * pt * (1 - pt) + Waa * (1 - pt)**2) #the recursion equation # Compute function over a set of points in [0,1] by 'lambdifying' sympy equation x = np.linspace(0,1,100) fy = sympy.lambdify(pt, f)(x) # Build plot if ax == None: fig, ax = plt.subplots() # Add cobweb cobweb = np.array([p for p in cobweb_diploid(p0, WAA, WAa, Waa, max=100)]) ax.plot(cobweb[:,0], cobweb[:,1]) # Annotate and label plot ax.plot(x, fy, color='black', label=f\"$W_A$$_A$ = {WAA}, $W_A$$_a$ = {WAa}, $W_a$$_a$ = {Waa}\") ax.plot(x, x, color='black', linestyle='--') ax.set_xlim(0,1) ax.set_ylim(0,1) ax.set_xlabel(\"allele frequency at $t$, $p_t$\") ax.set_ylabel(\"allele frequency at $t+1$, $p_{t+1}$\") ax.legend(frameon=False) return ax # Plot figure fig, ax = plt.subplots(1,2) fig.set_size_inches(12,4) # First cobweb from low starting condition plot_diploid_selection(WAA=1, WAa=2, Waa=1, p0=0.05, ax=ax[0]) # Second cobweb from high starting condition plot_diploid_selection(WAA=1, WAa=2, Waa=1, p0=0.95, ax=ax[1]) plt.show() What is the stable equilibrium in this case? Other models We can do something very similar for difference and differential equations. Now we plot the change in the variable as a function of the current value of the variable, e.g., plot \\(dn/dt\\) as a function of \\(n\\) . For example, in our model of haploid selection we have \\[ \\frac{\\mathrm{d}p}{\\mathrm{d}t} = sp(1-p) \\] and our plot looks like: # Initialize sympy symbols p0, s, t = sympy.symbols('p0, s, t') p = sympy.Function('t') # Specify differential equation diffeq = sympy.Eq(p(t).diff(t), s * p(t) * (1 - p(t))) # Convert differential equation RHS to pythonic function dp = sympy.lambdify((s, p(t)), diffeq.rhs) # Plot the curve fig, ax = plt.subplots() for s_coeff in [0.01, -0.01]: ax.plot( np.linspace(0, 1, 100), dp(s_coeff, np.linspace(0,1, 100)), label=f\"s = {s_coeff}\" ) ax.set_xlabel('allele frequency at $t, p$') ax.set_ylabel('change in allele frequency, $\\mathrm{d}p/\\mathrm{d}t$') ax.legend(frameon=False) plt.show() What does this tell us about how allele frequency will change when \\(s>0\\) vs. \\(s<0\\) ? And what allele frequencies, \\(p\\) , cause more rapid evolution? In this week's lab we'll plot the continuous logistic growth model, which shows some more complex dynamics. 4. Summary To get a feel for our model it is helpful to graph some numerical examples: Plot the variable as a function of time (\"simulate\") Plot the variable (or change in variable) as a function of itself (only works for models with one variable) Next lecture we\u2019ll look at a graphical technique for models with multiple variables...","title":"Lecture 5"},{"location":"lectures/lecture-05/#lecture-5-numerical-and-graphical-techniques-i-univariate","text":"Run notes interactively?","title":"Lecture 5: Numerical and graphical techniques I (univariate)"},{"location":"lectures/lecture-05/#lecture-overview","text":"Numerical and graphical techniques Plots of variables over time Plots of variables as a function of the variables themselves Summary","title":"Lecture overview"},{"location":"lectures/lecture-05/#1-numerical-and-graphical-techniques","text":"Before we jump into more rigorous mathematical analyses, we\u2019re first going to learn how to get a feel for the dynamics of our models. To do so we\u2019re going to choose some particular numerical values for our parameters and then use our models to predict what happens over time. The downside of this approach is that we often won\u2019t know the parameter values to choose and, regardless, choosing particular values doesn\u2019t tell us about the dynamics of our model more generally. The upside is that this approach can highlight errors or reveal unexpected patterns that guide future mathematical analyses.","title":"1. Numerical and graphical techniques"},{"location":"lectures/lecture-05/#2-plots-of-variables-over-time","text":"","title":"2. Plots of variables over time"},{"location":"lectures/lecture-05/#exponential-growth-model","text":"In the discrete exponential growth model, there is one parameter, \\(R\\) , the number of offspring per parent (\"reproductive factor\"). In last week\u2019s lab we wrote a recursive function (actually, a generator) to generate values of \\(n_t\\) , the population size, at sequential time points. import numpy as np def n(t0, n0, R, max=np.inf): # Set the initial value of t and n_t t, nt = t0, n0 # Yield new values of n_t if t hasn't gone past the max value while t < max: yield nt # Then update t (this is equivalent to t = t + 1) and n_t t, nt = t + 1, nt * R We then chose some parameter values (reproductive factor, \\(R = 2\\) ) and initial conditions (initial population size, \\(n_0 = 1\\) ) to get the values of \\(n_t\\) from the initial ( \\(t = 0\\) ) to final ( \\(t = 10\\) ) time. nt = n(t0=0, n0=1, R=2, max=10) #choose some parameter values nts = [n for n in nt] #get all the t, n_t values nts [1, 2, 4, 8, 16, 32, 64, 128, 256, 512] And we then plotted \\(n_t\\) as a function of \\(t\\) import matplotlib.pyplot as plt fig, ax = plt.subplots() ax.plot(range(10), nts, marker = '.', markersize = 10) ax.set_xlabel('generation, $t$') ax.set_ylabel('population size, $n_t$') plt.show() This allowed us to compare what happens for different values of the reproductive factor, \\(R\\) . colors = ['black','blue','red'] fig, ax = plt.subplots() for i, R in enumerate([1.1,1,0.9]): nt = n(t0=0, n0=100, R=R, max=10) nts = [n for n in nt] ax.plot(range(10), nts, color=colors[i], label=f\"R = {R}\", marker = '.', markersize = 10) ax.set_xlabel('generation, $t$') ax.set_ylabel('population size, $n_t$') ax.legend() plt.show() We see that when \\(R>1\\) we get population growth and when \\(R<1\\) we get population decline. When \\(R=1\\) the population size remains constant.","title":"Exponential growth model"},{"location":"lectures/lecture-05/#logistic-growth-model","text":"In the discrete logistic growth model, there are two parameters, the intrinsic growth rate, \\(r\\) , and the carrying capacity, \\(K\\) . The behaviour doesn\u2019t change much with different values of \\(K\\) but it is extremely sensitive to the value of \\(r\\) , as you may remember from last week\u2019s lab. def n(n0, r, k, max=np.inf): t, nt = 0, n0 while t < max: yield nt t, nt = t + 1, nt + r * nt * (1 - nt / k) # Initialize plots fig, ax = plt.subplots(1, 2, sharex=True, sharey=True) fig.set_size_inches(12,4) # Logistic growth with smaller r values for r in [0.40, 0.70, 1.80, 2.10]: ax[0].plot( #plot lines connecting values for visual clarity range(25), [nt for nt in n(1, r, 1000, max=25)], label = f\"r = {r}\", marker = '.', markersize = 10 ) # Logistic growth with larger r values for r in [2.70, 3.0995]: ax[1].plot( range(25), [nt for nt in n(1, r, 1000, max=25)], label = f\"r = {r}\", marker = '.', markersize = 10 ) # Add titles and annotations ax[0].set_title('smaller $r$') ax[1].set_title('larger $r$') for i in range(2): ax[i].set_xlabel('generation, $t$') ax[i].set_ylabel('population size, $n_t$') ax[i].legend() fig.tight_layout() plt.show() Bifurcation diagrams and chaos We can examine how this model behaves as we change \\(r\\) by making a bifurcation diagram , which plots the values the system takes on after a long time for a given parameter value. Check out the very complex and potentially strange dynamics in the plot below. What does it mean? # Sample the periodicity of the oscillations # by taking unique values after reaching carrying capacity (here we use t between 30 and 75) def log_map(r, n0=900, k=1000): return np.unique([nt for t, nt in enumerate(n(n0, r, k, max=75)) if t > 30]) # Compute the logistic map for different growth rates in discrete time r, Nr = np.array([]), np.array([]) #list of r and n_t values we will plot for i in np.linspace(1.5, 3, 1000): #these are the r values we will simulate nl = log_map(i) #get the unique values after carrying capacity r = np.hstack((r, [i for _ in range(len(nl))])) #add the r value to plotting list (repeat the value of r for each unique n_t value (for plotting)) Nr = np.hstack((Nr, nl)) #add the n_t values to plotting list # Plot the logistic map on a black background (why not?) fig, ax = plt.subplots() ax.patch.set_facecolor('black') ax.scatter(r, Nr, s=0.075, color='white') plt.xlabel('intrinsic growth rate, $r$') plt.ylabel('population size, $n_t$') plt.show()","title":"Logistic growth model"},{"location":"lectures/lecture-05/#3-plots-of-variables-as-a-function-of-the-variables-themselves","text":"OK, so now we\u2019ll move on to a plot that is easier to generate and is very useful for models with just one variable (which is what we\u2019ve been working with so far). Instead of plotting the variable as a function of time, we\u2019ll plot the variable as a function of the variable in the previous time, e.g., plotting \\(n_{t+1}\\) as a function of \\(n_t\\) .","title":"3. Plots of variables as a function of the variables themselves"},{"location":"lectures/lecture-05/#haploid-selection","text":"Let's start with our model of haploid selection \\[ p_{t+1} = \\frac{W_A p_t}{W_A p_t + W_a (1-p_t)} \\] and plot for two different sets of parameter values, where \\(A\\) has a higher or lower fitness than \\(a\\) . import sympy # Build cobweb plotting function def cobweb_haploid(p0, WA, Wa, max=np.inf): t, pnow, pnext = 0, p0, 0 #initial conditions while t < = max: yield pnow, pnext #current value of p_t and p_(t+1) pnext = (WA * pnow) / (WA * pnow + Wa * (1 - pnow)) #update p_(t+1) yield pnow, pnext #current value of p_t and p_(t+1) pnow = pnext #update p_t t += 1 #update t # Build function for generating figure def plot_haploid_selection(WA, Wa, p0=0.5, ax=None): pt = sympy.symbols('pt') #define our variable p_t # Write out sympy equation f = (WA * pt) / (WA * pt + Wa * (1 - pt)) #the recursion equation # Compute function over a set of points in [0,1] by 'lambdifying' sympy equation (turn it into a function) t = np.linspace(0,1,100) fy = sympy.lambdify(pt, f)(t) # Build plot if ax == None: fig, ax = plt.subplots() ax.plot(t, fy, color='black', label=f\"$W_A$ = {WA}, $W_a$ = {Wa}\") #plot p_(t+1) as function of p_t ax.plot(t, t, color='black', linestyle='--') #draw 1:1 line for reference # Add cobweb cobweb = np.array([p for p in cobweb_haploid(p0, WA, Wa, max=100)]) ax.plot(cobweb[:,0], cobweb[:,1]) # Annotate and label plot ax.set_xlim(0,1) ax.set_ylim(0,1) ax.set_xlabel(\"allele frequency at $t$, $p_t$\") ax.set_ylabel(\"allele frequency at $t+1$, $p_{t+1}$\") ax.legend(frameon=False) return ax # Plot figure fig, ax = plt.subplots(1,2) fig.set_size_inches(12,4) # First cobweb with WA > Wa plot_haploid_selection(WA = 1, Wa = 0.5, ax=ax[0]) # Second cobweb with WA < Wa plot_haploid_selection(WA = 0.5, Wa = 1, ax=ax[1]) plt.show() Note that the cobweb plots (staircase looking lines in blue) track the movement of the allele frequencies from \\(t \\rightarrow t + 1\\) . By following the cobweb, you can determine if and where the system will converge to an equilibrium . (Next week we'll do this mathematically.) What are the stable equilibria above?","title":"Haploid selection"},{"location":"lectures/lecture-05/#diploid-selection","text":"Now let\u2019s move on to the slightly more complex model of diploid selection \\[ p_{t+1} = \\frac{W_{AA} p_t^2 + W_{Aa}p_t q_t}{W_{AA}p_t^2 + W_{Aa}2p_tq_t + W_{aa}q_t^2} \\] To show some different behaviour than above, this time let's set \\(W_{AA} < W_{Aa} > W_{aa}\\) and plot for two different starting frequencies, \\(p_0\\) . def cobweb_diploid(p0, WAA, WAa, Waa, max=np.inf): t, pnow, pnext = 0, p0, 0 #initial conditions while t < = max: yield pnow, pnext #current value of p(t) and p(t+1) pnext = (WAA * pnow**2 + WAa * pnow * (1 - pnow)) / (WAA * pnow**2 + WAa * 2 * pnow * (1 - pnow) + Waa * (1 - pnow)**2) #update p(t+1) yield pnow, pnext #current value of p(t) and p(t+1) pnow = pnext #update p(t) t += 1 #update t # Build function for generating figure def plot_diploid_selection(WAA, WAa, Waa, ax=None, p0=0.5): pt = sympy.symbols('pt') #define our variable p(t) # Write out sympy equation f = (WAA * pt**2 + WAa * pt * (1- pt) ) / (WAA * pt**2 + WAa * 2 * pt * (1 - pt) + Waa * (1 - pt)**2) #the recursion equation # Compute function over a set of points in [0,1] by 'lambdifying' sympy equation x = np.linspace(0,1,100) fy = sympy.lambdify(pt, f)(x) # Build plot if ax == None: fig, ax = plt.subplots() # Add cobweb cobweb = np.array([p for p in cobweb_diploid(p0, WAA, WAa, Waa, max=100)]) ax.plot(cobweb[:,0], cobweb[:,1]) # Annotate and label plot ax.plot(x, fy, color='black', label=f\"$W_A$$_A$ = {WAA}, $W_A$$_a$ = {WAa}, $W_a$$_a$ = {Waa}\") ax.plot(x, x, color='black', linestyle='--') ax.set_xlim(0,1) ax.set_ylim(0,1) ax.set_xlabel(\"allele frequency at $t$, $p_t$\") ax.set_ylabel(\"allele frequency at $t+1$, $p_{t+1}$\") ax.legend(frameon=False) return ax # Plot figure fig, ax = plt.subplots(1,2) fig.set_size_inches(12,4) # First cobweb from low starting condition plot_diploid_selection(WAA=1, WAa=2, Waa=1, p0=0.05, ax=ax[0]) # Second cobweb from high starting condition plot_diploid_selection(WAA=1, WAa=2, Waa=1, p0=0.95, ax=ax[1]) plt.show() What is the stable equilibrium in this case?","title":"Diploid selection"},{"location":"lectures/lecture-05/#other-models","text":"We can do something very similar for difference and differential equations. Now we plot the change in the variable as a function of the current value of the variable, e.g., plot \\(dn/dt\\) as a function of \\(n\\) . For example, in our model of haploid selection we have \\[ \\frac{\\mathrm{d}p}{\\mathrm{d}t} = sp(1-p) \\] and our plot looks like: # Initialize sympy symbols p0, s, t = sympy.symbols('p0, s, t') p = sympy.Function('t') # Specify differential equation diffeq = sympy.Eq(p(t).diff(t), s * p(t) * (1 - p(t))) # Convert differential equation RHS to pythonic function dp = sympy.lambdify((s, p(t)), diffeq.rhs) # Plot the curve fig, ax = plt.subplots() for s_coeff in [0.01, -0.01]: ax.plot( np.linspace(0, 1, 100), dp(s_coeff, np.linspace(0,1, 100)), label=f\"s = {s_coeff}\" ) ax.set_xlabel('allele frequency at $t, p$') ax.set_ylabel('change in allele frequency, $\\mathrm{d}p/\\mathrm{d}t$') ax.legend(frameon=False) plt.show() What does this tell us about how allele frequency will change when \\(s>0\\) vs. \\(s<0\\) ? And what allele frequencies, \\(p\\) , cause more rapid evolution? In this week's lab we'll plot the continuous logistic growth model, which shows some more complex dynamics.","title":"Other models"},{"location":"lectures/lecture-05/#4-summary","text":"To get a feel for our model it is helpful to graph some numerical examples: Plot the variable as a function of time (\"simulate\") Plot the variable (or change in variable) as a function of itself (only works for models with one variable) Next lecture we\u2019ll look at a graphical technique for models with multiple variables...","title":"4. Summary"},{"location":"lectures/lecture-06/","text":"{ requestKernel: true, mountActivateWidget: true, mountStatusWidget: true, binderOptions: { repo: \"tomouellette/executable-cells\", ref: \"main\", binderUrl: \"https://gke.mybinder.org\", }, } Lecture 6: Numerical and graphical techniques II (multivariate) Run notes interactively? Lecture overview Numerical and graphical techniques Phase-line diagrams Phase-plane diagrams 1. Numerical and graphical techniques Last time we talked about two numerical/graphical approaches to get a better understanding of our models: Plotting a variable as a function of time (eg, \\(p_t\\) as a function of \\(t\\) ) Plotting a variable as a function of itself (eg, \\(p_{t+1}\\) as a function of \\(p_t\\) ). The latter works well for models with one variable. Today we\u2019re going to talk about a third numerical technique, a phase-plane diagram , which is especially useful for models that have two variables. 2. Phase-line diagrams Before looking at models with two variables, let\u2019s first consider some with only one. Consider again haploid selection where \\[ p_{t+1} = \\frac{W_Ap_t}{W_Ap_t + W_a(1-p_t)} \\] Last time we plotted \\(p_{t + 1}\\) as a function of \\(p_t\\) and used this to examine the dynamics starting from any initial value. We called this plot a cob-web plot. import sympy import numpy as np import matplotlib.pyplot as plt # Build cobweb plotting function def cobweb_haploid(p0, WA, Wa, max=np.inf): t, pnow, pnext = 0, p0, 0 #initial conditions while t < = max: yield pnow, pnext #current value of p_t and p_(t+1) pnext = (WA * pnow) / (WA * pnow + Wa * (1 - pnow)) #update p_(t+1) yield pnow, pnext #current value of p_t and p_(t+1) pnow = pnext #update p_t t += 1 #update t # Build function for generating figure def plot_haploid_selection(WA, Wa, p0=0.5, ax=None): pt = sympy.symbols('pt') #define our variable p_t # Write out sympy equation f = (WA * pt) / (WA * pt + Wa * (1 - pt)) #the recursion equation # Compute function over a set of points in [0,1] by 'lambdifying' sympy equation (turn it into a function) t = np.linspace(0,1,100) fy = sympy.lambdify(pt, f)(t) # Build plot if ax == None: fig, ax = plt.subplots() ax.plot(t, fy, color='black', label=f\"$W_A$ = {WA}, $W_a$ = {Wa}\") #plot p_(t+1) as function of p_t ax.plot(t, t, color='black', linestyle='--') #draw 1:1 line for reference # Add cobweb cobweb = np.array([p for p in cobweb_haploid(p0, WA, Wa, max=100)]) ax.plot(cobweb[:,0], cobweb[:,1]) # Annotate and label plot ax.set_xlim(0,1) ax.set_ylim(0,1) ax.set_xlabel(\"allele frequency at $t$, $p_t$\") ax.set_ylabel(\"allele frequency at $t+1$, $p_{t+1}$\") ax.legend(frameon=False) return ax # Plot figure fig, ax = plt.subplots(1,2) fig.set_size_inches(12,4) # First cobweb with WA > Wa plot_haploid_selection(WA = 1, Wa = 0.5, ax=ax[0]) # Second cobweb with WA < Wa plot_haploid_selection(WA = 0.5, Wa = 1, ax=ax[1]) plt.show() Now let's simplify the cob-web plot and just indicate the direction (and magnitude) of change in \\(p_t\\) with time. This is known as a phase-line diagram with a vector field (the arrows). def phase_line_haploid(p0, WA, Wa, max=np.inf): 'generator for p_t' t, pnow, pnext = 0, p0, 0 #initial conditions while t < max: yield pnow #current value of p_t and p_(t+1) pnext = (WA * pnow) / (WA * pnow + Wa * (1 - pnow)) pnow = pnext #update p(t) t += 1 #update t def plot_phase_line_haploid(WA, Wa, p0, max=20, ax=None): 'plot phase line' # Set up figure if ax==None: fig, ax = plt.subplots() fig.set_size_inches(8,0.25) ax.axhline(0, color='black', linewidth=0.5) # Plot phase-line pts = [pt for pt in phase_line_haploid(p0, WA, Wa, max=max)] #pt values ax.plot( pts, np.zeros(max) #dummy y values (0 for all x values) because we want to plot a 1d line ) # Plot vector field marker = '>' if pts[2] > pts[1] else ' < ' #determine which direction to point based on first 2 time points ax.scatter( pts, np.zeros(max),#dummy y again marker=marker, s=150 ) # Remove background axes ax.set_ylabel('$p$', rotation=0) ax.set_xlabel(f\"$W_A$ = {WA}, $W_a$ = {Wa}, $p_0$ = {p0}\") ax.get_yaxis().set_ticks([]) ax.spines['top'].set_visible(False) ax.spines['right'].set_visible(False) ax.spines['bottom'].set_visible(False) ax.spines['left'].set_visible(False) ax.set_xlim(0,1) plt.show() plot_phase_line_haploid(WA=1, Wa=0.5, p0=0.01) plot_phase_line_haploid(WA=0.5, Wa=1, p0=0.99) As in the cob-web plots, we see the allele frequency approaches \\(p=1\\) when \\(W_A>W_a\\) and \\(p=0\\) when \\(W_a>W_A\\) . We also notice, as above, the changes are fastest (fewer, longer arrows) at intermediate frequencies. Similarly, with the more complex model of diploid selection \\[ p_{t+1} = \\frac{W_{AA}p_t^2 + W_{Aa}p_tq_t}{W_{AA}p_t^2 + W_{Aa}p_tq_t + W_{aa}q_t^2} \\] we can draw a phase-line diagram and vector field for a set of parameter values. def phase_line_diploid(p0, WAA, WAa, Waa, max=np.inf): 'generator for p_t' t, pnow, pnext = 0, p0, 0 #initial conditions while t < max: yield pnow #current value of p(t) and p(t+1) pnext = (WAA * pnow**2 + WAa * pnow * (1 - pnow)) / (WAA * pnow**2 + WAa * 2 * pnow * (1 - pnow) + Waa * (1 - pnow)**2) #update p(t+1) pnow = pnext #update p(t) t += 1 #update t def plot_phase_line_diploid(WAA, WAa, Waa, p0, max=20, ax=None): 'plot phase line' # set up figure if ax==None: fig, ax = plt.subplots() fig.set_size_inches(8,0.25) ax.axhline(0, color='black', linewidth=0.5) # Plot phase-line pts = [pt for pt in phase_line_diploid(p0, WAA, WAa, Waa, max=max)] ax.plot( pts, np.zeros(max), alpha=1 ) # Plot phase-line markers marker = '>' if pts[2] > pts[1] else ' < ' ax.scatter( pts, np.zeros(max), marker=marker, s=150 ) ax.set_xlabel(f\"$WAA$ = {WAA}, $WAa$ = {WAa}, $Waa$ = {Waa}, $p_0$ = {p0}\") return ax # Plot figure fig, ax = plt.subplots() fig.set_size_inches(8,0.25) plot_phase_line_diploid(WAA=1, WAa=2, Waa=1, p0=0.99, max=100, ax=ax) #higher starting allele frequency plot_phase_line_diploid(WAA=1, WAa=2, Waa=1, p0=0.01, max=100, ax=ax) #low starting allele frequency # Remove background axes ax.set_ylabel('$p$', rotation=0) ax.get_yaxis().set_ticks([]) ax.spines['top'].set_visible(False) ax.spines['right'].set_visible(False) ax.spines['bottom'].set_visible(False) ax.spines['left'].set_visible(False) ax.set_xlim(0,1) plt.show() Notice that this time we chose two initial frequencies for the same plot, to show that under heterozygote advantage ( \\(W_{AA}<W_{Aa}>W_{aa}\\) ) the allele frequency approaches an intermediate value from either direction. 3. Phase-plane diagrams Now let\u2019s extend this technique from one to two variables. Lotka-Volterra model And let\u2019s introduce a new model for this purpose, the Lotka-Volterra model of competition (see section 3.4.1 in the text). This is an extension of the logistic growth model to include competition between multiple species (in our case two). Let the population size of each species be \\(n_1(t)\\) and \\(n_2(t)\\) . These are our two variables. And let them have different intrinsic growth rates, \\(r_1\\) and \\(r_2\\) , and carrying capacities, \\(K_1\\) and \\(K_2\\) . To model competition, we\u2019ll assume that, for an individual of species \\(i\\) , an individual of species \\(j\\) is the competitive equivalent of \\(\\alpha_{ij}\\) individuals of species \\(i\\) . We then have \\[ n_1(t+1) = n_1(t)\\left( 1 + r_1 \\left(1 - \\frac{n_1(t) + \\alpha_{12}n_2(t)}{K_1}\\right)\\right) \\] \\[ n_2(t+1) = n_2(t) \\left(1 + r_2 \\left(1 - \\frac{n_2(t) + \\alpha_{21}n_1(t)}{K_2}\\right)\\right) \\] Often individuals of the same species will use more similar resources and therefore competition will be less severe with individuals of the other species, \\(0 < \\alpha_{ij} < 1\\) , but not always. And, in fact, we could model other types of interactions (eg, mutualism) by making some of the interactions beneficial, \\(\\alpha_{ij} < 0\\) . Phase-planes and vector fields So why did we introduce the Lotka-Volterra model? Well, phase-plane diagrams are plots of one variable against another ( \\(n_1\\) vs. \\(n_2\\) ), on which we can plot vector fields , vectors originating from many different starting conditions that indicate the direction and magnitude of change in the two variables. With this we can graphically investigate the dynamics of the Lotka-Volterra model by first defining the rates of change \\(\\Delta\\) in both \\(n_1\\) and \\(n_2\\) and then choosing some parameter values to explore. \\[ \\Delta n_1 \\equiv n_1(t+1) - n_1(t) = n_1(t)r_1\\left(1 - \\frac{n_1(t) + \\alpha_{12}n_2(t)}{K_1}\\right) \\] \\[ \\Delta n_2 \\equiv n_2(t+1) - n_2(t) = n_2(t)r_2\\left(1 - \\frac{n_2(t) + \\alpha_{21}n_1(t)}{K_2}\\right) \\] Let's explore the Lotka-Volterra with the following parameter values: \\(r_1 = 0.5, r_2 = 0.5, K_1 = 1000, K_2 = 1000, \\alpha_{12} = 0.0, \\alpha_{21} = 0.5\\) . # Define a function to plot the phase plane and vector field for n1 and n2 def plot_vector_field(dn1, dn2, xlim=(0,1200), ylim=(0,1200), n_steps=25, width=8, height=6, show=False, axes_labels=[None, None]): # Set x and y ranges xrange, yrange = np.linspace(xlim[0], xlim[1], n_steps), np.linspace(ylim[0], ylim[1], n_steps) # Initialize 2D grid with x,y values and additional grids to track derivatives X, Y = np.meshgrid(xrange, yrange) U, V = np.zeros(X.shape), np.zeros(Y.shape) # Compute the gradient at each x,y position for i in range(len(xrange)): for j in range(len(xrange)): U[i,j] = sympy.lambdify((n1, n2), dn1)(X[i,j], Y[i,j]) #change in n1 V[i,j] = sympy.lambdify((n1, n2), dn2)(X[i,j], Y[i,j]) #change in n2 # Plot figure fig, ax = plt.subplots() fig.set_size_inches(width, height) ax.set_xlabel(axes_labels[0]) ax.set_ylabel(axes_labels[1]) ax.quiver(X,Y,U,V, linewidth=1) #from point X,Y draw arrow moving U in x-axis and V in y-axis if show == True: plt.show() else: return ax # Initialize the sympy variables n1, n2 = sympy.symbols('n1, n2') # Choose the parameter values r1, r2 = 0.5, 0.5 k1, k2 = 1000, 1000 a12, a21 = 0, 0.5 # Specify the difference equations dn1 = r1 * n1 * (1 - (n1 + a12 * n2) / k1) dn2 = r2 * n2 * (1 - (n2 + a21 * n1) / k2) # Plot the vector field plot_vector_field(dn1, dn2, axes_labels=[\"number of species 1, $n_1$\", \"number of species 2, $n_2$\"]) plt.show() With this approach we see that the dynamics appear to be approaching a value near \\(n_1 = 1000, n_2 = 500\\) from nearly any initial condition. Null clines To better understand the dynamics, we can ask for what values of our variables ( \\(n_1, n_2\\) ) is the change inour variables zero ( \\(\\Delta n_1 = 0\\) , \\(\\Delta n_2 = 0\\) ). These values are known as null clines . Concretely, going back to our previous formula for the change in \\(n_1\\) and \\(n_2\\) in the Lotka-Volterra model \\[ \\Delta n_1 = n_1(t)r_1(1 - \\frac{n_1(t) + \\alpha_{12}n_2(t)}{K_1}) \\] \\[ \\Delta n_2 = n_2(t)r_2(1 - \\frac{n_2(t) + \\alpha_{21}n_1(t)}{K_2}) \\] We want to know when \\(\\Delta n_1\\) and \\(\\Delta n_2\\) are 0. Solving for these inequalities shows that \\[ \\Delta n_1 = 0 \\Longrightarrow n_1(t) = 0, 1 - \\frac{n_1(t) + \\alpha_{12}n_2(t)}{K_1} = 0 \\] \\[ \\Delta n_2 = 0 \\Longrightarrow n_2(t) = 0, 1 - \\frac{n_2(t) + \\alpha_{21}n_1(t)}{K_2} = 0 \\] Plotting these null clines on the phase-plane diagram, we get # Initialize plot and ranges ax = plot_vector_field(dn1, dn2, axes_labels=[\"number of species 1, $n_1$\", \"number of species 2, $n_2$\"]) xrange, yrange = np.linspace(0, 1200, 100), np.linspace(0, 1200, 100) #plot the null clines for species 1 (blue) def plot_nullclines(ax): nullcline_1 = list(sympy.solve(sympy.Eq(dn1, 0))) ax.plot([nullcline_1[0] for i in range(len(xrange))], yrange, color='b') ax.plot([nullcline_1[1] for i in range(len(xrange))], yrange, color='b') # #plot the null clines for species 2 (red) nullcline_2 = [list(i.values())[0] for i in sympy.solve(sympy.Eq(dn2, 0))] ax.plot(sympy.lambdify(n2, nullcline_2[0])(yrange), yrange, color='r') # A this null cline is a function of n2 (i.e. y) ax.plot(xrange, [nullcline_2[1] for i in range(len(yrange))], color='r') ax.set_ylim(-10, 1210) ax.set_xlim(-10, 1210) return ax plot_nullclines(ax) plt.show() The null clines help us understand the dynamics. In each area bounded by null clines the arrows point in the same general direction (eg, in the top right area they point down and to the left). This helps us see where the dynamics are heading -- in this case most initial conditions head to the intersection of the null clines for \\(n_1\\) and \\(n_2\\) (red and blue), i.e., where the change in both our variables is zero, near \\(n_1=1000\\) and \\(n_2=500\\) . We can also make phase diagrams for continuous-time models, just using differential equations in place of difference equations. We\u2019ll see an example of that for another model, of predator and prey, in this week\u2019s lab.","title":"Lecture 6"},{"location":"lectures/lecture-06/#lecture-6-numerical-and-graphical-techniques-ii-multivariate","text":"Run notes interactively?","title":"Lecture 6: Numerical and graphical techniques II (multivariate)"},{"location":"lectures/lecture-06/#lecture-overview","text":"Numerical and graphical techniques Phase-line diagrams Phase-plane diagrams","title":"Lecture overview"},{"location":"lectures/lecture-06/#1-numerical-and-graphical-techniques","text":"Last time we talked about two numerical/graphical approaches to get a better understanding of our models: Plotting a variable as a function of time (eg, \\(p_t\\) as a function of \\(t\\) ) Plotting a variable as a function of itself (eg, \\(p_{t+1}\\) as a function of \\(p_t\\) ). The latter works well for models with one variable. Today we\u2019re going to talk about a third numerical technique, a phase-plane diagram , which is especially useful for models that have two variables.","title":"1. Numerical and graphical techniques"},{"location":"lectures/lecture-06/#2-phase-line-diagrams","text":"Before looking at models with two variables, let\u2019s first consider some with only one. Consider again haploid selection where \\[ p_{t+1} = \\frac{W_Ap_t}{W_Ap_t + W_a(1-p_t)} \\] Last time we plotted \\(p_{t + 1}\\) as a function of \\(p_t\\) and used this to examine the dynamics starting from any initial value. We called this plot a cob-web plot. import sympy import numpy as np import matplotlib.pyplot as plt # Build cobweb plotting function def cobweb_haploid(p0, WA, Wa, max=np.inf): t, pnow, pnext = 0, p0, 0 #initial conditions while t < = max: yield pnow, pnext #current value of p_t and p_(t+1) pnext = (WA * pnow) / (WA * pnow + Wa * (1 - pnow)) #update p_(t+1) yield pnow, pnext #current value of p_t and p_(t+1) pnow = pnext #update p_t t += 1 #update t # Build function for generating figure def plot_haploid_selection(WA, Wa, p0=0.5, ax=None): pt = sympy.symbols('pt') #define our variable p_t # Write out sympy equation f = (WA * pt) / (WA * pt + Wa * (1 - pt)) #the recursion equation # Compute function over a set of points in [0,1] by 'lambdifying' sympy equation (turn it into a function) t = np.linspace(0,1,100) fy = sympy.lambdify(pt, f)(t) # Build plot if ax == None: fig, ax = plt.subplots() ax.plot(t, fy, color='black', label=f\"$W_A$ = {WA}, $W_a$ = {Wa}\") #plot p_(t+1) as function of p_t ax.plot(t, t, color='black', linestyle='--') #draw 1:1 line for reference # Add cobweb cobweb = np.array([p for p in cobweb_haploid(p0, WA, Wa, max=100)]) ax.plot(cobweb[:,0], cobweb[:,1]) # Annotate and label plot ax.set_xlim(0,1) ax.set_ylim(0,1) ax.set_xlabel(\"allele frequency at $t$, $p_t$\") ax.set_ylabel(\"allele frequency at $t+1$, $p_{t+1}$\") ax.legend(frameon=False) return ax # Plot figure fig, ax = plt.subplots(1,2) fig.set_size_inches(12,4) # First cobweb with WA > Wa plot_haploid_selection(WA = 1, Wa = 0.5, ax=ax[0]) # Second cobweb with WA < Wa plot_haploid_selection(WA = 0.5, Wa = 1, ax=ax[1]) plt.show() Now let's simplify the cob-web plot and just indicate the direction (and magnitude) of change in \\(p_t\\) with time. This is known as a phase-line diagram with a vector field (the arrows). def phase_line_haploid(p0, WA, Wa, max=np.inf): 'generator for p_t' t, pnow, pnext = 0, p0, 0 #initial conditions while t < max: yield pnow #current value of p_t and p_(t+1) pnext = (WA * pnow) / (WA * pnow + Wa * (1 - pnow)) pnow = pnext #update p(t) t += 1 #update t def plot_phase_line_haploid(WA, Wa, p0, max=20, ax=None): 'plot phase line' # Set up figure if ax==None: fig, ax = plt.subplots() fig.set_size_inches(8,0.25) ax.axhline(0, color='black', linewidth=0.5) # Plot phase-line pts = [pt for pt in phase_line_haploid(p0, WA, Wa, max=max)] #pt values ax.plot( pts, np.zeros(max) #dummy y values (0 for all x values) because we want to plot a 1d line ) # Plot vector field marker = '>' if pts[2] > pts[1] else ' < ' #determine which direction to point based on first 2 time points ax.scatter( pts, np.zeros(max),#dummy y again marker=marker, s=150 ) # Remove background axes ax.set_ylabel('$p$', rotation=0) ax.set_xlabel(f\"$W_A$ = {WA}, $W_a$ = {Wa}, $p_0$ = {p0}\") ax.get_yaxis().set_ticks([]) ax.spines['top'].set_visible(False) ax.spines['right'].set_visible(False) ax.spines['bottom'].set_visible(False) ax.spines['left'].set_visible(False) ax.set_xlim(0,1) plt.show() plot_phase_line_haploid(WA=1, Wa=0.5, p0=0.01) plot_phase_line_haploid(WA=0.5, Wa=1, p0=0.99) As in the cob-web plots, we see the allele frequency approaches \\(p=1\\) when \\(W_A>W_a\\) and \\(p=0\\) when \\(W_a>W_A\\) . We also notice, as above, the changes are fastest (fewer, longer arrows) at intermediate frequencies. Similarly, with the more complex model of diploid selection \\[ p_{t+1} = \\frac{W_{AA}p_t^2 + W_{Aa}p_tq_t}{W_{AA}p_t^2 + W_{Aa}p_tq_t + W_{aa}q_t^2} \\] we can draw a phase-line diagram and vector field for a set of parameter values. def phase_line_diploid(p0, WAA, WAa, Waa, max=np.inf): 'generator for p_t' t, pnow, pnext = 0, p0, 0 #initial conditions while t < max: yield pnow #current value of p(t) and p(t+1) pnext = (WAA * pnow**2 + WAa * pnow * (1 - pnow)) / (WAA * pnow**2 + WAa * 2 * pnow * (1 - pnow) + Waa * (1 - pnow)**2) #update p(t+1) pnow = pnext #update p(t) t += 1 #update t def plot_phase_line_diploid(WAA, WAa, Waa, p0, max=20, ax=None): 'plot phase line' # set up figure if ax==None: fig, ax = plt.subplots() fig.set_size_inches(8,0.25) ax.axhline(0, color='black', linewidth=0.5) # Plot phase-line pts = [pt for pt in phase_line_diploid(p0, WAA, WAa, Waa, max=max)] ax.plot( pts, np.zeros(max), alpha=1 ) # Plot phase-line markers marker = '>' if pts[2] > pts[1] else ' < ' ax.scatter( pts, np.zeros(max), marker=marker, s=150 ) ax.set_xlabel(f\"$WAA$ = {WAA}, $WAa$ = {WAa}, $Waa$ = {Waa}, $p_0$ = {p0}\") return ax # Plot figure fig, ax = plt.subplots() fig.set_size_inches(8,0.25) plot_phase_line_diploid(WAA=1, WAa=2, Waa=1, p0=0.99, max=100, ax=ax) #higher starting allele frequency plot_phase_line_diploid(WAA=1, WAa=2, Waa=1, p0=0.01, max=100, ax=ax) #low starting allele frequency # Remove background axes ax.set_ylabel('$p$', rotation=0) ax.get_yaxis().set_ticks([]) ax.spines['top'].set_visible(False) ax.spines['right'].set_visible(False) ax.spines['bottom'].set_visible(False) ax.spines['left'].set_visible(False) ax.set_xlim(0,1) plt.show() Notice that this time we chose two initial frequencies for the same plot, to show that under heterozygote advantage ( \\(W_{AA}<W_{Aa}>W_{aa}\\) ) the allele frequency approaches an intermediate value from either direction.","title":"2. Phase-line diagrams"},{"location":"lectures/lecture-06/#3-phase-plane-diagrams","text":"Now let\u2019s extend this technique from one to two variables.","title":"3. Phase-plane diagrams"},{"location":"lectures/lecture-06/#lotka-volterra-model","text":"And let\u2019s introduce a new model for this purpose, the Lotka-Volterra model of competition (see section 3.4.1 in the text). This is an extension of the logistic growth model to include competition between multiple species (in our case two). Let the population size of each species be \\(n_1(t)\\) and \\(n_2(t)\\) . These are our two variables. And let them have different intrinsic growth rates, \\(r_1\\) and \\(r_2\\) , and carrying capacities, \\(K_1\\) and \\(K_2\\) . To model competition, we\u2019ll assume that, for an individual of species \\(i\\) , an individual of species \\(j\\) is the competitive equivalent of \\(\\alpha_{ij}\\) individuals of species \\(i\\) . We then have \\[ n_1(t+1) = n_1(t)\\left( 1 + r_1 \\left(1 - \\frac{n_1(t) + \\alpha_{12}n_2(t)}{K_1}\\right)\\right) \\] \\[ n_2(t+1) = n_2(t) \\left(1 + r_2 \\left(1 - \\frac{n_2(t) + \\alpha_{21}n_1(t)}{K_2}\\right)\\right) \\] Often individuals of the same species will use more similar resources and therefore competition will be less severe with individuals of the other species, \\(0 < \\alpha_{ij} < 1\\) , but not always. And, in fact, we could model other types of interactions (eg, mutualism) by making some of the interactions beneficial, \\(\\alpha_{ij} < 0\\) .","title":"Lotka-Volterra model"},{"location":"lectures/lecture-06/#phase-planes-and-vector-fields","text":"So why did we introduce the Lotka-Volterra model? Well, phase-plane diagrams are plots of one variable against another ( \\(n_1\\) vs. \\(n_2\\) ), on which we can plot vector fields , vectors originating from many different starting conditions that indicate the direction and magnitude of change in the two variables. With this we can graphically investigate the dynamics of the Lotka-Volterra model by first defining the rates of change \\(\\Delta\\) in both \\(n_1\\) and \\(n_2\\) and then choosing some parameter values to explore. \\[ \\Delta n_1 \\equiv n_1(t+1) - n_1(t) = n_1(t)r_1\\left(1 - \\frac{n_1(t) + \\alpha_{12}n_2(t)}{K_1}\\right) \\] \\[ \\Delta n_2 \\equiv n_2(t+1) - n_2(t) = n_2(t)r_2\\left(1 - \\frac{n_2(t) + \\alpha_{21}n_1(t)}{K_2}\\right) \\] Let's explore the Lotka-Volterra with the following parameter values: \\(r_1 = 0.5, r_2 = 0.5, K_1 = 1000, K_2 = 1000, \\alpha_{12} = 0.0, \\alpha_{21} = 0.5\\) . # Define a function to plot the phase plane and vector field for n1 and n2 def plot_vector_field(dn1, dn2, xlim=(0,1200), ylim=(0,1200), n_steps=25, width=8, height=6, show=False, axes_labels=[None, None]): # Set x and y ranges xrange, yrange = np.linspace(xlim[0], xlim[1], n_steps), np.linspace(ylim[0], ylim[1], n_steps) # Initialize 2D grid with x,y values and additional grids to track derivatives X, Y = np.meshgrid(xrange, yrange) U, V = np.zeros(X.shape), np.zeros(Y.shape) # Compute the gradient at each x,y position for i in range(len(xrange)): for j in range(len(xrange)): U[i,j] = sympy.lambdify((n1, n2), dn1)(X[i,j], Y[i,j]) #change in n1 V[i,j] = sympy.lambdify((n1, n2), dn2)(X[i,j], Y[i,j]) #change in n2 # Plot figure fig, ax = plt.subplots() fig.set_size_inches(width, height) ax.set_xlabel(axes_labels[0]) ax.set_ylabel(axes_labels[1]) ax.quiver(X,Y,U,V, linewidth=1) #from point X,Y draw arrow moving U in x-axis and V in y-axis if show == True: plt.show() else: return ax # Initialize the sympy variables n1, n2 = sympy.symbols('n1, n2') # Choose the parameter values r1, r2 = 0.5, 0.5 k1, k2 = 1000, 1000 a12, a21 = 0, 0.5 # Specify the difference equations dn1 = r1 * n1 * (1 - (n1 + a12 * n2) / k1) dn2 = r2 * n2 * (1 - (n2 + a21 * n1) / k2) # Plot the vector field plot_vector_field(dn1, dn2, axes_labels=[\"number of species 1, $n_1$\", \"number of species 2, $n_2$\"]) plt.show() With this approach we see that the dynamics appear to be approaching a value near \\(n_1 = 1000, n_2 = 500\\) from nearly any initial condition.","title":"Phase-planes and vector fields"},{"location":"lectures/lecture-06/#null-clines","text":"To better understand the dynamics, we can ask for what values of our variables ( \\(n_1, n_2\\) ) is the change inour variables zero ( \\(\\Delta n_1 = 0\\) , \\(\\Delta n_2 = 0\\) ). These values are known as null clines . Concretely, going back to our previous formula for the change in \\(n_1\\) and \\(n_2\\) in the Lotka-Volterra model \\[ \\Delta n_1 = n_1(t)r_1(1 - \\frac{n_1(t) + \\alpha_{12}n_2(t)}{K_1}) \\] \\[ \\Delta n_2 = n_2(t)r_2(1 - \\frac{n_2(t) + \\alpha_{21}n_1(t)}{K_2}) \\] We want to know when \\(\\Delta n_1\\) and \\(\\Delta n_2\\) are 0. Solving for these inequalities shows that \\[ \\Delta n_1 = 0 \\Longrightarrow n_1(t) = 0, 1 - \\frac{n_1(t) + \\alpha_{12}n_2(t)}{K_1} = 0 \\] \\[ \\Delta n_2 = 0 \\Longrightarrow n_2(t) = 0, 1 - \\frac{n_2(t) + \\alpha_{21}n_1(t)}{K_2} = 0 \\] Plotting these null clines on the phase-plane diagram, we get # Initialize plot and ranges ax = plot_vector_field(dn1, dn2, axes_labels=[\"number of species 1, $n_1$\", \"number of species 2, $n_2$\"]) xrange, yrange = np.linspace(0, 1200, 100), np.linspace(0, 1200, 100) #plot the null clines for species 1 (blue) def plot_nullclines(ax): nullcline_1 = list(sympy.solve(sympy.Eq(dn1, 0))) ax.plot([nullcline_1[0] for i in range(len(xrange))], yrange, color='b') ax.plot([nullcline_1[1] for i in range(len(xrange))], yrange, color='b') # #plot the null clines for species 2 (red) nullcline_2 = [list(i.values())[0] for i in sympy.solve(sympy.Eq(dn2, 0))] ax.plot(sympy.lambdify(n2, nullcline_2[0])(yrange), yrange, color='r') # A this null cline is a function of n2 (i.e. y) ax.plot(xrange, [nullcline_2[1] for i in range(len(yrange))], color='r') ax.set_ylim(-10, 1210) ax.set_xlim(-10, 1210) return ax plot_nullclines(ax) plt.show() The null clines help us understand the dynamics. In each area bounded by null clines the arrows point in the same general direction (eg, in the top right area they point down and to the left). This helps us see where the dynamics are heading -- in this case most initial conditions head to the intersection of the null clines for \\(n_1\\) and \\(n_2\\) (red and blue), i.e., where the change in both our variables is zero, near \\(n_1=1000\\) and \\(n_2=500\\) . We can also make phase diagrams for continuous-time models, just using differential equations in place of difference equations. We\u2019ll see an example of that for another model, of predator and prey, in this week\u2019s lab.","title":"Null clines"},{"location":"lectures/lecture-07/","text":"{ requestKernel: true, mountActivateWidget: true, mountStatusWidget: true, binderOptions: { repo: \"tomouellette/executable-cells\", ref: \"main\", binderUrl: \"https://gke.mybinder.org\", }, } Lecture 7: Equilibria Run notes interactively? Lecture overview Equilibria Exponential growth Logistic growth Haploid selection Diploid selection Summary 1. Equilibria An equilibrium is any state of a system which tends to persist unchanged over time. For discrete-time models, the equilibria are defined as those values of the variables where no changes occur from one time step to the next. For example, those values of allele frequency \\(p_t\\) where \\[ \\begin{aligned} \\Delta p &= 0\\\\ p_{t+1} - p_t &= 0\\\\ p_{t+1} &= p_t \\end{aligned} \\] Similarly, for continuous-time models, the equilibria are defined as those values of the variables for which the rate of change in the variables equals zero. For example, those values of allele frequency \\(p\\) where \\[ \\frac{\\mathrm{d}p}{\\mathrm{d}t} = 0 \\] What are the equilibria for the following models? Model Discrete time Continous time Exponential growth \\(n_{t+1} = R n_t\\) \\(\\frac{\\mathrm{d}n}{\\mathrm{d}t} = r n\\) Logistic growth \\(n_{t+1} = (1 + r(1 - \\frac{n_t}{K}))n_t\\) \\(\\frac{\\mathrm{d}n}{\\mathrm{d}t} = r(1 - \\frac{n}{K})n\\) Haploid selection \\(p_{t+1} = \\frac{W_A p_t}{W_A p_t + W_a q_t}\\) \\(\\frac{\\mathrm{d}p}{\\mathrm{d}t} = s p(1-p)\\) Diploid selection \\(p_{t+1} = \\frac{p_t^2W_{AA} + p_t q_tW_{Aa}}{p_t^2W_{AA} + 2 p_t q_tW_{Aa} + q_t^2W_{aa}}\\) Not derived 2. Exponential growth Here, we will solve for the equilibria in both the discrete- and continuous-time exponential-growth models. Discrete time \\[ n_{t+1} = Rn_t \\] Set \\(n_{t+1} = n_t = \\hat n\\) and solve for \\(\\hat{n}\\) \\[ \\begin{aligned} \\hat n &= R\\hat n\\\\ \\hat n &= 0 \\end{aligned} \\] Continuous time \\[ \\frac{\\mathrm{d}n}{\\mathrm{d}t} = r n \\] Set \\(\\mathrm{d}n/\\mathrm{d}t = 0\\) and \\(n = \\hat n\\) and solve for \\(\\hat n\\) \\[ \\begin{aligned} 0 &= r \\hat{n}\\\\ \\hat n &= 0 \\end{aligned} \\] So the only equilibrium in both discrete- and continuous-time exponential growth is extinction, \\(\\hat{n}=0\\) . Special case of parameters Notice above that \\(R=1\\) and \\(r=0\\) also satisfy the conditions for an equilibrium. These are called special cases of parameters . Here this refers to the case where individuals perfectly replace themselves so that the population remains constant from any starting value of \\(n\\) . 3. Logistic growth Here, we will solve for the equilibria in both the discrete- and continuous-time logistic-growth models. Discrete time \\[ n_{t+1} = \\left(1 + r\\left(1 - \\frac{n_t}{K}\\right)\\right)n_t \\] As above, we substitute \\(n_{t+1} = n_t = \\hat n\\) and want to solve for \\(\\hat{n}\\) . \\[ \\hat n = \\left(1 + r\\left(1 - \\frac{\\hat n}{K}\\right)\\right)\\hat{n} \\] Notice that one equilibrium is \\(\\hat n = 0\\) . However, this isn't the only equilibrium because dividing both sides by \\(\\hat n\\) results in \\[ \\begin{aligned} 1 &= 1 + r\\left(1 - \\frac{\\hat n}{K}\\right)\\\\ 0 &= r\\left(1 - \\frac{\\hat n}{K}\\right) \\end{aligned} \\] Here we have a special case of parameters, \\(r=0\\) , or \\[ \\begin{aligned} 0 &= 1 - \\frac{\\hat n}{K}\\\\ \\hat n &= K \\end{aligned} \\] There are therefore two equilibria: extinction, \\(\\hat{n}=0\\) , or carrying capacity, \\(\\hat{n}=K\\) . Continuous time \\[ \\frac{\\mathrm{d}n}{\\mathrm{d}t} = r \\left(1 - \\frac{n}{K}\\right)n \\] We set \\(\\mathrm{d}n/\\mathrm{d}t=0\\) and \\(n=\\hat{n}\\) \\[ 0 = r \\left(1 - \\frac{\\hat n}{K}\\right)\\hat{n} \\] which is the same equation we had above in discrete-time, so the equilibria ( \\(\\hat n = 0,K\\) ) and the special case of parameters ( \\(r = 0\\) ) are also the same. 4. Haploid selection Here, we will solve for the equilibria in both the discrete- and continuous-time haploid-selection models. Discrete time \\[ p_{t+1} = \\frac{p_tW_A}{p_tW_A + q_tW_a} \\] Replace \\(p_{t+1}\\) and \\(p_t\\) with \\(\\hat p\\) and replace \\(q_t\\) with \\(\\hat q\\) and solve for \\(\\hat p\\) and \\(\\hat q\\) \\[ \\begin{aligned} \\hat{p} &= \\frac{\\hat p W_A}{\\hat p W_A + \\hat q W_a}\\\\ \\end{aligned} \\] We first see that \\(\\hat{p}=0\\) is an equilibrium. But there is more, since dividing by \\(\\hat p\\) gives \\[ \\begin{aligned} 1 &= \\frac{W_A}{\\hat p W_A + \\hat q W_a}\\\\ \\hat p W_A + \\hat q W_a &= W_A\\\\ \\hat q W_a &= (1-\\hat p) W_A \\end{aligned} \\] At this point we use \\(q=1-p\\) to write this in terms of \\(p\\) only \\[ (1-\\hat p) W_a = (1-\\hat p) W_A \\] So \\(\\hat p =1\\) is another equilibrium. And finally, dividing by \\((1-\\hat p)\\) gives a special case of parameters, \\(W_A=W_a\\) . To summarize, the allele frequency will not change from one generation to the next in our discrete-time haploid-selection model when \\(\\hat p = 0 \\Longrightarrow\\) the population is \"fixed\" for the \\(a\\) allele \\(\\hat p = 1 \\Longrightarrow\\) the population is fixed for the \\(A\\) allele \\(W_A = W_a \\Longrightarrow\\) the two alleles have equal fitness (\"neutrality\") Continuous time \\[ \\frac{\\mathrm{d}p}{\\mathrm{d}t} = sp(1-p) \\] In the continuous-time model, we set the derivative equal to zero and \\(p=\\hat{p}\\) \\[ \\begin{aligned} 0 &= s\\hat p(1 -\\hat p) \\end{aligned} \\] And we again find the same equilibria ( \\(\\hat p=0,1\\) ) and special case of parameters ( \\(s=0\\) , i.e., neutrality). 5. Diploid selection Discrete time Here, we will solve for the equilibria in the discrete-time diploid-selection model \\[ p_{t+1} = \\frac{p_t^2 W_{AA} + p_t q_t W_{Aa}}{p_t^2 W_{AA} + 2 p_t q_t W_{Aa} + q_t^2 W_{aa}} \\] We replace \\(p_{t+1}\\) and \\(p_t\\) with \\(\\hat p\\) and \\(q_t\\) with \\(\\hat{q}\\) and solve for \\(\\hat p\\) and \\(\\hat q\\) \\[ \\begin{aligned} \\hat{p} &= \\frac{\\hat{p}^2 W_{AA} + \\hat{p} \\hat{q} W_{Aa}}{\\hat{p}^2 W_{AA} + 2 \\hat{p} \\hat{q} W_{Aa} + \\hat{q}^2 W_{aa}}\\\\ \\hat{p} &= \\frac{\\hat{p}(\\hat p W_{AA} + \\hat{q} W_{Aa})}{\\hat{p}^2 W_{AA} + 2 \\hat{p} \\hat{q} W_{Aa} + \\hat{q}^2 W_{aa}} \\end{aligned} \\] We see that \\(\\hat{p}=0\\) is one equilibrium. Moving on, dividing by \\(\\hat p\\) gives \\[ \\begin{aligned} 1 &= \\frac{\\hat p W_{AA} + \\hat{q} W_{Aa}}{\\hat{p}^2 W_{AA} + 2 \\hat{p} \\hat{q} W_{Aa} + \\hat{q}^2 W_{aa}}\\\\ \\hat{p}^2 W_{AA} + 2 \\hat{p} \\hat{q} W_{Aa} + \\hat{q}^2 W_{aa} &= \\hat p W_{AA} + \\hat{q} W_{Aa}\\\\ 0 &= (\\hat{p} - \\hat{p}^2) W_{AA} + (\\hat{q} - 2 \\hat{p} \\hat{q}) W_{Aa} - \\hat{q}^2 W_{aa}\\\\ 0 &= \\hat{p}(1 - \\hat{p}) W_{AA} + \\hat{q}(1 - 2 \\hat{p}) W_{Aa} - \\hat{q}^2 W_{aa}\\\\ 0 &= \\hat{q}(\\hat{p} W_{AA} + (1 - 2 \\hat{p}) W_{Aa} - \\hat{q} W_{aa}) \\end{aligned} \\] And so \\(\\hat{q}=0\\implies\\hat{p}=1\\) is another equilibrium. Dividing by \\(\\hat{q}\\) and putting everything in terms of \\(p\\) we have \\[ \\begin{aligned} 0 &= \\hat{p} W_{AA} + (1 - 2 \\hat{p}) W_{Aa} - \\hat{q} W_{aa}\\\\ 0 &= \\hat{p} W_{AA} + (1 - 2 \\hat{p}) W_{Aa} - (1 - \\hat{p}) W_{aa}\\\\ 0 &= \\hat{p}(W_{AA} -2W_{Aa} + W_{aa}) + W_{Aa} - W_{aa}\\\\ W_{aa} - W_{Aa} &= \\hat p(W_{AA} -2W_{Aa} + W_{aa})\\\\ \\frac{W_{Aa} - W_{aa}}{2W_{Aa} - W_{AA} - W_{aa}} &= \\hat p\\\\ \\end{aligned} \\] We therefore have three equilibria under diploid selection: \\(\\hat{p}=0,\\frac{W_{Aa} - W_{aa}}{2W_{Aa} - W_{AA} - W_{aa}},1\\) . Since a frequency is bounded between 0 and 1, we must have \\(0 \\leq p \\leq 1\\) . We therefore call \\(\\hat{p}=0\\) and \\(\\hat{p}=1\\) boundary equilibria . These bounds also imply the third equilibrium is only biologically valid when \\[ 0 \\leq \\frac{W_{Aa} - W_{aa}}{2 W_{Aa} -W_{AA} - W_{aa}} \\leq 1 \\] When \\(W_{Aa} = W_{aa}\\) this equilibrium reduces to \\(\\hat{p}=0\\) and when \\(W_{Aa} = W_{AA}\\) this reduces to \\(\\hat{p}=1\\) (check this for yourself). The third equilibrium will be an internal equilibrium , representing a population with both \\(A\\) and \\(a\\) alleles, when \\[ 0 < \\frac{W_{Aa} - W_{aa}}{2 W_{Aa} -W_{AA} - W_{aa}} < 1 \\] The equilibrium is positive when the numerator and denominator have the same sign (i.e., are both positive or both negative). Let's split this into two \"cases\". Case A will have a positive numerator, \\(W_{Aa} > W_{aa}\\) , and Case B will have a negative numerator, \\(W_{Aa} < W_{aa}\\) . So, in Case A, the equilibrium is positive when the denominator is positive, \\(2 W_{Aa} - W_{AA} - W_{aa} > 0\\) . While in case B the equilibrium is positive when the denominator is negative, \\(2 W_{Aa} - W_{AA} - W_{aa} < 0\\) . Now we can rearrange the equilibrium to show that it is less than 1 when \\[ \\begin{aligned} \\frac{W_{Aa} - W_{aa}}{2 W_{Aa} -W_{AA} - W_{aa}} &< 1\\\\ \\frac{W_{Aa} - W_{aa}}{2 W_{Aa} -W_{AA} - W_{aa}} - 1 &< 0\\\\ \\frac{W_{Aa} - W_{aa} - (2 W_{Aa} -W_{AA} - W_{aa})}{2 W_{Aa} -W_{AA} - W_{aa}} &< 0\\\\ \\frac{W_{AA} - W_{Aa}}{2 W_{Aa} -W_{AA} - W_{aa}} &< 0\\\\ \\frac{W_{Aa} - W_{AA}}{2 W_{Aa} -W_{AA} - W_{aa}} &> 0\\\\ \\end{aligned} \\] Again we need the numerator and denominator to have the same sign for this inequality to hold. In case A, where we've said that denominator is positive, this means we also need the numerator to be positive, \\(W_{Aa} > W_{AA}\\) . While in case B we said that the denominator is negative, so we also need the numerator to be negative, \\(W_{Aa} < W_{AA}\\) . Putting this all together, there is a biologically-relevant internal equilibrium when either Case A: \\(W_{Aa} > W_{aa}\\) and \\(W_{Aa} > W_{AA}\\) (which ensures \\(2 W_{Aa} - W_{AA} - W_{aa} > 0\\) ; go ahead and check!) Case B: \\(W_{Aa} < W_{aa}\\) and \\(W_{Aa} < W_{AA}\\) (which ensures \\(2 W_{Aa} - W_{AA} - W_{aa} < 0\\) ) Case A therefore represents \"heterozygote advantage\", \\(W_{AA} < W_{Aa} > W_{aa}\\) , while Case B represents \"heterozygote disadvantage\", \\(W_{AA} > W_{Aa} < W_{aa}\\) . 6. Summary In summary, the equilibria for the models we have looked at are: Model Discrete-time equilibria Continuous-time equilibria Exponential growth \\(\\hat n = 0\\) \\(\\hat n = 0\\) Logistic growth \\(\\hat n = 0, \\hat n = K\\) \\(\\hat n = 0, \\hat n = K\\) Haploid selection \\(\\hat p = 0, \\hat p = 1\\) \\(\\hat p = 0, \\hat p = 1\\) Diploid selection \\(\\hat p = 0, \\hat p = 1, \\hat p = \\frac{W_{Aa} - W_{aa}}{2W_{Aa} - W_{AA} - W_{AA}}\\) Not derived Make sure that you understand how to determine equilibria in discrete- and continuous-time and can derive the equilibria of the models above on your own.","title":"Lecture 7"},{"location":"lectures/lecture-07/#lecture-7-equilibria","text":"Run notes interactively?","title":"Lecture 7: Equilibria"},{"location":"lectures/lecture-07/#lecture-overview","text":"Equilibria Exponential growth Logistic growth Haploid selection Diploid selection Summary","title":"Lecture overview"},{"location":"lectures/lecture-07/#1-equilibria","text":"An equilibrium is any state of a system which tends to persist unchanged over time. For discrete-time models, the equilibria are defined as those values of the variables where no changes occur from one time step to the next. For example, those values of allele frequency \\(p_t\\) where \\[ \\begin{aligned} \\Delta p &= 0\\\\ p_{t+1} - p_t &= 0\\\\ p_{t+1} &= p_t \\end{aligned} \\] Similarly, for continuous-time models, the equilibria are defined as those values of the variables for which the rate of change in the variables equals zero. For example, those values of allele frequency \\(p\\) where \\[ \\frac{\\mathrm{d}p}{\\mathrm{d}t} = 0 \\] What are the equilibria for the following models? Model Discrete time Continous time Exponential growth \\(n_{t+1} = R n_t\\) \\(\\frac{\\mathrm{d}n}{\\mathrm{d}t} = r n\\) Logistic growth \\(n_{t+1} = (1 + r(1 - \\frac{n_t}{K}))n_t\\) \\(\\frac{\\mathrm{d}n}{\\mathrm{d}t} = r(1 - \\frac{n}{K})n\\) Haploid selection \\(p_{t+1} = \\frac{W_A p_t}{W_A p_t + W_a q_t}\\) \\(\\frac{\\mathrm{d}p}{\\mathrm{d}t} = s p(1-p)\\) Diploid selection \\(p_{t+1} = \\frac{p_t^2W_{AA} + p_t q_tW_{Aa}}{p_t^2W_{AA} + 2 p_t q_tW_{Aa} + q_t^2W_{aa}}\\) Not derived","title":"1. Equilibria"},{"location":"lectures/lecture-07/#2-exponential-growth","text":"Here, we will solve for the equilibria in both the discrete- and continuous-time exponential-growth models.","title":"2. Exponential growth"},{"location":"lectures/lecture-07/#discrete-time","text":"\\[ n_{t+1} = Rn_t \\] Set \\(n_{t+1} = n_t = \\hat n\\) and solve for \\(\\hat{n}\\) \\[ \\begin{aligned} \\hat n &= R\\hat n\\\\ \\hat n &= 0 \\end{aligned} \\]","title":"Discrete time"},{"location":"lectures/lecture-07/#continuous-time","text":"\\[ \\frac{\\mathrm{d}n}{\\mathrm{d}t} = r n \\] Set \\(\\mathrm{d}n/\\mathrm{d}t = 0\\) and \\(n = \\hat n\\) and solve for \\(\\hat n\\) \\[ \\begin{aligned} 0 &= r \\hat{n}\\\\ \\hat n &= 0 \\end{aligned} \\] So the only equilibrium in both discrete- and continuous-time exponential growth is extinction, \\(\\hat{n}=0\\) . Special case of parameters Notice above that \\(R=1\\) and \\(r=0\\) also satisfy the conditions for an equilibrium. These are called special cases of parameters . Here this refers to the case where individuals perfectly replace themselves so that the population remains constant from any starting value of \\(n\\) .","title":"Continuous time"},{"location":"lectures/lecture-07/#3-logistic-growth","text":"Here, we will solve for the equilibria in both the discrete- and continuous-time logistic-growth models.","title":"3. Logistic growth"},{"location":"lectures/lecture-07/#discrete-time_1","text":"\\[ n_{t+1} = \\left(1 + r\\left(1 - \\frac{n_t}{K}\\right)\\right)n_t \\] As above, we substitute \\(n_{t+1} = n_t = \\hat n\\) and want to solve for \\(\\hat{n}\\) . \\[ \\hat n = \\left(1 + r\\left(1 - \\frac{\\hat n}{K}\\right)\\right)\\hat{n} \\] Notice that one equilibrium is \\(\\hat n = 0\\) . However, this isn't the only equilibrium because dividing both sides by \\(\\hat n\\) results in \\[ \\begin{aligned} 1 &= 1 + r\\left(1 - \\frac{\\hat n}{K}\\right)\\\\ 0 &= r\\left(1 - \\frac{\\hat n}{K}\\right) \\end{aligned} \\] Here we have a special case of parameters, \\(r=0\\) , or \\[ \\begin{aligned} 0 &= 1 - \\frac{\\hat n}{K}\\\\ \\hat n &= K \\end{aligned} \\] There are therefore two equilibria: extinction, \\(\\hat{n}=0\\) , or carrying capacity, \\(\\hat{n}=K\\) .","title":"Discrete time"},{"location":"lectures/lecture-07/#continuous-time_1","text":"\\[ \\frac{\\mathrm{d}n}{\\mathrm{d}t} = r \\left(1 - \\frac{n}{K}\\right)n \\] We set \\(\\mathrm{d}n/\\mathrm{d}t=0\\) and \\(n=\\hat{n}\\) \\[ 0 = r \\left(1 - \\frac{\\hat n}{K}\\right)\\hat{n} \\] which is the same equation we had above in discrete-time, so the equilibria ( \\(\\hat n = 0,K\\) ) and the special case of parameters ( \\(r = 0\\) ) are also the same.","title":"Continuous time"},{"location":"lectures/lecture-07/#4-haploid-selection","text":"Here, we will solve for the equilibria in both the discrete- and continuous-time haploid-selection models.","title":"4. Haploid selection"},{"location":"lectures/lecture-07/#discrete-time_2","text":"\\[ p_{t+1} = \\frac{p_tW_A}{p_tW_A + q_tW_a} \\] Replace \\(p_{t+1}\\) and \\(p_t\\) with \\(\\hat p\\) and replace \\(q_t\\) with \\(\\hat q\\) and solve for \\(\\hat p\\) and \\(\\hat q\\) \\[ \\begin{aligned} \\hat{p} &= \\frac{\\hat p W_A}{\\hat p W_A + \\hat q W_a}\\\\ \\end{aligned} \\] We first see that \\(\\hat{p}=0\\) is an equilibrium. But there is more, since dividing by \\(\\hat p\\) gives \\[ \\begin{aligned} 1 &= \\frac{W_A}{\\hat p W_A + \\hat q W_a}\\\\ \\hat p W_A + \\hat q W_a &= W_A\\\\ \\hat q W_a &= (1-\\hat p) W_A \\end{aligned} \\] At this point we use \\(q=1-p\\) to write this in terms of \\(p\\) only \\[ (1-\\hat p) W_a = (1-\\hat p) W_A \\] So \\(\\hat p =1\\) is another equilibrium. And finally, dividing by \\((1-\\hat p)\\) gives a special case of parameters, \\(W_A=W_a\\) . To summarize, the allele frequency will not change from one generation to the next in our discrete-time haploid-selection model when \\(\\hat p = 0 \\Longrightarrow\\) the population is \"fixed\" for the \\(a\\) allele \\(\\hat p = 1 \\Longrightarrow\\) the population is fixed for the \\(A\\) allele \\(W_A = W_a \\Longrightarrow\\) the two alleles have equal fitness (\"neutrality\")","title":"Discrete time"},{"location":"lectures/lecture-07/#continuous-time_2","text":"\\[ \\frac{\\mathrm{d}p}{\\mathrm{d}t} = sp(1-p) \\] In the continuous-time model, we set the derivative equal to zero and \\(p=\\hat{p}\\) \\[ \\begin{aligned} 0 &= s\\hat p(1 -\\hat p) \\end{aligned} \\] And we again find the same equilibria ( \\(\\hat p=0,1\\) ) and special case of parameters ( \\(s=0\\) , i.e., neutrality).","title":"Continuous time"},{"location":"lectures/lecture-07/#5-diploid-selection","text":"","title":"5. Diploid selection"},{"location":"lectures/lecture-07/#discrete-time_3","text":"Here, we will solve for the equilibria in the discrete-time diploid-selection model \\[ p_{t+1} = \\frac{p_t^2 W_{AA} + p_t q_t W_{Aa}}{p_t^2 W_{AA} + 2 p_t q_t W_{Aa} + q_t^2 W_{aa}} \\] We replace \\(p_{t+1}\\) and \\(p_t\\) with \\(\\hat p\\) and \\(q_t\\) with \\(\\hat{q}\\) and solve for \\(\\hat p\\) and \\(\\hat q\\) \\[ \\begin{aligned} \\hat{p} &= \\frac{\\hat{p}^2 W_{AA} + \\hat{p} \\hat{q} W_{Aa}}{\\hat{p}^2 W_{AA} + 2 \\hat{p} \\hat{q} W_{Aa} + \\hat{q}^2 W_{aa}}\\\\ \\hat{p} &= \\frac{\\hat{p}(\\hat p W_{AA} + \\hat{q} W_{Aa})}{\\hat{p}^2 W_{AA} + 2 \\hat{p} \\hat{q} W_{Aa} + \\hat{q}^2 W_{aa}} \\end{aligned} \\] We see that \\(\\hat{p}=0\\) is one equilibrium. Moving on, dividing by \\(\\hat p\\) gives \\[ \\begin{aligned} 1 &= \\frac{\\hat p W_{AA} + \\hat{q} W_{Aa}}{\\hat{p}^2 W_{AA} + 2 \\hat{p} \\hat{q} W_{Aa} + \\hat{q}^2 W_{aa}}\\\\ \\hat{p}^2 W_{AA} + 2 \\hat{p} \\hat{q} W_{Aa} + \\hat{q}^2 W_{aa} &= \\hat p W_{AA} + \\hat{q} W_{Aa}\\\\ 0 &= (\\hat{p} - \\hat{p}^2) W_{AA} + (\\hat{q} - 2 \\hat{p} \\hat{q}) W_{Aa} - \\hat{q}^2 W_{aa}\\\\ 0 &= \\hat{p}(1 - \\hat{p}) W_{AA} + \\hat{q}(1 - 2 \\hat{p}) W_{Aa} - \\hat{q}^2 W_{aa}\\\\ 0 &= \\hat{q}(\\hat{p} W_{AA} + (1 - 2 \\hat{p}) W_{Aa} - \\hat{q} W_{aa}) \\end{aligned} \\] And so \\(\\hat{q}=0\\implies\\hat{p}=1\\) is another equilibrium. Dividing by \\(\\hat{q}\\) and putting everything in terms of \\(p\\) we have \\[ \\begin{aligned} 0 &= \\hat{p} W_{AA} + (1 - 2 \\hat{p}) W_{Aa} - \\hat{q} W_{aa}\\\\ 0 &= \\hat{p} W_{AA} + (1 - 2 \\hat{p}) W_{Aa} - (1 - \\hat{p}) W_{aa}\\\\ 0 &= \\hat{p}(W_{AA} -2W_{Aa} + W_{aa}) + W_{Aa} - W_{aa}\\\\ W_{aa} - W_{Aa} &= \\hat p(W_{AA} -2W_{Aa} + W_{aa})\\\\ \\frac{W_{Aa} - W_{aa}}{2W_{Aa} - W_{AA} - W_{aa}} &= \\hat p\\\\ \\end{aligned} \\] We therefore have three equilibria under diploid selection: \\(\\hat{p}=0,\\frac{W_{Aa} - W_{aa}}{2W_{Aa} - W_{AA} - W_{aa}},1\\) . Since a frequency is bounded between 0 and 1, we must have \\(0 \\leq p \\leq 1\\) . We therefore call \\(\\hat{p}=0\\) and \\(\\hat{p}=1\\) boundary equilibria . These bounds also imply the third equilibrium is only biologically valid when \\[ 0 \\leq \\frac{W_{Aa} - W_{aa}}{2 W_{Aa} -W_{AA} - W_{aa}} \\leq 1 \\] When \\(W_{Aa} = W_{aa}\\) this equilibrium reduces to \\(\\hat{p}=0\\) and when \\(W_{Aa} = W_{AA}\\) this reduces to \\(\\hat{p}=1\\) (check this for yourself). The third equilibrium will be an internal equilibrium , representing a population with both \\(A\\) and \\(a\\) alleles, when \\[ 0 < \\frac{W_{Aa} - W_{aa}}{2 W_{Aa} -W_{AA} - W_{aa}} < 1 \\] The equilibrium is positive when the numerator and denominator have the same sign (i.e., are both positive or both negative). Let's split this into two \"cases\". Case A will have a positive numerator, \\(W_{Aa} > W_{aa}\\) , and Case B will have a negative numerator, \\(W_{Aa} < W_{aa}\\) . So, in Case A, the equilibrium is positive when the denominator is positive, \\(2 W_{Aa} - W_{AA} - W_{aa} > 0\\) . While in case B the equilibrium is positive when the denominator is negative, \\(2 W_{Aa} - W_{AA} - W_{aa} < 0\\) . Now we can rearrange the equilibrium to show that it is less than 1 when \\[ \\begin{aligned} \\frac{W_{Aa} - W_{aa}}{2 W_{Aa} -W_{AA} - W_{aa}} &< 1\\\\ \\frac{W_{Aa} - W_{aa}}{2 W_{Aa} -W_{AA} - W_{aa}} - 1 &< 0\\\\ \\frac{W_{Aa} - W_{aa} - (2 W_{Aa} -W_{AA} - W_{aa})}{2 W_{Aa} -W_{AA} - W_{aa}} &< 0\\\\ \\frac{W_{AA} - W_{Aa}}{2 W_{Aa} -W_{AA} - W_{aa}} &< 0\\\\ \\frac{W_{Aa} - W_{AA}}{2 W_{Aa} -W_{AA} - W_{aa}} &> 0\\\\ \\end{aligned} \\] Again we need the numerator and denominator to have the same sign for this inequality to hold. In case A, where we've said that denominator is positive, this means we also need the numerator to be positive, \\(W_{Aa} > W_{AA}\\) . While in case B we said that the denominator is negative, so we also need the numerator to be negative, \\(W_{Aa} < W_{AA}\\) . Putting this all together, there is a biologically-relevant internal equilibrium when either Case A: \\(W_{Aa} > W_{aa}\\) and \\(W_{Aa} > W_{AA}\\) (which ensures \\(2 W_{Aa} - W_{AA} - W_{aa} > 0\\) ; go ahead and check!) Case B: \\(W_{Aa} < W_{aa}\\) and \\(W_{Aa} < W_{AA}\\) (which ensures \\(2 W_{Aa} - W_{AA} - W_{aa} < 0\\) ) Case A therefore represents \"heterozygote advantage\", \\(W_{AA} < W_{Aa} > W_{aa}\\) , while Case B represents \"heterozygote disadvantage\", \\(W_{AA} > W_{Aa} < W_{aa}\\) .","title":"Discrete time"},{"location":"lectures/lecture-07/#6-summary","text":"In summary, the equilibria for the models we have looked at are: Model Discrete-time equilibria Continuous-time equilibria Exponential growth \\(\\hat n = 0\\) \\(\\hat n = 0\\) Logistic growth \\(\\hat n = 0, \\hat n = K\\) \\(\\hat n = 0, \\hat n = K\\) Haploid selection \\(\\hat p = 0, \\hat p = 1\\) \\(\\hat p = 0, \\hat p = 1\\) Diploid selection \\(\\hat p = 0, \\hat p = 1, \\hat p = \\frac{W_{Aa} - W_{aa}}{2W_{Aa} - W_{AA} - W_{AA}}\\) Not derived Make sure that you understand how to determine equilibria in discrete- and continuous-time and can derive the equilibria of the models above on your own.","title":"6. Summary"},{"location":"lectures/lecture-08/","text":"{ requestKernel: true, mountActivateWidget: true, mountStatusWidget: true, binderOptions: { repo: \"tomouellette/executable-cells\", ref: \"main\", binderUrl: \"https://gke.mybinder.org\", }, } Lecture 8: Local stability Run notes interactively? Lecture overview Stability Local stability analysis in discrete-time one-variable models Local stability analysis in continuous-time one-variable models Summary 1. Stability What is stability and stability analysis? What happens very near an equilibrium? Starting near an equilibrium, if the system moves towards the equilibrium over time the equilibrium is said to be locally stable . In contrast, if the system moves away from the equilibrium over time the equilibrium is said to be unstable . An equilibrium point is said to be globally stable if all initial conditions lead to it. Our goal: to determine whether a small perturbation away from an equilibrium point will grow or shrink in magnitude over time \\(\\Longrightarrow\\) local stability analysis . Example Consider logistic growth in discrete time, with \\(K = 1000\\) and \\(r = 0.5\\) . For populations started near carrying capacity (e.g., \\(n_t = 900\\) ), we see that they move closer to the carrying capacity over time. import numpy as np import matplotlib.pyplot as plt # logistic growth recursion def f(nt,r,k): return nt * (1 + r * (1 - nt / k)) # Build cobweb plotting function def cobweb_logistic(n0, r, k, max=np.inf): t, nnow, nnext = 0, n0, 0 #initial conditions while t < max: yield nnow, nnext #current value of n(t) and n(t+1) nnext = f(nnow,r,k) yield nnow, nnext #current value of n(t) and n(t+1) nnow = nnext #update n(t) t += 1 #update t # Plot def plot_logistic_with_cobweb(r, k, n0, ncobs=10, ax=None): # Plot the curves (add an additional curve past equilibrium to show stability) xs = np.linspace(0,k*1.5,100) #x values if ax == None: fig, ax = plt.subplots() #1:1 line ax.plot(xs, xs, color='black', linestyle='dashed') # recursion ax.plot(xs, [f(x,r,k) for x in xs], color='black') # cobweb cobweb = np.array([i for i in cobweb_logistic(n0, r, k, ncobs)]) plt.plot(cobweb[:,0], cobweb[:,1], color='blue') #aesthetics ax.set_ylim(0,None) ax.set_xlim(0,None) ax.set_xlabel('$n_t$') ax.set_ylabel('$n_{t+1}$') return ax plot_logistic_with_cobweb(n0=900,r=0.5, k=1000, ncobs=1100) plt.show() As we discussed when introducing cobweb diagrams, in this case we move to the right when \\(n_t<K\\) because the recursion (solid line) is above the 1:1 line (dashed), i.e., \\(n_{t+1}>n_t\\) . Similarly, we move to the left when \\(n_t>K\\) because the recursion is below the 1:1 line. Now, we know the 1:1 line has a slope of 1. Since the recursion crosses this line going from above to below (as we move to the right) at the equilibrium \\(n_t=K\\) , we know the slope of recursion is less than 1 at that point, \\( \\(\\left.\\frac{\\mathrm{d}n_{t+1}}{\\mathrm{d}n_t}\\right|_{n_t=K}<1\\) \\) In this case we also see that the slope is positive. Now what about if we had \\(r = -0.5\\) ? plot_logistic_with_cobweb(r=-0.5, k=1000, n0=900) plt.show() We see that we now move away from the equilibrium at \\(n_t=K\\) . Because the recursion is now steeper than the 1:1 line at that point, we know the slope of the recursion at \\(n_t = K\\) is now greater than 1 \\[\\left.\\frac{\\mathrm{d}n_{t+1}}{\\mathrm{d}n_t}\\right|_{n_t=K}>1\\] So how does knowing the slope of the recursion at the equilibrium help? (e.g. at \\(n_t = K\\) ). If we have an equilibrium point, call it \\(a\\) , and we have a starting condition, \\(x\\) , which is near \\(a\\) , then we can use the Taylor Series to rewrite the recursion. Mathematical aside: Taylor series \\[ f(x) = \\sum_{k = 0}^{\\infty}\\frac{f^{(k)}(a)}{k!}(x-a)^k \\] where \\(f^{(k)}(a)\\) is the \\(k^{\\mathrm{th}}\\) derivative of the function with respect to \\(x\\) , evaluated at point \\(a\\) . (See section P1.3 in the text for more information). If we start near enough to the equilibrium, \\((x - a)^k\\) will be tiny for \\(k > 1\\) and the function will be dominated by the first two terms in the series, with \\(k = 0\\) and \\(k = 1\\) : \\[ f (x) \\simeq f (a) + f'(a)(x - a) \\] using \\(f^{(0)}(a) = f(a)\\) and the short-hand notation \\(f'(a) = f^{(1)}(a)\\) to describe the slope of \\(f\\) at \\(x=a\\) . This is great! No matter how complicated and non-linear an equation we have, we can get an approximate equation that describes the dynamics near an equilibrium point. This equation is linear in \\(x\\) and can therefore be easily analysed. Let's see how this works in discrete- and continuous-time models. 2. Local stability analysis in discrete-time one-variable models Given a recursion equation in one variable, \\(x(t+1) = f(x(t))\\) , with an equilibrium \\(\\hat{x}\\) , when will a small perturbation ( \\(\\epsilon\\) ) away from the equilibrium grow in magnitude over time? At time \\(t\\) , say that the population is a small distance from the equilibrium: \\(\\hat{x} + \\epsilon(t)\\) (Note that \\(\\epsilon(t)\\) might be negative). At time \\(t+1\\) , the population will be at \\(\\hat{x} + \\epsilon(t+1)\\) , which equals \\(f(\\hat{x} + \\epsilon(t))\\) . Using the Taylor Series of \\(f(\\hat{x} + \\epsilon(t))\\) around \\(\\epsilon(t)=0\\) : \\[ \\begin{aligned} \\hat{x} + \\epsilon(t+1) &= f(\\hat{x} + \\epsilon(t))\\\\ &\\approx f(\\hat{x}) + f'(\\hat{x})(\\hat{x} + \\epsilon(t) - \\hat{x})\\\\ &= f(\\hat{x}) + f'(\\hat{x})\\epsilon(t) \\end{aligned} \\] We know that \\(f(\\hat{x}) = \\hat{x}\\) because \\(\\hat{x}\\) is an equilibrium, which implies \\[ \\epsilon(t+1) \\approx f'(\\hat{x})\\epsilon(t) \\] This is the recursion for exponential growth, with reproductive factor \\(\\lambda = f'(\\hat{x})\\) . So knowing that \\[ \\epsilon (t+1) \\approx \\lambda \\epsilon (t) \\] means the perturbation will: move from one side of the equilibrium to the other (i.e., oscillate) if \\(\\lambda\\) is negative grow if \\(\\lambda<-1\\) \\(\\implies\\hat{x}\\) unstable or shrink if \\(-1<\\lambda<0\\) \\(\\implies\\hat{x}\\) locally stable stay on the same side of the equilibrium if \\(\\lambda\\) is positive and shrink if \\(0<\\lambda<1\\) \\(\\implies\\hat{x}\\) locally stable or grow if \\(1<\\lambda\\) \\(\\implies\\hat{x}\\) unstable Stability in discrete time therefore requires the slope of the recursion to be between -1 and 1 at the equilibrium, \\(-1<\\left.\\frac{\\mathrm{d}x_{t+1}}{\\mathrm{d}x_t}\\right|_{x_t=\\hat x}<1\\) . E.g., logistic growth Let's now return to the logistic growth model in discrete time as an example. Here the recursion is \\[ f(n) = n \\left(1 + r\\left(1 - \\frac{n}{K}\\right)\\right) \\] When \\(r = 0.5\\) we saw that \\(\\hat n = K\\) was locally stable and the slope of the recusion at \\(n = K\\) , \\(\\lambda = f'(K)\\) , was between 0 and 1. Whereas, when \\(r = -0.5\\) we saw that \\(\\hat n = K\\) was unstable and the slope of the recursion at \\(n = K\\) , \\(\\lambda = f'(K)\\) , was greater than 1. Now let's perform a local stability analysis to see, more generally, when \\(\\hat{n}=K\\) is locally stable. We first take the derivative of \\(f\\) with respect to \\(n\\) \\[ f'(n) = 1 + r - 2 r \\frac{n}{K} \\] Then we plug in the equilirbium value, \\(n=K\\) \\[ \\begin{aligned} f'(K) &= 1 + r - 2 r \\\\ &= 1 - r \\end{aligned} \\] This will be negative when \\(r > 1\\) , creating oscillations. The equilibrium will be stable when \\(-1 < 1 - r < 1 \\implies 0 < r < 2\\) . This is consistent with the cob-webs we just observed, as well as the bifurcation diagram we saw in a Lecture 5 (repeated again below), where we see cycling for values of \\(r\\) greater than 2. # Sample the periodicity of the oscillations # by taking unique values after reaching carrying capacity def log_map(r, n0=900, k=1000): return np.unique([nt[1] for t, nt in enumerate(n(n0, r, k, max=75)) if t > 30]) # Compute the logistic map for different growth rates in discrete time r, Nr = np.array([]), np.array([]) for i in np.linspace(1.5, 3, 1000): nl = log_map(i) r = np.hstack((r, [i for _ in range(len(nl))])) Nr = np.hstack((Nr, nl)) # Plot the logistic map on a black background fig, ax = plt.subplots() ax.patch.set_facecolor('black') ax.scatter(r, Nr, s=0.075, color='white') plt.show() plot_logistic_with_cobweb(r=2.5, k=1000, n0=900) plt.show() 3. Local stability analysis in continuous-time one-variable models As in discrete time, we focus on a small perturbation ( \\(\\epsilon\\) ) away from an equilibrium ( \\(\\hat{x}\\) ) and determine whether this perturbation will grow or shrink. If, at time \\(t\\) , the population is a small distance from equilibrium, \\(\\hat{x} + \\epsilon (t)\\) , the rate of change in \\(x\\) will be \\(\\mathrm{d}x/\\mathrm{d}t = \\mathrm{d}(\\hat{x} + \\epsilon (t))/\\mathrm{d}t\\) . In this case, \\(f(x)=\\mathrm{d}x/\\mathrm{d}t\\) is the function that we wish to approximate, using a Taylor Series of \\(f(\\hat{x} + \\epsilon (t))\\) around \\(\\epsilon (t)=0\\) \\[ \\begin{aligned} \\frac{\\mathrm{d}(\\hat{x} + \\epsilon (t))}{\\mathrm{d}t} &= f(\\hat{x} + \\epsilon (t))\\\\ &\\approx f(\\hat{x}) + f'(\\hat{x})(\\hat{x} + \\epsilon (t) - \\hat{x})\\\\ &= f(\\hat{x}) + f'(\\hat{x})\\epsilon(t) \\end{aligned} \\] Since \\(\\hat{x}\\) is an equilibrium \\(f(\\hat{x})\\) equals zero, leaving just \\(f'(\\hat{x})\\epsilon(t)\\) on the right-hand side. Furthermore, the left-hand side can be expanded and simplified ( \\(\\hat{x}\\) is a constant that does not change in time) \\[ \\begin{aligned} \\frac{\\mathrm{d}(\\hat{x}+\\epsilon (t))}{\\mathrm{d}t} &= \\frac{\\mathrm{d}\\hat{x}}{\\mathrm{d}t} + \\frac{\\mathrm{d}\\epsilon (t)}{\\mathrm{d}t}\\\\ &= \\frac{\\mathrm{d}\\epsilon (t)} {\\mathrm{d}t} \\end{aligned} \\] Combining the above, the perturbation will change over time at a rate \\[ \\frac{\\mathrm{d} \\epsilon(t)}{\\mathrm{d}t} \\approx f'(\\hat{x}) \\epsilon(t) \\] This is the same as exponential growth with growth rate \\(r=f'(\\hat{x})\\) . So what will the perturbation do then? Well, note that (as shown above) that the change in the perturbation is equal to \\[ \\frac{\\mathrm{d} \\epsilon(t)}{\\mathrm{d}t} \\simeq r \\epsilon(t) \\] The perturbation will therefore grow if \\(r>0\\) \\(\\implies\\hat{x}\\) unstable shrink if \\(r<0\\) \\(\\implies\\hat{x}\\) locally stable Stability in continuous time therefore requires the slope of the differential equation to be negative at the equilibrium, \\(\\left.\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(\\frac{\\mathrm{d}x}{\\mathrm{d}t}\\right)\\right|_{x=\\hat{x}} < 0\\) . Unlike in discrete time, there is no possibility for oscillations in continuous time. E.g., logistic growth Let's again look at the model of logistic growth \\[ f(n)=\\frac{\\mathrm{d}n}{\\mathrm{d}t} = rn \\left(1 - \\frac{n}{K}\\right) \\] The derivative of \\(f\\) with respect to \\(n\\) is \\[ f'(n) = r - 2 r\\frac{n}{K} \\] Plugging in \\(n=K\\) gives \\[ f'(K) = r - 2 r = -r \\] This implies that \\(r>0\\) causes local stability of \\(\\hat{n}=K\\) . We can check this is consistent with a graphical analysis, below. def f(n,r,k): 'differential equation for logistic growth' return n*r*(1-n/k) def plot_logistic_de(r,k,ax=None): 'plot differential equation for logistic growth as function of n' xs = np.linspace(0,k*1.5,100) #n values if ax == None: fig, ax = plt.subplots() # 0 line ax.plot(xs, [0 for _ in xs], color='black', linestyle='--') # differential equation ax.plot(xs, [f(x,r,k) for x in xs], color='black') #aesthetics ax.set_xlabel('$n$') ax.set_ylabel('$dn/dt$') return ax plot_logistic_de(r=0.5, k=1000) plt.show() plot_logistic_de(r=-0.5, k=1000) plt.show() 6. Summary Local stability analysis for discrete- and continuous-time models. take the derivative of the recursion/differential equation with respect to the variable, \\(f'(x)\\) plug in the equilibrium value of the variable, \\(f'(\\hat x)\\) determine the sign and magnitude (sign only in continuous-time)","title":"Lecture 8"},{"location":"lectures/lecture-08/#lecture-8-local-stability","text":"Run notes interactively?","title":"Lecture 8: Local stability"},{"location":"lectures/lecture-08/#lecture-overview","text":"Stability Local stability analysis in discrete-time one-variable models Local stability analysis in continuous-time one-variable models Summary","title":"Lecture overview"},{"location":"lectures/lecture-08/#1-stability","text":"","title":"1. Stability"},{"location":"lectures/lecture-08/#what-is-stability-and-stability-analysis","text":"What happens very near an equilibrium? Starting near an equilibrium, if the system moves towards the equilibrium over time the equilibrium is said to be locally stable . In contrast, if the system moves away from the equilibrium over time the equilibrium is said to be unstable . An equilibrium point is said to be globally stable if all initial conditions lead to it. Our goal: to determine whether a small perturbation away from an equilibrium point will grow or shrink in magnitude over time \\(\\Longrightarrow\\) local stability analysis .","title":"What is stability and stability analysis?"},{"location":"lectures/lecture-08/#example","text":"Consider logistic growth in discrete time, with \\(K = 1000\\) and \\(r = 0.5\\) . For populations started near carrying capacity (e.g., \\(n_t = 900\\) ), we see that they move closer to the carrying capacity over time. import numpy as np import matplotlib.pyplot as plt # logistic growth recursion def f(nt,r,k): return nt * (1 + r * (1 - nt / k)) # Build cobweb plotting function def cobweb_logistic(n0, r, k, max=np.inf): t, nnow, nnext = 0, n0, 0 #initial conditions while t < max: yield nnow, nnext #current value of n(t) and n(t+1) nnext = f(nnow,r,k) yield nnow, nnext #current value of n(t) and n(t+1) nnow = nnext #update n(t) t += 1 #update t # Plot def plot_logistic_with_cobweb(r, k, n0, ncobs=10, ax=None): # Plot the curves (add an additional curve past equilibrium to show stability) xs = np.linspace(0,k*1.5,100) #x values if ax == None: fig, ax = plt.subplots() #1:1 line ax.plot(xs, xs, color='black', linestyle='dashed') # recursion ax.plot(xs, [f(x,r,k) for x in xs], color='black') # cobweb cobweb = np.array([i for i in cobweb_logistic(n0, r, k, ncobs)]) plt.plot(cobweb[:,0], cobweb[:,1], color='blue') #aesthetics ax.set_ylim(0,None) ax.set_xlim(0,None) ax.set_xlabel('$n_t$') ax.set_ylabel('$n_{t+1}$') return ax plot_logistic_with_cobweb(n0=900,r=0.5, k=1000, ncobs=1100) plt.show() As we discussed when introducing cobweb diagrams, in this case we move to the right when \\(n_t<K\\) because the recursion (solid line) is above the 1:1 line (dashed), i.e., \\(n_{t+1}>n_t\\) . Similarly, we move to the left when \\(n_t>K\\) because the recursion is below the 1:1 line. Now, we know the 1:1 line has a slope of 1. Since the recursion crosses this line going from above to below (as we move to the right) at the equilibrium \\(n_t=K\\) , we know the slope of recursion is less than 1 at that point, \\( \\(\\left.\\frac{\\mathrm{d}n_{t+1}}{\\mathrm{d}n_t}\\right|_{n_t=K}<1\\) \\) In this case we also see that the slope is positive. Now what about if we had \\(r = -0.5\\) ? plot_logistic_with_cobweb(r=-0.5, k=1000, n0=900) plt.show() We see that we now move away from the equilibrium at \\(n_t=K\\) . Because the recursion is now steeper than the 1:1 line at that point, we know the slope of the recursion at \\(n_t = K\\) is now greater than 1 \\[\\left.\\frac{\\mathrm{d}n_{t+1}}{\\mathrm{d}n_t}\\right|_{n_t=K}>1\\] So how does knowing the slope of the recursion at the equilibrium help? (e.g. at \\(n_t = K\\) ). If we have an equilibrium point, call it \\(a\\) , and we have a starting condition, \\(x\\) , which is near \\(a\\) , then we can use the Taylor Series to rewrite the recursion. Mathematical aside: Taylor series \\[ f(x) = \\sum_{k = 0}^{\\infty}\\frac{f^{(k)}(a)}{k!}(x-a)^k \\] where \\(f^{(k)}(a)\\) is the \\(k^{\\mathrm{th}}\\) derivative of the function with respect to \\(x\\) , evaluated at point \\(a\\) . (See section P1.3 in the text for more information). If we start near enough to the equilibrium, \\((x - a)^k\\) will be tiny for \\(k > 1\\) and the function will be dominated by the first two terms in the series, with \\(k = 0\\) and \\(k = 1\\) : \\[ f (x) \\simeq f (a) + f'(a)(x - a) \\] using \\(f^{(0)}(a) = f(a)\\) and the short-hand notation \\(f'(a) = f^{(1)}(a)\\) to describe the slope of \\(f\\) at \\(x=a\\) . This is great! No matter how complicated and non-linear an equation we have, we can get an approximate equation that describes the dynamics near an equilibrium point. This equation is linear in \\(x\\) and can therefore be easily analysed. Let's see how this works in discrete- and continuous-time models.","title":"Example"},{"location":"lectures/lecture-08/#2-local-stability-analysis-in-discrete-time-one-variable-models","text":"Given a recursion equation in one variable, \\(x(t+1) = f(x(t))\\) , with an equilibrium \\(\\hat{x}\\) , when will a small perturbation ( \\(\\epsilon\\) ) away from the equilibrium grow in magnitude over time? At time \\(t\\) , say that the population is a small distance from the equilibrium: \\(\\hat{x} + \\epsilon(t)\\) (Note that \\(\\epsilon(t)\\) might be negative). At time \\(t+1\\) , the population will be at \\(\\hat{x} + \\epsilon(t+1)\\) , which equals \\(f(\\hat{x} + \\epsilon(t))\\) . Using the Taylor Series of \\(f(\\hat{x} + \\epsilon(t))\\) around \\(\\epsilon(t)=0\\) : \\[ \\begin{aligned} \\hat{x} + \\epsilon(t+1) &= f(\\hat{x} + \\epsilon(t))\\\\ &\\approx f(\\hat{x}) + f'(\\hat{x})(\\hat{x} + \\epsilon(t) - \\hat{x})\\\\ &= f(\\hat{x}) + f'(\\hat{x})\\epsilon(t) \\end{aligned} \\] We know that \\(f(\\hat{x}) = \\hat{x}\\) because \\(\\hat{x}\\) is an equilibrium, which implies \\[ \\epsilon(t+1) \\approx f'(\\hat{x})\\epsilon(t) \\] This is the recursion for exponential growth, with reproductive factor \\(\\lambda = f'(\\hat{x})\\) . So knowing that \\[ \\epsilon (t+1) \\approx \\lambda \\epsilon (t) \\] means the perturbation will: move from one side of the equilibrium to the other (i.e., oscillate) if \\(\\lambda\\) is negative grow if \\(\\lambda<-1\\) \\(\\implies\\hat{x}\\) unstable or shrink if \\(-1<\\lambda<0\\) \\(\\implies\\hat{x}\\) locally stable stay on the same side of the equilibrium if \\(\\lambda\\) is positive and shrink if \\(0<\\lambda<1\\) \\(\\implies\\hat{x}\\) locally stable or grow if \\(1<\\lambda\\) \\(\\implies\\hat{x}\\) unstable Stability in discrete time therefore requires the slope of the recursion to be between -1 and 1 at the equilibrium, \\(-1<\\left.\\frac{\\mathrm{d}x_{t+1}}{\\mathrm{d}x_t}\\right|_{x_t=\\hat x}<1\\) .","title":"2. Local stability analysis in discrete-time one-variable models"},{"location":"lectures/lecture-08/#eg-logistic-growth","text":"Let's now return to the logistic growth model in discrete time as an example. Here the recursion is \\[ f(n) = n \\left(1 + r\\left(1 - \\frac{n}{K}\\right)\\right) \\] When \\(r = 0.5\\) we saw that \\(\\hat n = K\\) was locally stable and the slope of the recusion at \\(n = K\\) , \\(\\lambda = f'(K)\\) , was between 0 and 1. Whereas, when \\(r = -0.5\\) we saw that \\(\\hat n = K\\) was unstable and the slope of the recursion at \\(n = K\\) , \\(\\lambda = f'(K)\\) , was greater than 1. Now let's perform a local stability analysis to see, more generally, when \\(\\hat{n}=K\\) is locally stable. We first take the derivative of \\(f\\) with respect to \\(n\\) \\[ f'(n) = 1 + r - 2 r \\frac{n}{K} \\] Then we plug in the equilirbium value, \\(n=K\\) \\[ \\begin{aligned} f'(K) &= 1 + r - 2 r \\\\ &= 1 - r \\end{aligned} \\] This will be negative when \\(r > 1\\) , creating oscillations. The equilibrium will be stable when \\(-1 < 1 - r < 1 \\implies 0 < r < 2\\) . This is consistent with the cob-webs we just observed, as well as the bifurcation diagram we saw in a Lecture 5 (repeated again below), where we see cycling for values of \\(r\\) greater than 2. # Sample the periodicity of the oscillations # by taking unique values after reaching carrying capacity def log_map(r, n0=900, k=1000): return np.unique([nt[1] for t, nt in enumerate(n(n0, r, k, max=75)) if t > 30]) # Compute the logistic map for different growth rates in discrete time r, Nr = np.array([]), np.array([]) for i in np.linspace(1.5, 3, 1000): nl = log_map(i) r = np.hstack((r, [i for _ in range(len(nl))])) Nr = np.hstack((Nr, nl)) # Plot the logistic map on a black background fig, ax = plt.subplots() ax.patch.set_facecolor('black') ax.scatter(r, Nr, s=0.075, color='white') plt.show() plot_logistic_with_cobweb(r=2.5, k=1000, n0=900) plt.show()","title":"E.g., logistic growth"},{"location":"lectures/lecture-08/#3-local-stability-analysis-in-continuous-time-one-variable-models","text":"As in discrete time, we focus on a small perturbation ( \\(\\epsilon\\) ) away from an equilibrium ( \\(\\hat{x}\\) ) and determine whether this perturbation will grow or shrink. If, at time \\(t\\) , the population is a small distance from equilibrium, \\(\\hat{x} + \\epsilon (t)\\) , the rate of change in \\(x\\) will be \\(\\mathrm{d}x/\\mathrm{d}t = \\mathrm{d}(\\hat{x} + \\epsilon (t))/\\mathrm{d}t\\) . In this case, \\(f(x)=\\mathrm{d}x/\\mathrm{d}t\\) is the function that we wish to approximate, using a Taylor Series of \\(f(\\hat{x} + \\epsilon (t))\\) around \\(\\epsilon (t)=0\\) \\[ \\begin{aligned} \\frac{\\mathrm{d}(\\hat{x} + \\epsilon (t))}{\\mathrm{d}t} &= f(\\hat{x} + \\epsilon (t))\\\\ &\\approx f(\\hat{x}) + f'(\\hat{x})(\\hat{x} + \\epsilon (t) - \\hat{x})\\\\ &= f(\\hat{x}) + f'(\\hat{x})\\epsilon(t) \\end{aligned} \\] Since \\(\\hat{x}\\) is an equilibrium \\(f(\\hat{x})\\) equals zero, leaving just \\(f'(\\hat{x})\\epsilon(t)\\) on the right-hand side. Furthermore, the left-hand side can be expanded and simplified ( \\(\\hat{x}\\) is a constant that does not change in time) \\[ \\begin{aligned} \\frac{\\mathrm{d}(\\hat{x}+\\epsilon (t))}{\\mathrm{d}t} &= \\frac{\\mathrm{d}\\hat{x}}{\\mathrm{d}t} + \\frac{\\mathrm{d}\\epsilon (t)}{\\mathrm{d}t}\\\\ &= \\frac{\\mathrm{d}\\epsilon (t)} {\\mathrm{d}t} \\end{aligned} \\] Combining the above, the perturbation will change over time at a rate \\[ \\frac{\\mathrm{d} \\epsilon(t)}{\\mathrm{d}t} \\approx f'(\\hat{x}) \\epsilon(t) \\] This is the same as exponential growth with growth rate \\(r=f'(\\hat{x})\\) . So what will the perturbation do then? Well, note that (as shown above) that the change in the perturbation is equal to \\[ \\frac{\\mathrm{d} \\epsilon(t)}{\\mathrm{d}t} \\simeq r \\epsilon(t) \\] The perturbation will therefore grow if \\(r>0\\) \\(\\implies\\hat{x}\\) unstable shrink if \\(r<0\\) \\(\\implies\\hat{x}\\) locally stable Stability in continuous time therefore requires the slope of the differential equation to be negative at the equilibrium, \\(\\left.\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(\\frac{\\mathrm{d}x}{\\mathrm{d}t}\\right)\\right|_{x=\\hat{x}} < 0\\) . Unlike in discrete time, there is no possibility for oscillations in continuous time.","title":"3. Local stability analysis in continuous-time one-variable models"},{"location":"lectures/lecture-08/#eg-logistic-growth_1","text":"Let's again look at the model of logistic growth \\[ f(n)=\\frac{\\mathrm{d}n}{\\mathrm{d}t} = rn \\left(1 - \\frac{n}{K}\\right) \\] The derivative of \\(f\\) with respect to \\(n\\) is \\[ f'(n) = r - 2 r\\frac{n}{K} \\] Plugging in \\(n=K\\) gives \\[ f'(K) = r - 2 r = -r \\] This implies that \\(r>0\\) causes local stability of \\(\\hat{n}=K\\) . We can check this is consistent with a graphical analysis, below. def f(n,r,k): 'differential equation for logistic growth' return n*r*(1-n/k) def plot_logistic_de(r,k,ax=None): 'plot differential equation for logistic growth as function of n' xs = np.linspace(0,k*1.5,100) #n values if ax == None: fig, ax = plt.subplots() # 0 line ax.plot(xs, [0 for _ in xs], color='black', linestyle='--') # differential equation ax.plot(xs, [f(x,r,k) for x in xs], color='black') #aesthetics ax.set_xlabel('$n$') ax.set_ylabel('$dn/dt$') return ax plot_logistic_de(r=0.5, k=1000) plt.show() plot_logistic_de(r=-0.5, k=1000) plt.show()","title":"E.g., logistic growth"},{"location":"lectures/lecture-08/#6-summary","text":"Local stability analysis for discrete- and continuous-time models. take the derivative of the recursion/differential equation with respect to the variable, \\(f'(x)\\) plug in the equilibrium value of the variable, \\(f'(\\hat x)\\) determine the sign and magnitude (sign only in continuous-time)","title":"6. Summary"},{"location":"lectures/lecture-09/","text":"{ requestKernel: true, mountActivateWidget: true, mountStatusWidget: true, binderOptions: { repo: \"tomouellette/executable-cells\", ref: \"main\", binderUrl: \"https://gke.mybinder.org\", }, } Lecture 9: General solutions (univariate) Run notes interactively? Lecture overview General solutions Linear models in discrete time Nonlinear models in discrete time Linear models in continuous time Nonlinear models in continuous time Summary 1. General solutions Last week we learned how to find equilibria and determine their local stability in models with one variable (univariate). Those analyses describe the long-term dynamics of our models, i.e., what we expect after a long time has passed. This week we\u2019ll look at some simple cases where we can describe the entire dynamics, including the short-term, by solving for the variable as a function of time, \\(x_t = f(t)\\) This is called a general solution . 2. Linear models in discrete time With a single variable, \\(x\\) , in discrete time all linear models can be written \\[ x_{t+1} = a x_t + b \\] There are two cases that we will consider separately: 1) \\(b = 0\\) and 2) \\(b \\neq 0\\) . Brute force iteration When \\(b = 0\\) we can use brute force iteration \\[ \\begin{aligned} x_t &= a x_{t-1}\\\\ &= a a x_{t-2}\\\\ &= a a a x_{t-3}\\\\ &\\vdots\\\\ &= a\\cdots a x_0\\\\ &= a^t x_0 \\end{aligned} \\] This is the general solution for exponential growth in discrete time, with reproductive factor \\(a\\) . We can see that our variable will oscillate around the equilibrium ( \\(\\hat{x}=0\\) ) if \\(a<0\\) and will either approach the equilibrium ( \\(|a|<1\\) ) or depart from it ( \\(|a|>1\\) ), consistent with our local stability analysis. See this for yourself by playing with the value of \\(a\\) in the plot below. import matplotlib.pyplot as plt a, x0 = 0.99, 10 #define parameter values and initial condition ts = range(1000) #time values xs = [a**t * x0 for t in ts] #variable values from general solution plt.scatter(ts, xs) #plot discretely plt.ylabel('$x(t)$') plt.xlabel('$t$') plt.show() Solving affine models When \\(b \\neq 0\\) (which gives us what is called an affine model ) we need to use a transformation , much like we did when determining local stability. Step 1 : Solve for the equilibrium \\[ \\begin{aligned} \\hat{x} &= a \\hat{x} + b \\\\ \\hat{x} &= \\frac{b}{1 - a} \\end{aligned} \\] Note Note that if \\(a=1\\) there is no equilibrium for \\(b\\neq0\\) , and instead you can use brute force iteration to show that \\(x_t = x_0 + b t\\) . Step 2 : Define \\(\\delta_t = x_t - \\hat{x}\\) , the deviation of our variable from the equilibrium (this is our transformation). Step 3 : Write the recursion equation for the transformed variable \\[ \\begin{aligned} \\delta_{t+1} &= x_{t+1} - \\hat{x} \\\\ &= a x_t + b - \\hat{x} \\\\ &= a(\\delta_t + \\hat{x}) + b - \\hat{x}\\\\ &= a \\left(\\delta_t + \\frac{b}{1 - a}\\right) + b - \\frac{b}{1 - a}\\\\ &= a \\delta_t \\end{aligned} \\] Step 4 : This is the same recursion we derived above for \\(x\\) when \\(b=0\\) . So the general solution for the transformed variable is \\(\\delta_t = a^t \\delta_0\\) . Step 5 : Reverse transform back to \\(x_t\\) \\[ \\begin{aligned} x_t &= \\delta_t + \\hat{x}\\\\ &= a^t \\delta_0 + \\hat{x}\\\\ &= a^t (x_0 - \\hat{x}) + \\hat{x}\\\\ &= a^t x_0 + (1 - a^t)\\hat{x} \\end{aligned} \\] This says that our variable moves from \\(x_0\\) towards/away from \\(\\hat{x}\\) by a factor \\(a\\) per time step. Note that if \\(b=0\\) then \\(\\hat{x}=0\\) and this reduces to what we derived above, \\(x_t=a^t x_0\\) . Below we plot the general solution for a given value of \\(a\\) and \\(b\\) from a number of different intitial conditions. Try playing with the values of \\(a\\) and \\(b\\) and observe the different dynamics. a, b, x0 = 0.99, 1, 10 #define parameter values and initial condition ts = range(1000) #time values xs = [a**t * x0 + (1-a**t)*b/(1-a) for t in ts] #variable values from general solution plt.scatter(ts, xs) #plot discretely plt.ylabel('$x(t)$') plt.xlabel('$t$') plt.show() 3. Nonlinear models in discrete time Unfortunately there is no recipe to solve nonlinear models in discrete time, even with one variable. In fact, most of the time there is no general solution. To get a sense of why that might be, remember the chaos of logistic growth! import numpy as np # Generator for logistic growth def n(n0, r, k, max=np.inf): t, nt = 0, n0 while t < max: yield nt t, nt = t + 1, nt + r * nt * (1 - nt / k) # Sample the periodicity of the oscillations by taking unique values after reaching carrying capacity def log_map(r, n0=900, k=1000): return np.unique([nt for t, nt in enumerate(n(n0, r, k, max=75)) if t > 30]) # Compute the logistic map for different growth rates in discrete time r, Nr = np.array([]), np.array([]) for i in np.linspace(1.5, 3, 1000): nl = log_map(i) r = np.hstack((r, [i for _ in range(len(nl))])) Nr = np.hstack((Nr, nl)) # Plot the logistic map on a black background fig, ax = plt.subplots() ax.patch.set_facecolor('black') ax.scatter(r, Nr, s=0.075, color='white') ax.set_xlabel('intrinsic growth rate, $r$') ax.set_ylabel('population size, $n$') plt.show() Solving with transformations Sometimes, however, you can find a transformation that works. For example, with haploid selection we have \\[ p_{t+1} = \\frac{W_A p_t}{W_A p_t + W_a q_t} \\] Brute force iteration will create a giant mess. But what about if we let \\(f_t = p_t/q_t\\) ? Noting that \\(q_{t+1} = 1 - p_{t+1} = (W_a p_t)/(W_A p_t + W_a q_t)\\) we have \\[ \\begin{aligned} f_{t+1} &= \\frac{p_{t+1}}{q_{t+1}}\\\\ &= \\frac{W_A p_t}{W_a q_t}\\\\ &= \\frac{W_A}{W_a} f_t \\end{aligned} \\] This implies that \\(f_t = (W_A/W_a)^t f_0\\) ! Converting back to \\(p_t\\) we see \\[ p_t = \\frac{f_t}{1-f_t} = \\frac{W_A^t p_0}{W_A^t p_0 + W_a^t q_0} \\] Solving with conceptualization An alternative way to derive this general solution is to think about (\"conceptualize\") the \\(A\\) and \\(a\\) alleles as two competing populations that each grow exponentially according to their fitness \\[ \\begin{aligned} n_A(t) &= W_A^t n_A(0)\\\\ n_a(t) &= W_a^t n_a(0) \\end{aligned} \\] Then the frequency of allele \\(A\\) at time \\(t\\) is \\[ p_t = \\frac{n_A(t)}{n_A(t) + n_a(t)} = \\frac{W_A^t n_A(0)}{W_A^t n_A(0) + W_a^t n_a(0)} \\] Dividing numerator and denominator by the total initial population size \\(n_A(0) + n_a(0)\\) \\[ p_t = \\frac{W_A^t p_0}{W_A^t p_0 + W_a^t q_0} \\] Below we plot this general solution for a given \\(W_A\\) , \\(W_a\\) , and \\(p_0\\) . WA, Wa, p0 = 1.1, 1, 0.01 #define parameter values and initial condition ts = range(100) #time values ps = [(WA**t * p0)/(WA**t * p0 + Wa**t * (1-p0)) for t in ts] #variable values from general solution plt.scatter(ts, ps) #plot discretely plt.ylabel('allele frequency, $p(t)$') plt.xlabel('generation, $t$') plt.show() 4. Linear models in continuous time In continuous time, a linear differential equation of one variable can be written \\[ \\frac{\\mathrm{d}x}{\\mathrm{d}t} = a x + b \\] Let's first look at the case where \\(b=0\\) . Separation of variables Here we can use a method called seperation of variables . That is, our differential equation can be written \\(\\mathrm{d}x/\\mathrm{d}t = f(x) g(t)\\) , i.e., we can separate the variables \\(x\\) and \\(t\\) . We can then re-write the equation as \\(\\mathrm{d}x/f(x) = g(t)\\mathrm{d}t\\) and take the indefinite integral of both sides. In our case we have \\(f(x)=a x\\) and \\(g(t)=1\\) so \\[ \\begin{aligned} \\int \\frac{\\mathrm{d}x}{a x} &= \\int \\mathrm{d}t \\\\ \\frac{\\ln(x)}{a} + c_1 &= t + c_2\\\\ \\ln(x) &= a t + c \\; \\text{(where } c = c_2 - c_1\\text{)}\\\\ x_t &= e^{a t} e^{a c} \\end{aligned} \\] Plugging in \\(t=0\\) we have \\(x_0 = e^{a c}\\) and so our general solution is \\[ x_t = x_0 e^{at} \\] This is the general solution for exponential growth in continuous time with growth rate \\(a\\) . We see that variable will either converge on ( \\(a<0\\) ) or depart from ( \\(a>0\\) ) the equilibrium ( \\(\\hat x=0\\) ), consistent with our local stability analysis. import matplotlib.pyplot as plt a, x0 = 0.01, 10 #define parameter values and initial condition ts = range(1000) #time values xs = [exp(a*t) * x0 for t in ts] #variable values from general solution plt.plot(ts, xs) #plot continuously plt.ylabel('$x(t)$') plt.xlabel('$t$') plt.show() Using transformations Now let's consider the case where \\(b\\neq0\\) . This can also be solved by the method of separation of variables but let's do it with a transformation, like we did in discrete time. Step 1 : Solve for the equilibrium, \\[ \\begin{aligned} 0 &= a \\hat{x} + b\\\\ \\hat{x} &= -b/a \\end{aligned} \\] Step 2 : Define \\(\\delta = x - \\hat{x}\\) as the deviation of the variable from equilibrium. Step 3 : Derive the differential equation for \\(\\delta\\) \\[ \\begin{aligned} \\frac{\\mathrm{d}\\delta}{\\mathrm{d}t} &= \\frac{\\mathrm{d}(x - \\hat{x})}{\\mathrm{d}t}\\\\ &= \\frac{\\mathrm{d}x}{\\mathrm{d}t} - \\frac{\\mathrm{d}\\hat{x}}{\\mathrm{d}t}\\\\ &= \\frac{\\mathrm{d}x}{\\mathrm{d}t}\\\\ &= a x + b\\\\ &= a (\\delta + \\hat{x}) + b\\\\ &= a(\\delta + -b/a) + b\\\\ &= a \\delta \\end{aligned} \\] Step 4 : This is the same differential equation we had above for \\(x\\) when \\(b=0\\) . The general solution is therefore \\(\\delta\\) is \\(\\delta_t = \\delta_0 e^{a t}\\) . Step 5 : Replace \\(\\delta\\) with \\(x - \\hat{x}\\) to back transform to our original variable \\[ x_t = e^{a t} x_0 + (1 - e^{a t})\\hat{x} \\] Similar to the discrete case (but without the oscillations), this tells us there is an exponential approach to ( \\(a<0\\) ) or departure from ( \\(a>0\\) ) the equilibrium, \\(\\hat{x}\\) . Below we plot this general solution for given values of \\(a\\) and \\(b\\) and a range of initial conditions, \\(x_0\\) . a, b, x0 = -0.01, 1, 10 #define parameter values and initial condition ts = range(1000) #time values xs = [exp(a*t) * x0 + (1-exp(a*t))*(-b/a) for t in ts] #variable values from general solution plt.plot(ts, xs) #plot continuously plt.ylabel('$x(t)$') plt.xlabel('$t$') plt.show() 5. Nonlinear models in continuous time Some nonlinear differential equations can also be solved. But there is no general recipe. Separation of variables Sometimes separation of variables works, as in the case of logistic growth and haploid selection (which are equivalent in form in continuous-time!). \\[ \\begin{aligned} \\frac{\\mathrm{d}p}{\\mathrm{d}t} &= s p (1-p)\\\\ \\frac{\\mathrm{d}p}{s p (1-p)} &= \\mathrm{d}t\\\\ \\left(\\frac{1}{s p} + \\frac{1/s}{1-p}\\right) \\mathrm{d}p &= \\mathrm{d}t \\;\\text{(method of partial fractions, rule A.19 in the text)}\\\\ \\int \\frac{1}{s p} \\mathrm{d}p + \\int \\frac{1}{s(1-p)} \\mathrm{d}p &= \\int \\mathrm{d}t\\\\ \\ln(p)/s - \\ln(1 - p)/s + c_1 &= t + c_2 \\\\ \\ln\\left(\\frac{p}{1-p}\\right) &= s t + s c \\; \\text{(where } c = c_2 - c_1\\text{)}\\\\ \\frac{p}{1-p} &= e^{st} e^{sc} \\end{aligned} \\] Plugging in \\(t=0\\) we have \\(p_0/(1-p_0) = e^{sc}\\) . Then solving this linear equation for \\(p\\) \\[ p_t = \\frac{e^{st} p_0}{1 - p_0 + e^{st} p_0} \\] This shows essentially the same dynamics as haploid selection in discrete time. s, p0 = 0.1, 0.01 #define parameter values and initial condition ts = range(100) #time values ps = [(exp(s*t) * p0)/(1 - p0 + exp(s*t)*p0) for t in ts] #variable values from general solution plt.plot(ts, ps) #plot continuously plt.ylabel('allele frequency, $p(t)$') plt.xlabel('generation, $t$') plt.show() Alternative methods Separation of variables does not always work as it may not be possible to solve the integrals. However, separation of variables is not the only method. Box 6.2 in the text describes how to solve three forms of differential equations that are not amenable to separation of variables (ie, that cannot be written like \\(\\mathrm{d}x/\\mathrm{d}t = f(x) g(t)\\) ). 6. Summary Today we've covered how to find the general solution for some univariate models. We now have three methods to analyze univariate models: numerical and graphical analyses (for particular parameter values) finding equilibria and determining their local stability (general long-term dynamics) finding the general solution (general short- and long-term dynamics)","title":"Lecture 9"},{"location":"lectures/lecture-09/#lecture-9-general-solutions-univariate","text":"Run notes interactively?","title":"Lecture 9: General solutions (univariate)"},{"location":"lectures/lecture-09/#lecture-overview","text":"General solutions Linear models in discrete time Nonlinear models in discrete time Linear models in continuous time Nonlinear models in continuous time Summary","title":"Lecture overview"},{"location":"lectures/lecture-09/#1-general-solutions","text":"Last week we learned how to find equilibria and determine their local stability in models with one variable (univariate). Those analyses describe the long-term dynamics of our models, i.e., what we expect after a long time has passed. This week we\u2019ll look at some simple cases where we can describe the entire dynamics, including the short-term, by solving for the variable as a function of time, \\(x_t = f(t)\\) This is called a general solution .","title":"1. General solutions"},{"location":"lectures/lecture-09/#2-linear-models-in-discrete-time","text":"With a single variable, \\(x\\) , in discrete time all linear models can be written \\[ x_{t+1} = a x_t + b \\] There are two cases that we will consider separately: 1) \\(b = 0\\) and 2) \\(b \\neq 0\\) .","title":"2. Linear models in discrete time"},{"location":"lectures/lecture-09/#brute-force-iteration","text":"When \\(b = 0\\) we can use brute force iteration \\[ \\begin{aligned} x_t &= a x_{t-1}\\\\ &= a a x_{t-2}\\\\ &= a a a x_{t-3}\\\\ &\\vdots\\\\ &= a\\cdots a x_0\\\\ &= a^t x_0 \\end{aligned} \\] This is the general solution for exponential growth in discrete time, with reproductive factor \\(a\\) . We can see that our variable will oscillate around the equilibrium ( \\(\\hat{x}=0\\) ) if \\(a<0\\) and will either approach the equilibrium ( \\(|a|<1\\) ) or depart from it ( \\(|a|>1\\) ), consistent with our local stability analysis. See this for yourself by playing with the value of \\(a\\) in the plot below. import matplotlib.pyplot as plt a, x0 = 0.99, 10 #define parameter values and initial condition ts = range(1000) #time values xs = [a**t * x0 for t in ts] #variable values from general solution plt.scatter(ts, xs) #plot discretely plt.ylabel('$x(t)$') plt.xlabel('$t$') plt.show()","title":"Brute force iteration"},{"location":"lectures/lecture-09/#solving-affine-models","text":"When \\(b \\neq 0\\) (which gives us what is called an affine model ) we need to use a transformation , much like we did when determining local stability. Step 1 : Solve for the equilibrium \\[ \\begin{aligned} \\hat{x} &= a \\hat{x} + b \\\\ \\hat{x} &= \\frac{b}{1 - a} \\end{aligned} \\] Note Note that if \\(a=1\\) there is no equilibrium for \\(b\\neq0\\) , and instead you can use brute force iteration to show that \\(x_t = x_0 + b t\\) . Step 2 : Define \\(\\delta_t = x_t - \\hat{x}\\) , the deviation of our variable from the equilibrium (this is our transformation). Step 3 : Write the recursion equation for the transformed variable \\[ \\begin{aligned} \\delta_{t+1} &= x_{t+1} - \\hat{x} \\\\ &= a x_t + b - \\hat{x} \\\\ &= a(\\delta_t + \\hat{x}) + b - \\hat{x}\\\\ &= a \\left(\\delta_t + \\frac{b}{1 - a}\\right) + b - \\frac{b}{1 - a}\\\\ &= a \\delta_t \\end{aligned} \\] Step 4 : This is the same recursion we derived above for \\(x\\) when \\(b=0\\) . So the general solution for the transformed variable is \\(\\delta_t = a^t \\delta_0\\) . Step 5 : Reverse transform back to \\(x_t\\) \\[ \\begin{aligned} x_t &= \\delta_t + \\hat{x}\\\\ &= a^t \\delta_0 + \\hat{x}\\\\ &= a^t (x_0 - \\hat{x}) + \\hat{x}\\\\ &= a^t x_0 + (1 - a^t)\\hat{x} \\end{aligned} \\] This says that our variable moves from \\(x_0\\) towards/away from \\(\\hat{x}\\) by a factor \\(a\\) per time step. Note that if \\(b=0\\) then \\(\\hat{x}=0\\) and this reduces to what we derived above, \\(x_t=a^t x_0\\) . Below we plot the general solution for a given value of \\(a\\) and \\(b\\) from a number of different intitial conditions. Try playing with the values of \\(a\\) and \\(b\\) and observe the different dynamics. a, b, x0 = 0.99, 1, 10 #define parameter values and initial condition ts = range(1000) #time values xs = [a**t * x0 + (1-a**t)*b/(1-a) for t in ts] #variable values from general solution plt.scatter(ts, xs) #plot discretely plt.ylabel('$x(t)$') plt.xlabel('$t$') plt.show()","title":"Solving affine models"},{"location":"lectures/lecture-09/#3-nonlinear-models-in-discrete-time","text":"Unfortunately there is no recipe to solve nonlinear models in discrete time, even with one variable. In fact, most of the time there is no general solution. To get a sense of why that might be, remember the chaos of logistic growth! import numpy as np # Generator for logistic growth def n(n0, r, k, max=np.inf): t, nt = 0, n0 while t < max: yield nt t, nt = t + 1, nt + r * nt * (1 - nt / k) # Sample the periodicity of the oscillations by taking unique values after reaching carrying capacity def log_map(r, n0=900, k=1000): return np.unique([nt for t, nt in enumerate(n(n0, r, k, max=75)) if t > 30]) # Compute the logistic map for different growth rates in discrete time r, Nr = np.array([]), np.array([]) for i in np.linspace(1.5, 3, 1000): nl = log_map(i) r = np.hstack((r, [i for _ in range(len(nl))])) Nr = np.hstack((Nr, nl)) # Plot the logistic map on a black background fig, ax = plt.subplots() ax.patch.set_facecolor('black') ax.scatter(r, Nr, s=0.075, color='white') ax.set_xlabel('intrinsic growth rate, $r$') ax.set_ylabel('population size, $n$') plt.show()","title":"3. Nonlinear models in discrete time"},{"location":"lectures/lecture-09/#solving-with-transformations","text":"Sometimes, however, you can find a transformation that works. For example, with haploid selection we have \\[ p_{t+1} = \\frac{W_A p_t}{W_A p_t + W_a q_t} \\] Brute force iteration will create a giant mess. But what about if we let \\(f_t = p_t/q_t\\) ? Noting that \\(q_{t+1} = 1 - p_{t+1} = (W_a p_t)/(W_A p_t + W_a q_t)\\) we have \\[ \\begin{aligned} f_{t+1} &= \\frac{p_{t+1}}{q_{t+1}}\\\\ &= \\frac{W_A p_t}{W_a q_t}\\\\ &= \\frac{W_A}{W_a} f_t \\end{aligned} \\] This implies that \\(f_t = (W_A/W_a)^t f_0\\) ! Converting back to \\(p_t\\) we see \\[ p_t = \\frac{f_t}{1-f_t} = \\frac{W_A^t p_0}{W_A^t p_0 + W_a^t q_0} \\]","title":"Solving with transformations"},{"location":"lectures/lecture-09/#solving-with-conceptualization","text":"An alternative way to derive this general solution is to think about (\"conceptualize\") the \\(A\\) and \\(a\\) alleles as two competing populations that each grow exponentially according to their fitness \\[ \\begin{aligned} n_A(t) &= W_A^t n_A(0)\\\\ n_a(t) &= W_a^t n_a(0) \\end{aligned} \\] Then the frequency of allele \\(A\\) at time \\(t\\) is \\[ p_t = \\frac{n_A(t)}{n_A(t) + n_a(t)} = \\frac{W_A^t n_A(0)}{W_A^t n_A(0) + W_a^t n_a(0)} \\] Dividing numerator and denominator by the total initial population size \\(n_A(0) + n_a(0)\\) \\[ p_t = \\frac{W_A^t p_0}{W_A^t p_0 + W_a^t q_0} \\] Below we plot this general solution for a given \\(W_A\\) , \\(W_a\\) , and \\(p_0\\) . WA, Wa, p0 = 1.1, 1, 0.01 #define parameter values and initial condition ts = range(100) #time values ps = [(WA**t * p0)/(WA**t * p0 + Wa**t * (1-p0)) for t in ts] #variable values from general solution plt.scatter(ts, ps) #plot discretely plt.ylabel('allele frequency, $p(t)$') plt.xlabel('generation, $t$') plt.show()","title":"Solving with conceptualization"},{"location":"lectures/lecture-09/#4-linear-models-in-continuous-time","text":"In continuous time, a linear differential equation of one variable can be written \\[ \\frac{\\mathrm{d}x}{\\mathrm{d}t} = a x + b \\] Let's first look at the case where \\(b=0\\) .","title":"4. Linear models in continuous time"},{"location":"lectures/lecture-09/#separation-of-variables","text":"Here we can use a method called seperation of variables . That is, our differential equation can be written \\(\\mathrm{d}x/\\mathrm{d}t = f(x) g(t)\\) , i.e., we can separate the variables \\(x\\) and \\(t\\) . We can then re-write the equation as \\(\\mathrm{d}x/f(x) = g(t)\\mathrm{d}t\\) and take the indefinite integral of both sides. In our case we have \\(f(x)=a x\\) and \\(g(t)=1\\) so \\[ \\begin{aligned} \\int \\frac{\\mathrm{d}x}{a x} &= \\int \\mathrm{d}t \\\\ \\frac{\\ln(x)}{a} + c_1 &= t + c_2\\\\ \\ln(x) &= a t + c \\; \\text{(where } c = c_2 - c_1\\text{)}\\\\ x_t &= e^{a t} e^{a c} \\end{aligned} \\] Plugging in \\(t=0\\) we have \\(x_0 = e^{a c}\\) and so our general solution is \\[ x_t = x_0 e^{at} \\] This is the general solution for exponential growth in continuous time with growth rate \\(a\\) . We see that variable will either converge on ( \\(a<0\\) ) or depart from ( \\(a>0\\) ) the equilibrium ( \\(\\hat x=0\\) ), consistent with our local stability analysis. import matplotlib.pyplot as plt a, x0 = 0.01, 10 #define parameter values and initial condition ts = range(1000) #time values xs = [exp(a*t) * x0 for t in ts] #variable values from general solution plt.plot(ts, xs) #plot continuously plt.ylabel('$x(t)$') plt.xlabel('$t$') plt.show()","title":"Separation of variables"},{"location":"lectures/lecture-09/#using-transformations","text":"Now let's consider the case where \\(b\\neq0\\) . This can also be solved by the method of separation of variables but let's do it with a transformation, like we did in discrete time. Step 1 : Solve for the equilibrium, \\[ \\begin{aligned} 0 &= a \\hat{x} + b\\\\ \\hat{x} &= -b/a \\end{aligned} \\] Step 2 : Define \\(\\delta = x - \\hat{x}\\) as the deviation of the variable from equilibrium. Step 3 : Derive the differential equation for \\(\\delta\\) \\[ \\begin{aligned} \\frac{\\mathrm{d}\\delta}{\\mathrm{d}t} &= \\frac{\\mathrm{d}(x - \\hat{x})}{\\mathrm{d}t}\\\\ &= \\frac{\\mathrm{d}x}{\\mathrm{d}t} - \\frac{\\mathrm{d}\\hat{x}}{\\mathrm{d}t}\\\\ &= \\frac{\\mathrm{d}x}{\\mathrm{d}t}\\\\ &= a x + b\\\\ &= a (\\delta + \\hat{x}) + b\\\\ &= a(\\delta + -b/a) + b\\\\ &= a \\delta \\end{aligned} \\] Step 4 : This is the same differential equation we had above for \\(x\\) when \\(b=0\\) . The general solution is therefore \\(\\delta\\) is \\(\\delta_t = \\delta_0 e^{a t}\\) . Step 5 : Replace \\(\\delta\\) with \\(x - \\hat{x}\\) to back transform to our original variable \\[ x_t = e^{a t} x_0 + (1 - e^{a t})\\hat{x} \\] Similar to the discrete case (but without the oscillations), this tells us there is an exponential approach to ( \\(a<0\\) ) or departure from ( \\(a>0\\) ) the equilibrium, \\(\\hat{x}\\) . Below we plot this general solution for given values of \\(a\\) and \\(b\\) and a range of initial conditions, \\(x_0\\) . a, b, x0 = -0.01, 1, 10 #define parameter values and initial condition ts = range(1000) #time values xs = [exp(a*t) * x0 + (1-exp(a*t))*(-b/a) for t in ts] #variable values from general solution plt.plot(ts, xs) #plot continuously plt.ylabel('$x(t)$') plt.xlabel('$t$') plt.show()","title":"Using transformations"},{"location":"lectures/lecture-09/#5-nonlinear-models-in-continuous-time","text":"Some nonlinear differential equations can also be solved. But there is no general recipe.","title":"5. Nonlinear models in continuous time"},{"location":"lectures/lecture-09/#separation-of-variables_1","text":"Sometimes separation of variables works, as in the case of logistic growth and haploid selection (which are equivalent in form in continuous-time!). \\[ \\begin{aligned} \\frac{\\mathrm{d}p}{\\mathrm{d}t} &= s p (1-p)\\\\ \\frac{\\mathrm{d}p}{s p (1-p)} &= \\mathrm{d}t\\\\ \\left(\\frac{1}{s p} + \\frac{1/s}{1-p}\\right) \\mathrm{d}p &= \\mathrm{d}t \\;\\text{(method of partial fractions, rule A.19 in the text)}\\\\ \\int \\frac{1}{s p} \\mathrm{d}p + \\int \\frac{1}{s(1-p)} \\mathrm{d}p &= \\int \\mathrm{d}t\\\\ \\ln(p)/s - \\ln(1 - p)/s + c_1 &= t + c_2 \\\\ \\ln\\left(\\frac{p}{1-p}\\right) &= s t + s c \\; \\text{(where } c = c_2 - c_1\\text{)}\\\\ \\frac{p}{1-p} &= e^{st} e^{sc} \\end{aligned} \\] Plugging in \\(t=0\\) we have \\(p_0/(1-p_0) = e^{sc}\\) . Then solving this linear equation for \\(p\\) \\[ p_t = \\frac{e^{st} p_0}{1 - p_0 + e^{st} p_0} \\] This shows essentially the same dynamics as haploid selection in discrete time. s, p0 = 0.1, 0.01 #define parameter values and initial condition ts = range(100) #time values ps = [(exp(s*t) * p0)/(1 - p0 + exp(s*t)*p0) for t in ts] #variable values from general solution plt.plot(ts, ps) #plot continuously plt.ylabel('allele frequency, $p(t)$') plt.xlabel('generation, $t$') plt.show()","title":"Separation of variables"},{"location":"lectures/lecture-09/#alternative-methods","text":"Separation of variables does not always work as it may not be possible to solve the integrals. However, separation of variables is not the only method. Box 6.2 in the text describes how to solve three forms of differential equations that are not amenable to separation of variables (ie, that cannot be written like \\(\\mathrm{d}x/\\mathrm{d}t = f(x) g(t)\\) ).","title":"Alternative methods"},{"location":"lectures/lecture-09/#6-summary","text":"Today we've covered how to find the general solution for some univariate models. We now have three methods to analyze univariate models: numerical and graphical analyses (for particular parameter values) finding equilibria and determining their local stability (general long-term dynamics) finding the general solution (general short- and long-term dynamics)","title":"6. Summary"},{"location":"lectures/schedule/","text":"Schedule Lecture Topic Reading 1 Introduction Preface, 1.1, 1.4 (5p.) 2 Model construction Chapter 2 (34p.) 3 Exponential and logistic growth 3.1, 3.2 (8p.) 4 One-locus selection 3.3 (10p.) 5 Numerical and graphical techniques I (univariate) 4.1-4.3 (23p.) 6 Numerical and graphical techniques II (multivariate) 4.4-4.5 (12p.) 7 Equilibria (univariate) 5.1-5.2 (12p.) 8 Stability (univariate) 5.3 (13p.) 9 General solutions I (univariate) Chapter 6 (18p.) 10 Midterm review 11 General solutions II (multivariate) 12 Equilibria and stability (linear multivariate) 13 Demography 14 Equilibria and stability (nonlinear multivariate) 15 Evolutionary invasion analysis 16 Evolutionary invasion analysis - structured populations 17 Introduction to probability 18 More probability 19 More probability 20 TBD 21 TBD 22 TBD 23 Grad student presentations 24 Final review","title":"Schedule"},{"location":"lectures/schedule/#schedule","text":"Lecture Topic Reading 1 Introduction Preface, 1.1, 1.4 (5p.) 2 Model construction Chapter 2 (34p.) 3 Exponential and logistic growth 3.1, 3.2 (8p.) 4 One-locus selection 3.3 (10p.) 5 Numerical and graphical techniques I (univariate) 4.1-4.3 (23p.) 6 Numerical and graphical techniques II (multivariate) 4.4-4.5 (12p.) 7 Equilibria (univariate) 5.1-5.2 (12p.) 8 Stability (univariate) 5.3 (13p.) 9 General solutions I (univariate) Chapter 6 (18p.) 10 Midterm review 11 General solutions II (multivariate) 12 Equilibria and stability (linear multivariate) 13 Demography 14 Equilibria and stability (nonlinear multivariate) 15 Evolutionary invasion analysis 16 Evolutionary invasion analysis - structured populations 17 Introduction to probability 18 More probability 19 More probability 20 TBD 21 TBD 22 TBD 23 Grad student presentations 24 Final review","title":"Schedule"},{"location":"syllabus/assignments/","text":"Assignments Homeworks A list of homework problems will be released after class on Wednesday, with the solutions due by the start of class on Monday. Homeworks can be submitted online (Quercus) or on paper (in class). Labs Each computer lab contains a series of problems and the solutions are due by the end of the day (ideally by the end of the lab). Solutions can be submitted online (Quercus).","title":"Assignments"},{"location":"syllabus/assignments/#assignments","text":"","title":"Assignments"},{"location":"syllabus/assignments/#homeworks","text":"A list of homework problems will be released after class on Wednesday, with the solutions due by the start of class on Monday. Homeworks can be submitted online (Quercus) or on paper (in class).","title":"Homeworks"},{"location":"syllabus/assignments/#labs","text":"Each computer lab contains a series of problems and the solutions are due by the end of the day (ideally by the end of the lab). Solutions can be submitted online (Quercus).","title":"Labs"},{"location":"syllabus/course_structure/","text":"Course structure Learning objectives Mathematics is central to science because it provides a rigorous way to go from a set of assumptions (what we take to be true) to their logical consequences (what we want to know). In ecology & evolution this might be how we think SARS-CoV-2 may spread and evolve given a set of vaccination rates and travel restrictions, how caribou population sizes are predicted to respond to forecasted rates of climate change, or something much more abstract like the expected amount of genetic diversity in a randomly mating population. In this course we'll learn how to build, analyze, and interpret mathematical models of increasing complexity through readings, lectures, tutorials, assignments, computer labs, and a final project. By the end of the course you will be able to: build a model: go from a verbal description of a biological system to a set of equations analyze a model: manipulate a set of equations into a mathematical expression of interest interpret a model: translate mathematical expressions back into biological meaning Weekly tasks attend two lectures [time = 2h] attend one lab [time = 2h] read text [approx. time = 2h] do homework [approx. time = 2h] Grading scheme The scheme is slightly different for EEB430 and EEB1430 (where different the latter is in parentheses) 20% - homeworks 20% - labs 20% (15%) - midterm 15% (25%) - final project 25% (20%) - final Late fees: homeworks and labs: to facilitate us giving you rapid feedback and solutions, you will receive 1/2 of your grade if submitted <24 hours late and 0 for anything later final project: you will receive 9/10 of your grade if submitted <24 hours late, else 8/10 if <48 hours late, else ...","title":"Course structure"},{"location":"syllabus/course_structure/#course-structure","text":"","title":"Course structure"},{"location":"syllabus/course_structure/#learning-objectives","text":"Mathematics is central to science because it provides a rigorous way to go from a set of assumptions (what we take to be true) to their logical consequences (what we want to know). In ecology & evolution this might be how we think SARS-CoV-2 may spread and evolve given a set of vaccination rates and travel restrictions, how caribou population sizes are predicted to respond to forecasted rates of climate change, or something much more abstract like the expected amount of genetic diversity in a randomly mating population. In this course we'll learn how to build, analyze, and interpret mathematical models of increasing complexity through readings, lectures, tutorials, assignments, computer labs, and a final project. By the end of the course you will be able to: build a model: go from a verbal description of a biological system to a set of equations analyze a model: manipulate a set of equations into a mathematical expression of interest interpret a model: translate mathematical expressions back into biological meaning","title":"Learning objectives"},{"location":"syllabus/course_structure/#weekly-tasks","text":"attend two lectures [time = 2h] attend one lab [time = 2h] read text [approx. time = 2h] do homework [approx. time = 2h]","title":"Weekly tasks"},{"location":"syllabus/course_structure/#grading-scheme","text":"The scheme is slightly different for EEB430 and EEB1430 (where different the latter is in parentheses) 20% - homeworks 20% - labs 20% (15%) - midterm 15% (25%) - final project 25% (20%) - final Late fees: homeworks and labs: to facilitate us giving you rapid feedback and solutions, you will receive 1/2 of your grade if submitted <24 hours late and 0 for anything later final project: you will receive 9/10 of your grade if submitted <24 hours late, else 8/10 if <48 hours late, else ...","title":"Grading scheme"},{"location":"syllabus/exams/","text":"Exams Midterm Covers material from Lectures 1-9 and Labs 1-5 Wednesday October 19, 3:10-5PM Ramsay Wright 109/107 Final Covers material from all lectures and labs time and location TBA","title":"Exams"},{"location":"syllabus/exams/#exams","text":"","title":"Exams"},{"location":"syllabus/exams/#midterm","text":"Covers material from Lectures 1-9 and Labs 1-5 Wednesday October 19, 3:10-5PM Ramsay Wright 109/107","title":"Midterm"},{"location":"syllabus/exams/#final","text":"Covers material from all lectures and labs time and location TBA","title":"Final"},{"location":"syllabus/final_project/","text":"Final project Construct your own model. In this project you will use the tools you've learned in class and apply them to a model that you develop. The model can be about any phenomenon in ecology and evolution, as long as you make up the model. Be as creative as you want. You'll do the final project in two parts. Part 1: Describe your biological question and why this interests you. Describe your model in words (ie, the main assumptions) and explain the main structure with a diagram (eg, flow or life cycle diagram). Describe what your analysis might reveal (ie, your hypothesis). Max 2 pages. Due November 16. Part 2: Describe your model assumptions in detail, defining all parameters and variables. Write down the equations for your model. Analyze your model. Explain how the results address your original question. Suggest how the model could be improved or extended. Max 4 pages. Due December 7. And for grad students taking EEB1430, you'll also give a short presentation of your final project on December 7. Tip If you are having trouble coming up with a new model, take one of the models that we've analysed in the course and change one or more of its underlying assumptions to get a new set of equations. Then analyse these equations. Discuss the differences between the assumptions used and also between the results obtained.","title":"Final Project"},{"location":"syllabus/final_project/#final-project","text":"","title":"Final project"},{"location":"syllabus/final_project/#construct-your-own-model","text":"In this project you will use the tools you've learned in class and apply them to a model that you develop. The model can be about any phenomenon in ecology and evolution, as long as you make up the model. Be as creative as you want. You'll do the final project in two parts. Part 1: Describe your biological question and why this interests you. Describe your model in words (ie, the main assumptions) and explain the main structure with a diagram (eg, flow or life cycle diagram). Describe what your analysis might reveal (ie, your hypothesis). Max 2 pages. Due November 16. Part 2: Describe your model assumptions in detail, defining all parameters and variables. Write down the equations for your model. Analyze your model. Explain how the results address your original question. Suggest how the model could be improved or extended. Max 4 pages. Due December 7. And for grad students taking EEB1430, you'll also give a short presentation of your final project on December 7. Tip If you are having trouble coming up with a new model, take one of the models that we've analysed in the course and change one or more of its underlying assumptions to get a new set of equations. Then analyse these equations. Discuss the differences between the assumptions used and also between the results obtained.","title":"Construct your own model."},{"location":"syllabus/general_info/","text":"General info Land acknowledgement I wish to acknowledge this land on which the University of Toronto operates. For thousands of years it has been the traditional land of the Huron-Wendat, the Seneca, and the Mississaugas of the Credit. Today, this meeting place is still the home to many Indigenous people from across Turtle Island and I am grateful to have the opportunity to work on this land. For more information see University of Toronto's land acknowledgement . Group norms The University of Toronto is committed to equity, human rights, and respect for diversity. All members of the learning environment in this course should strive to create an atmosphere of mutual respect where all members of our community can express themselves, engage with each other, and respect one another\u2019s differences. U of T does not condone discrimination or harassment against any persons or communities. Please contact me if you have any concerns. For more information see the Code of Student Conduct . Accessibility The University provides academic accommodations for students with disabilities in accordance with the terms of the Ontario Human Rights Code . This occurs through a collaborative process that acknowledges a collective obligation to develop an accessible learning environment that both meets the needs of students and preserves the essential academic requirements of the University\u2019s courses and programs. Students with diverse learning styles and needs are welcome in this course. If you have a disability that may require accommodations, please feel free to get in touch with me and/or the Accessibility Services office . Religious observances The University provides reasonable accommodation of the needs of students who observe religious holy days other than those already accommodated by ordinary scheduling and statutory holidays. Students have a responsibility to alert members of the teaching staff in a timely fashion to upcoming religious observances and anticipated absences and I will make every reasonable effort to avoid scheduling tests, examinations or other compulsory activities at these times. Please reach out to me as early as possible to communicate any anticipated absences related to religious observances, and to discuss any possible related implications for course work. Family care responsibilities The University of Toronto strives to provide a family-friendly environment. You may wish to inform me if you are a student with family responsibilities. If you are a student parent or have family responsibilities, you also may wish to visit the Family Care Office website .","title":"General info"},{"location":"syllabus/general_info/#general-info","text":"","title":"General info"},{"location":"syllabus/general_info/#land-acknowledgement","text":"I wish to acknowledge this land on which the University of Toronto operates. For thousands of years it has been the traditional land of the Huron-Wendat, the Seneca, and the Mississaugas of the Credit. Today, this meeting place is still the home to many Indigenous people from across Turtle Island and I am grateful to have the opportunity to work on this land. For more information see University of Toronto's land acknowledgement .","title":"Land acknowledgement"},{"location":"syllabus/general_info/#group-norms","text":"The University of Toronto is committed to equity, human rights, and respect for diversity. All members of the learning environment in this course should strive to create an atmosphere of mutual respect where all members of our community can express themselves, engage with each other, and respect one another\u2019s differences. U of T does not condone discrimination or harassment against any persons or communities. Please contact me if you have any concerns. For more information see the Code of Student Conduct .","title":"Group norms"},{"location":"syllabus/general_info/#accessibility","text":"The University provides academic accommodations for students with disabilities in accordance with the terms of the Ontario Human Rights Code . This occurs through a collaborative process that acknowledges a collective obligation to develop an accessible learning environment that both meets the needs of students and preserves the essential academic requirements of the University\u2019s courses and programs. Students with diverse learning styles and needs are welcome in this course. If you have a disability that may require accommodations, please feel free to get in touch with me and/or the Accessibility Services office .","title":"Accessibility"},{"location":"syllabus/general_info/#religious-observances","text":"The University provides reasonable accommodation of the needs of students who observe religious holy days other than those already accommodated by ordinary scheduling and statutory holidays. Students have a responsibility to alert members of the teaching staff in a timely fashion to upcoming religious observances and anticipated absences and I will make every reasonable effort to avoid scheduling tests, examinations or other compulsory activities at these times. Please reach out to me as early as possible to communicate any anticipated absences related to religious observances, and to discuss any possible related implications for course work.","title":"Religious observances"},{"location":"syllabus/general_info/#family-care-responsibilities","text":"The University of Toronto strives to provide a family-friendly environment. You may wish to inform me if you are a student with family responsibilities. If you are a student parent or have family responsibilities, you also may wish to visit the Family Care Office website .","title":"Family care responsibilities"},{"location":"syllabus/instructors/","text":"Instructors Professor Matthew Osmond (he/him) email: mm.osmond@utoronto.ca office hours: Wednesday 11-12, Earth Sciences Centre (ESC) 3041 website: osmond-lab.github.io Teaching assistant Puneeth Deraje (he/him) email: puneeth.deraje@mail.utoronto.ca office hours: Thursday 10-10:30, ESC 3046","title":"Instructors"},{"location":"syllabus/instructors/#instructors","text":"","title":"Instructors"},{"location":"syllabus/instructors/#professor","text":"Matthew Osmond (he/him) email: mm.osmond@utoronto.ca office hours: Wednesday 11-12, Earth Sciences Centre (ESC) 3041 website: osmond-lab.github.io","title":"Professor"},{"location":"syllabus/instructors/#teaching-assistant","text":"Puneeth Deraje (he/him) email: puneeth.deraje@mail.utoronto.ca office hours: Thursday 10-10:30, ESC 3046","title":"Teaching assistant"},{"location":"syllabus/other_resources/","text":"Other resources There are many resources available at the University to help you succeed in this course. Below are a few: Writing Center Academic integrity More on academic integrity CTSI list of supports Academic success module Get help with Quercus","title":"Other resources"},{"location":"syllabus/other_resources/#other-resources","text":"There are many resources available at the University to help you succeed in this course. Below are a few: Writing Center Academic integrity More on academic integrity CTSI list of supports Academic success module Get help with Quercus","title":"Other resources"},{"location":"syllabus/textbook/","text":"Textbook Otto & Day 2007. A biologist's guide to mathematical modeling in ecology and evolution . UofT library e-copies UofT library physical-copies buy your own copy","title":"Textbook"},{"location":"syllabus/textbook/#textbook","text":"Otto & Day 2007. A biologist's guide to mathematical modeling in ecology and evolution . UofT library e-copies UofT library physical-copies buy your own copy","title":"Textbook"},{"location":"syllabus/when_and_where/","text":"When and where Lectures Monday & Wednesday, 10:10 - 11:00 AM, Ramsay Wright (RW) 142 Labs Wednesday, 3:10 - 5:00 PM, RW 109/107","title":"When and where"},{"location":"syllabus/when_and_where/#when-and-where","text":"","title":"When and where"},{"location":"syllabus/when_and_where/#lectures","text":"Monday & Wednesday, 10:10 - 11:00 AM, Ramsay Wright (RW) 142","title":"Lectures"},{"location":"syllabus/when_and_where/#labs","text":"Wednesday, 3:10 - 5:00 PM, RW 109/107","title":"Labs"}]}